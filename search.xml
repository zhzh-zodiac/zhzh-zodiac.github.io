<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo base command</title>
    <url>/2022/11/24/hexo-base-command/</url>
    <content><![CDATA[<blockquote>
<p>初始化&amp;一些基础命令</p>
</blockquote>
<span id="more"></span>

<h3 id="init-hexo"><a href="#init-hexo" class="headerlink" title="init hexo"></a>init hexo</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装主题 https://github.com/next-theme/hexo-theme-next</span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"></span><br><span class="line">// 安装 https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">npm install hexo-symbols-count-time</span><br><span class="line"></span><br><span class="line">// 安装 https://github.com/wzpan/hexo-generator-search</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"></span><br><span class="line">// 安装 https://github.com/next-theme/hexo-generator-searchdb</span><br><span class="line">npm install hexo-generator-searchdb</span><br><span class="line"></span><br><span class="line">// 安装deploy插件</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>00 开篇词 爱与被爱，是人一生最值得学习的能力</title>
    <url>/2022/11/24/love/00/</url>
    <content><![CDATA[<hr>
<p>从蹒跚学步到牙牙学语，从徒手开根号到闭眼背英文，我们一直在孜孜不倦地学习获取新的技能。然而学校从来没有开设一门课，教你如何去爱一个人，或者怎样享受被一个人爱。</p>
<p>甚至教导主任们视恋爱如洪水猛兽，一发现爱的苗头就要赶尽杀绝、斩草除根。</p>
<p>以至于当你遇到那个让你魂牵梦绕的人时，当你父母开始着急忙慌催婚时，你只能像一个从未训练过的士兵，手无寸铁地走向战场。更有甚者，有人相信了损友们不知道从哪个网络小说中学到的恋爱宝典，简直就像拿着贴了双面胶的炸药包上战场，结果可想而知。</p>
<span id="more"></span>

<p>谈恋爱看似很容易，只要不太挑，总能搂到人跟你组 cp。两个人眼一闭一睁，恋爱就算谈上了。谈恋爱又很难，找人难、追求难、维系关系难、分手也很难，相见时难别亦难。</p>
<p>这么多年，我看过许多以幸福模样开局，却草草收场的恋情，也见过很多在恋情中相互折磨的恋人。不是不爱，只是不懂如何去爱。</p>
<p>你是不是也曾经为了一个人，茶饭不思辗转反侧，费尽心力也只是友情以上恋爱未满；</p>
<p>你是不是也曾经在某个深夜，骤然醒来回想起某个人如同月光皎洁，却遗憾就此错过；</p>
<p>你是不是也突然醒悟，当初那句话若是换个说法，现在那个人是否还会留在身边。</p>
<p>于是，我们总在一遍遍地感叹，感叹命运为何如此残酷，总是让我们在错的时间遇到对的人，让我们一次次地在 KTV 大声唱着，“后来，当我学会如何去爱，你却已经不在。”</p>
<p>打住，不要伤春悲秋，这还上升不到命运的高度。其实，恋爱就是个技能问题。</p>
<h3 id="恋爱，是一项技能"><a href="#恋爱，是一项技能" class="headerlink" title="恋爱，是一项技能"></a>恋爱，是一项技能</h3><hr>
<p>但是，从理论上来说，恋爱这个技能，你也可以不学。</p>
<p>因为在一段长时间、近距离、高频次接触的、密切的亲密关系中，两个人一切的性格缺陷都会被放大。所以理论上，如果你是性格特别圆融的人，根本没有缺陷，那自然不用学，就像练了九阳神功的张无忌，什么武功都不用练，一路平 A 别人也破不了防。</p>
<p>不过一般历史上，我们称这种没有缺陷的人为完人、圣人，比如孔子、王阳明。这是最治本的路子，但也是普通人最难以企及的路子。</p>
<p>对我们普通人来说，学习这项技能就显得性价比非常高。恋爱技能就像太极剑，是让你掩盖破绽、化解矛盾，和自己，也和对方的缺陷达成和解的一种能力。</p>
<p>培养爱的能力，这里既涉及知识，也包括方法，最终上升到能力。</p>
<p>比如，我们经常聊防渣的话题，如果你连渣男渣女是什么样都不知道，以为只要女孩前凸后翘、性感妩媚、长袖善舞就是渣女，那自然防不住。识渣是防渣的第一步，这类知识不学自然不会，如果靠自己在恋爱中学习，那代价往往是撞得头破血流。</p>
<p>所以，学习这样一门课，往小了说，避开一个雷，能为你节约多少时间精力；往大了说，北大包丽、WePhone 苏享茂，不就是“死于”渣男渣女之手，学会这课还能救命。</p>
<p>再比如，我们还会聊“暧昧”的话题，就要讲如何利用暧昧期推进关系，讲亲密关系的六层交互理论。这种方法不学，你也有可能会不自觉地用，就好像很多人没上过游泳课也会游泳，没上过羽毛球课也会打羽毛球一样。但是成系统成体系学习过的人，稍加训练就比自己领悟的野路子强。</p>
<p>知识和方法，都是可复制、可传授的，所以恋爱能力是能够习得的。当然，我们在恋爱课堂里谈不成恋爱，还需要你在掌握了知识和方法，构建了正确的恋爱框架后，在生活中不断地积极实践，才能真正将其内化为自己的能力。</p>
<p>但是，恋爱这种能力，是一种需要长期学习和培训的能力。</p>
<p>它不像 21 天就能玩转的 Python 或者每天 5 分钟就能轻松记下的单词，“爱”这个能力没法突击。但是，越早学习，你就越不容易错过天命之人，而留下不容挽回的遗憾。</p>
<p>你也发现了，这个专栏叫《恋爱必修课》，不是想鼓吹人生要以恋爱为中心，而是想告诉你，爱与被爱，是人一生最值得学习的能力。其他技能，最多也只是支撑你事业发展的一条腿，爱的能力却是通向你爱情和家庭唯一的一张船票，现在这张船票的票价仅仅是两杯星巴克的价钱。</p>
<h3 id="恋爱，是自我成长"><a href="#恋爱，是自我成长" class="headerlink" title="恋爱，是自我成长"></a>恋爱，是自我成长</h3><hr>
<p>既然讲恋爱课，要讲什么呢？</p>
<p>有人问过我，要不要学习和了解一下最近大火的 PUA、茶艺学等学问；还有人问我，网上的恋爱套路，到底有几分可以效仿。我理解这种心态，在这个普通人都会几句土味情话的时代，好像学了就有可能找到对象，不学就要落后，落后就要孤单。</p>
<p>可是，为什么套路化和模板化的东西这么流行？背后的根本原因就是，我们害怕没人爱，害怕自己是单身。人口焦虑还未结束，信息焦虑的脚步就跟上了，随之而来的就是“爱情焦虑”。</p>
<p>别急，先停止你的焦虑。我们先来想一想，恋爱到底是什么？</p>
<p>在我做情感咨询的这么多年，问我“为什么和怎么办”的人很多，问我“是什么”的人还没碰见过。偏偏这个问题又极度重要，对“是什么”理解得越深刻，对“为什么”分析的原因才能越精确，“怎么办”的方法才能越有效。</p>
<p>现在搜索引擎的强大往往让人产生一种错觉，认为是什么这个问题只需要敲击几下键盘就唾手可得。不过互联网或者书本上给你的概念、定义、结论都是他人对经验的总结，是外在的认知。</p>
<p>在我看来，恋爱是自我成长。所有情感问题都是内在的领悟，是处理自己与这个世界的关系。</p>
<p>你好像觉得，有些人天生就受欢迎，总是有很多追求者，还有的人谈恋爱就像过家家一样轻松简单，但这都不是厉害，谈得多谈得快不代表谈的好。很多帅哥美女，追求者很多，但是饱受情伤，在爱情中是非常苦恼的。你必须要靠自己培养爱的能力，不断去解决爱情难题，在爱情这条路上，最终修炼和找到更好的自我，这才是爱情带给你的真正财富。</p>
<p>所以，我必须声明的是，这与你看到的大部分情感课都不一样。</p>
<p>在某些人眼里，或许是史上最没用的情感课。因为这个课程既不会讲搭讪技巧也不会提供撩妹的话术，我绝不会保证你学完这个课程后就成为恋爱达人，三言两语就轻松让人投怀送抱。</p>
<p>我甚至不能承诺，学完这个课程，你就能熟练掌握爱的能力。因为爱的能力没法凭空获得，只有在不断实践中才能掌握属于自己的秘籍。但是漫无目的地盲目实践，对于绝大多数人来说都没有效果，你往往不是谈了三次恋爱，而是把一个错误的恋爱模式重复了三次。</p>
<p>但是，我能够承诺的是，通过本次课程，帮助你建立一个正确的恋爱框架，让你在未来的人生中能够始终朝着正确方向构筑自己爱的能力。</p>
<p>以道驭术，术必成；离道之术，术必衰。人要成长，根本永远重于枝节。</p>
<h3 id="我会怎么讲这门课？"><a href="#我会怎么讲这门课？" class="headerlink" title="我会怎么讲这门课？"></a>我会怎么讲这门课？</h3><hr>
<p>那么，我会怎么给你讲这门课呢？</p>
<p>在本次课程中，我会以十个恋爱中的常见问题为主线，串起一段感情的开始、发展和结局。</p>
<p>比如说，在谈恋爱前，我们应该设定什么样子的目标，才能帮我们找到正确的方向？“TA 到底爱不爱我”这个问题，到底有没有标准答案？怎样开启和推进一段亲密关系，才是恋爱的正确打开方式？以及在暧昧阶段，如何把握合适的节奏，制造更多的火花？</p>
<p>当你走进一段感情后，是不是就可以高枕无忧了呢？并不是，恋爱中的问题一点也不会比恋爱前少，怎样创造新鲜感、仪式感？谈钱到底伤不伤感情？遇到“高级渣”怎么办？等等。</p>
<p>除了这些，还有分手了到底是谁的错，以及相亲的时候有哪些注意事项，我都会带着你一一分析。最后，我还给你准备了三个延伸阅读的话题，聊聊恋爱里那些有趣的事情。</p>
<p>这些问题都是我在情感咨询过程中，被问到次数最多的共性问题，是中文互联网上频上热搜的热门问题，也是多次帮人解决亲密关系中矛盾的关键问题。我相信，你在恋爱这条路上，一定多多少少会遇到类似的情况，不知道如何是好。</p>
<p>所以，在这门课程，我会就这些问题帮助你分析，并找到解决办法。</p>
<p>当你不知道找什么样的对象适合自己的时候，你可以使用我给你的“恋爱目标三步走”方法；</p>
<p>当你害怕自己遇到“渣男渣女”的时候，你可以使用我准备的“高级防渣手册”；</p>
<p>当你去参加一次相亲会，不知道怎么做的时候，你可以对照我说的“相亲注意事项”清单；</p>
<p>……</p>
<p>只要你愿意做出积极的改变，改变就从下一秒开始。</p>
<p>这门课中的大部分案例，来源于我的咨询者的真实经历，你会时不时地从中找到你的影子，所以你不用担心理解的门槛。同时，我还会在其中穿插大量武侠、影视、文学作品的典型事例，不仅帮助你理解消化，也能让我给你讲得更加有趣。</p>
<p>毕竟，我希望这门课是一门对你有用的课，也是一门有意思，让你回味无穷的课。</p>
<h3 id="我是谁？"><a href="#我是谁？" class="headerlink" title="我是谁？"></a>我是谁？</h3><hr>
<p>说了这么多，我得介绍一下我自己。</p>
<p>我叫李一帆，毕业于北京航空航天大学的理工科专业，现在是一名科研工作者，就职于科研事业单位。也许你会奇怪，为什么我这个“工科男”能成为情感专家，能来给你讲爱情？</p>
<p>其实，十多年前，我就与恋爱这个课题结缘。当时在校内网和天涯社区连载了“金庸教你谈恋爱”，受到了大量网友的喜爱，被评选为年度天涯社区武侠玄幻十大牛人之首。</p>
<p>在这之后，还有幸出了一本情感领域畅销书《爱情就是一物降一物》，因为输出内容注重逻辑、好玩易懂，排斥夸张尴尬的套路，我被很多读者和书迷认识并肯定。</p>
<p>在这个过程中，有许多朋友通过网络、电话甚至不远千里跑到北京向我求助，咨询情感问题。那个时候，情感咨询还不是很流行，他们之前遇到情感方面的难题，要么是靠密友东一嘴西一嘴拿主意，要么是去找心理咨询师。</p>
<p>在帮助他们的过程中，我由衷感到一种快乐和价值。帮助情侣和解、帮助分手的人走出情伤、帮助怀疑自己的人勇敢面对所爱……因此，我在工作之余，专注于情感咨询服务多年，为那些在恋爱中迷茫的人，提供关于亲密关系建立和维护方面的咨询服务，也帮助了越来越多的男男女女摆脱了困境，重新回到正常恋爱轨道。</p>
<p>再加上我这人兴趣广泛、所学驳杂，心理学、生物学、经济学都略懂皮毛；星座占卜算命也略知一二；历史文学影视也都能说道说道，所以，我不是一个学院派的心理咨询师做情感分析，我善于提供一些新鲜独特的视角，给予咨询者一些有益的启发和思考。</p>
<p>毕竟，爱情，从来不是只有它本身。它的背后，有价值、有责任、有自我，有许许多多复杂的事物和道理。也许探索爱情不简单，但也正是它的魅力所在。</p>
<p>接下来，和我一起来研究这个从古至今都迷人的话题吧！准备好了吗？让我们一起寻找爱情的本质，让你爱上恋爱，更让你爱上自己。</p>
<p>最后，愿天下有情人终成眷属！</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>01 是终点也是起点：你的恋爱目标是什么？</title>
    <url>/2022/11/24/love/01/</url>
    <content><![CDATA[<hr>
<p>今天是我们这堂恋爱课的第一讲，我想先和你聊聊“恋爱目标”这件事。</p>
<p>谈起目标，看似画饼充饥，可实际上，却是整个战略中最重要的一环。</p>
<p>正如每一个玩命复习的学生，目标大多是在考试中拿到理想分数；每一个玩命加班的打工人，目标大多是月底拿到更多薪水；每一个玩命忽悠你加班的资本家，目标都是先挣他一个亿。</p>
<p>但是，绝大多数玩命谈恋爱的人，投入了大量的时间、精力、金钱和情绪后，却自始至终都没搞懂自己的目标是什么，更说不出自己在一段恋爱中究竟想得到什么。</p>
<span id="more"></span>

<h3 id="为什么要有恋爱目标？"><a href="#为什么要有恋爱目标？" class="headerlink" title="为什么要有恋爱目标？"></a>为什么要有恋爱目标？</h3><hr>
<p>也许你会说了，没有目标不行吗？人生这场旅途，不就是边走边看边观摩吗？还真不是。</p>
<p>之前，有一个妆容精致的 OL 小姐姐，当时，她来找我做情感咨询。这个点奶茶都恨不得给我做个 SWOT 分析的女生，跟我大讲她的每一段情感遭遇，问我为什么她的恋情总是失败？</p>
<p>本来气势汹汹的她，被我问到你的恋爱目标是什么时，像一个课堂上开小差被抓包的学生，犹豫了半天，思索了半天，最后试探性告诉我，不以结婚为目的的谈恋爱都是耍流氓？</p>
<p>你看，这个答案说出口，她自己都没底。爱情跟考试一样，没学就是不会，“三短一长选一长”纯粹是求个心理安慰。我为什么要先问她恋爱目标？恋爱目标真的很重要吗？</p>
<p>是的，方向不正确，越努力，越失败。我举个例子，在金庸武侠中，有一个叫杨过的人，即使你没看过《神雕侠侣》，我相信你也多多少少听说过他和小龙女的“恋爱事迹”。</p>
<p>其实除了小龙女之外，杨过这一生遇见了无数妹子，郭芙、陆无双、程瑛、完颜萍、耶律燕、公孙绿萼、郭襄等等。这些小姐姐，梅兰菊竹各有所长，有颜值高的、武功高的、性格温柔的、有文化的、家世好的，可是为什么都是一见杨过终身误，却没有一个能拿下杨过的？</p>
<p>因为，她们不符合杨过的恋爱目标。杨过自幼失怙，说是找对象，实际上都是在找母爱。</p>
<p>这些妹子看见杨过，都是杨大哥、杨大侠，都把他当朋友、当暗恋对象、当救星、当武林豪杰，都是平视甚至仰视杨过的。所以，靠传统江湖女侠撩汉那一套都不好使啊！管你英雄救美、霸道女侠、刁蛮公主、古灵精怪的，杨过全然不吃这一套，杨过谈恋爱就是要弥补家庭温暖的呀。</p>
<p>而小龙女呢？小龙女拿杨过当儿子养了好几年，又当爹、又当妈，又管生活，又管教育还管思想，一把屎一把尿把他拉扯大，所以杨过认准小龙女生死相许。</p>
<p>只有小龙女拿杨过当孩子，一见面就摸摸头，说过儿长大了。其中蕴含的真意，翻译过来大概就是：儿子，叫爸爸。也只有在小龙女这里，杨过才会扔下大侠包袱，翻跟头、耍无赖，回归他最喜欢的小孩状态。</p>
<p>所以神雕同人小说都喜欢拿黄蓉去配杨过，这还真是书糙理不糙。因为神雕出场的所有女性，有一个算一个，能跟小龙女争一下的只有黄蓉，因为她是唯二能让杨过感受到母爱的角色。</p>
<p>这就叫，目标不对，努力白费；目标搞对，一步到位。</p>
<h3 id="什么是好的恋爱目标？"><a href="#什么是好的恋爱目标？" class="headerlink" title="什么是好的恋爱目标？"></a>什么是好的恋爱目标？</h3><hr>
<p>那么，什么是好的恋爱目标呢？这显然是一个没有标准答案的问题。</p>
<p>有人觉得理想的恋爱是琴瑟和谐、相敬如宾；</p>
<p>有人觉得恋爱是同生共死、轰轰烈烈到白头；</p>
<p>有人觉得非要天雷勾地火，看见对方就想“繁衍后代”才算真正恋爱；</p>
<p>有人觉得恋爱就是为了结婚，结婚了就算恋爱成功。</p>
<p>其实每一种都行，无所谓对错。这种只要你自己信就好的东西，我们统称为价值观。</p>
<p>就好比电影《姜子牙》里面说的，救一人还是救苍生。你爱救一人就救一人，你爱救苍生就救苍生，这种价值选择怎么样都不能称之为错。这个问题上，唯一可能出现的错误就是，打着救苍生的牌子害一人或者打着救一人的牌子害苍生——救谁都没有错，害人才有错。有人打着结婚的牌子骗人恋爱，或打恋爱的牌子骗人结婚——结婚和恋爱都没错，骗人才有错。</p>
<p>虽然，我们说，不同的人在不同的人生阶段，面对不同的恋爱对象，内心的恋爱目标也是不同的，我们无法给每个人确定一个一以贯之的目标。但是，我可以给你三条恋爱目标的原则。</p>
<h4 id="第一条：再差的目标，也胜过没有目标。"><a href="#第一条：再差的目标，也胜过没有目标。" class="headerlink" title="第一条：再差的目标，也胜过没有目标。"></a>第一条：再差的目标，也胜过没有目标。</h4><p>当你有了一个恋爱目标，哪怕你定的不是特别准，你也可以在生活中慢慢修正。但是，就怕你毫无目标，始终在原地兜兜转转；有一个恋爱目标，哪怕定的特别高，你也可以在人海中慢慢寻找，就怕你一点头绪都没有，碰见对的人都不自知。</p>
<p>《天龙八部》中有一个叫虚竹的人物，他的恋爱目标就是找初恋，但是初恋叫啥名、长啥样，一概不知。你看，这个恋爱目标是不是差到不能再差了，无异于大海捞针，几乎不可能实现。</p>
<p>但就是抱着这样的目标，他在西夏招亲的时候，碰见了梦姑。这是不是像极了我们的现实生活，所以说，只要你目标明确，从不彷徨，人口基数这么大，你总能碰到你想找的那个人。</p>
<p>你可能想问了，那我就想找个好看的、有钱的行吗？当然可以。</p>
<p>你可以在恋爱中追求阶级跃升，找家庭条件最好的，也可以在恋爱中追求精神契合，找兴趣爱好最一致的；你希望在一段恋爱关系中得到生活的照顾，可以专找贤妻良母型为你洗衣做饭的；也可以在一段恋爱关系中想得到事业的支持，专找女强人型愿意陪你披荆斩棘的。</p>
<p>但你不能不知道自己到底要什么，也不能什么都想要。</p>
<p>其实，最痛苦的就是这种半吊子。半吊子们，既无法彻底坚持理想主义，搞纯粹的爱情，又无法彻底向功利主义低头，去做现实的奴隶，他们站在此岸望彼岸，两头不靠岸。</p>
<h4 id="第二条：再好的目标，也得服从人生目标"><a href="#第二条：再好的目标，也得服从人生目标" class="headerlink" title="第二条：再好的目标，也得服从人生目标"></a>第二条：再好的目标，也得服从人生目标</h4><p>恋爱是人生的一部分，不能孤立地评判爱情，好的感情应当是让人生变得更好，而不是相反。</p>
<p>最近有部大热的剧叫《沉默的真相》，不知道你有没有看过？剧中的主人公叫江阳，是一名检察官，本来有着大好前途，但为了查清一起因高官性侵女童引发的冤案，也为了给山村支教同学侯贵平一个清白，付出了无数代价甚至身陷囹圄。</p>
<p>当然，在这个专栏里，我们要分析的不是江阳的正义感。我要讲的是，我当时在看剧时，观察到的剧中的一些情节，也就是江阳的爱情，虽然着墨不多，但也值得分析。</p>
<p>江阳的初恋是市副检察长的千金吴爱可，但是，最终他选择了和一名纺织厂女工郭红霞结婚。论出身、论颜值、论学历、论工作，吴爱可都是秒杀郭红霞的存在。那为什么江阳不选吴爱可呢？</p>
<p>因为，再好的恋爱目标，也要服从于人生目标。</p>
<p>江阳自从介入这个案件后，人生目标就是一件事——求个公道。吴爱可也很愿意求公道，但求公道的前提是她那个副检查长老爹能摆得平，当她发现对方势力过于强大可能伤及自身的时候，吴爱可就怂了，这就是我们经常能遇到的，精致的理想主义者。</p>
<p>相反，郭红霞出场不多，寥寥几笔我们就能发现，这个女人不是英雄江阳背后的女人，而是英雄本雄。无论顺境逆境、贫穷富贵，始终无怨无悔支持丈夫追查案件真相，可谓坚定执着、深明大义。我想作者将其命名为郭红霞的时候，必然脑海里也闪现过郭靖郭巨侠那平凡又伟大的母亲。</p>
<p>如果说，江阳是跃向空中划开乌云的追光者，一心只为求公道、求得人间正义，那么，红霞就是替他承受现实引力的守护人，志同道合、一体两面。</p>
<p>爱情就是一场自我修炼，找对象其实也是在找寻自我。</p>
<h4 id="第三条：恋爱目标，要以我为主"><a href="#第三条：恋爱目标，要以我为主" class="headerlink" title="第三条：恋爱目标，要以我为主"></a>第三条：恋爱目标，要以我为主</h4><p>所谓的以我为主，就是恋爱目标的制定，决定因素应当在自己而不是在他人。当你把目标从取悦他人转到取悦自己上来，你会发现恋爱将变得前所未有的简单，也前所未有的充满意义。</p>
<p>我曾经做情感咨询的时候，遇到过一个男生，他自嘲自己是标准的舔狗。每天给人发几十条消息却收不到几条回复，逢年过节就绞尽脑汁给人送礼物，却频频被拒收，只有在人家失恋空窗期的时候，他才能捞着几次约会机会。</p>
<p>他自我感觉状态很差，却又欲罢不能。姑娘对他的拒绝和冷漠让他十分痛苦，但偶尔的联系却又让他激动不已，见一次面就像打了兴奋剂，充能好几天。</p>
<p>我帮他分析，他之所以处于这种状态，未必是他真有多喜欢那个姑娘，更多是他沉浸于自己设定的游戏，只是想赢而已。偏偏这场游戏还不受他自己控制，纯 AI 代打，输赢皆在人家一念之间。</p>
<p>与其用尽心机、想尽办法让别人过得更好，不如让自己过得更好。当他下定决心斩断这段关系，开始尽力过好自己生活后没几个月，这个姑娘居然开始主动联系他，约他出去吃饭看电影了。</p>
<p>所以，尽管恋爱目标没有标准答案，但我都推荐你将这条作为自己的恋爱目标之一。</p>
<p>那就是通过一段感情，变成更好的自己，这不是鸡汤。</p>
<p>这个好，可以是事业的提升，我努力升职加薪，当上 CEO，就是为了迎娶白富美，走上人生巅峰，这当然没有问题；这个好，也可以是视野的开阔，为了一个人，去到了从未踏足的地方，见到了从未看过的风景，吃到了从未尝试的美食，多了以前想象不到的人生体验，这非常美好。</p>
<p>这个好，还可以是情感能力的提升，学会了如何爱一个人，也学会了如何享受被爱，明白了如何在习惯的生活中接纳一段亲密关系，这都是宝贵的财富。只有当你把恋爱的出发点和落脚点转回到自己身上时，你才会发现很多困扰自己的问题，都不再是问题。</p>
<h3 id="如何找到自己的恋爱目标？"><a href="#如何找到自己的恋爱目标？" class="headerlink" title="如何找到自己的恋爱目标？"></a>如何找到自己的恋爱目标？</h3><hr>
<p>现在，你应该对恋爱目标有一个新的认知了，那么，怎样才能找到自己的恋爱目标呢？我给你提供了一个简单的“目标三步走”小方法，你可以试一试。</p>
<p>Step1：在任意一个空闲的晚上，在一张纸上列出下面的内容：</p>
<p>你希望在一段感情中得到什么？</p>
<p>你绝对不能妥协牺牲的底线是什么？</p>
<p>这两点，每一点分别写五条，然后再划掉两条，这是一个不断权衡的过程。</p>
<p>Step2：在纸的另一侧，列出你人生的理想和中期、短期规划目标。</p>
<p>Step3：当你进入一段感情后（包括在追求期），每隔一段时间，你就拿出这个恋爱目标单进行迭代。如果你处于一段感情很久了，你也可以用这个方法，写下这段感情的目标。</p>
<p>当你觉得距离人生理想更接近了，就修改底线；</p>
<p>当你觉得距离人生理想更遥远了，就修改目标；</p>
<p>当你觉得这段感情偏离四个以上的恋爱目标，就认真考虑脱离这段感情。</p>
<p>示意图</p>
<img data-src="/2022/11/24/love/01/01.jpeg" class="">

<p>这个方法也许不会帮你确定一个完美的目标，但是一定会让你在这个过程中，有所收获。有的时候，在情感问题上，万有引力那个公式不重要，那个砸中牛顿的苹果才重要。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>恋爱目标不仅是目标，更是你寻找恋爱对象的标准，是你划定一段恋爱关系空间的依据，是做一切恋爱决策的基础，更是你认清自我的过程。</p>
<p>恋爱目标是个战略问题，市面上那些教你约会的方法，告白的方法，哄女朋友开心的等等具体方法都是战术问题，不解决战略问题，战术问题只会按住葫芦起了瓢。</p>
<p>所以，恋爱问题千变万化，但万变不离其宗。目标不对，努力白费；目标搞对，一步到位。</p>
<p>今天我们讲了三条确定恋爱目标的原则，一是再差的目标，也胜过没有目标；二是恋爱的目标，要服从人生的目标；三是恋爱目标，要以我为主。</p>
<p>丧失自我的恋爱关系，走到一起也是失败；帮你找到自我的恋爱关系，分手了也是成功。</p>
<p>“贵以身为天下，若可寄天下，爱以身为天下，若可托天下”。以我为主，不仅是恋爱的智慧，更是人生的智慧。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><hr>
<p>回忆你的感情经历，或者是展望你的未来，思考一下，你的恋爱目标是什么？有没有发生过变化？你的恋爱目标，是否符合这一讲所说的三个原则呢？</p>
<p>欢迎在留言区和我讨论、交流你的想法和见解，也可以留下你在婚恋上的困惑。</p>
<p>我会第一时间给你回复，期待你在爱情上的蜕变和成长。</p>
<p>感谢你的阅读，如果你的身边有不清楚恋爱目标的朋友，记得把这一讲分享给 Ta。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>02 拒绝焦虑状态：TA到底爱我吗？</title>
    <url>/2022/11/24/love/02/</url>
    <content><![CDATA[<p>在我做情感咨询的这么多年里，你猜一下，我被问的最多的一个问题是什么？这个问题就是：“老师，你觉得 Ta 到底喜不喜欢我？”或者，“Ta 到底爱不爱我？”</p>
<p>比如，曾经有个朋友问我：“有个女生主动给我发‘在吗’，是不是说明她喜欢我？我回复她以后，她又不理我，是不是说明她对我欲擒故纵？以后会不会对我有情感 PUA 呀？”</p>
<p>嗯，我看了看他聊天记录，告诉他，你隔了十几个钟头才回复人家，可能人家已经借到钱了……</p>
<p>还有人拿着图来咨询我，这个人以日期为横轴，以双方发信息的条数比为纵轴，做了一个点状图。他说，最近比例显著升高，是不是说明妹子开始对我感兴趣了？我好奇地问了一下他的职业。结果他告诉我，他是搞金属材料的在读博士生。好吧，真·钢铁直男。</p>
<p>可以说，几乎所有刚进入恋爱状态的男男女女，最爱干的事情就是拿着放大镜去观察心仪对象的一举一动，然后化身为福尔摩斯，动不动就能分析出对方一万字的心理活动，而这一切，就只是为了知道对方到底喜不喜欢自己。</p>
<p>那么，我们今天就来研究一下，到底该如何破解这个“千古谜题”。</p>
<span id="more"></span>

<h3 id="为什么你这么焦虑？"><a href="#为什么你这么焦虑？" class="headerlink" title="为什么你这么焦虑？"></a>为什么你这么焦虑？</h3><hr>
<p>想要找到破局之道，我们就先来好好研究一下这个“论题”。</p>
<p>先要思考的是，你为什么会问这个问题？在我看来，当你开始有这种困惑，迫切地想知道一个人对你的心意时，我不用听你任何的介绍，当然无法确定 Ta 是不是喜欢你，但有 3 点可以肯定：</p>
<p>第一，你对这个人有好感；</p>
<p>第二，你对这个人没把握；</p>
<p>第三，你希望找到一些依据给自己勇气，来支撑自己继续坚持。</p>
<p>因为，我完全能体会，当你深深爱上一个人的时候，Ta 的一言一行、一颦一笑都让你不能自已，你急切地希望从中能解读出一点蛛丝马迹，给自己支撑下去的力量和勇气。</p>
<p>我曾经也研究过语义分析来解析聊天记录；研究过摄影构图用以解析朋友圈自拍；当然，我也研究过心理学和微表情学，甚至研究过易经、塔罗牌、星座、星命术这些奇门异术。</p>
<p>目的只有一个，就是为了向自己证明——她也爱我。</p>
<p>但是，这种状态其实非常糟糕。以金庸老爷子的小说为例，在他的武侠世界里，有多少男男女女，但是，就有那么两个人，特别纠结别人喜不喜欢自己，还是两个男人。</p>
<p>一个是《书剑恩仇录》里的男主陈家洛，另一个是《飞狐外传》的男主胡斐。这两个人，你可能认识，听说过，但是不认识也不要紧，我来给你简单地讲讲。</p>
<p>首先是陈家洛这人，他喜欢一个叫霍青桐的妹子，但是他又不敢表达，一天到晚猜来猜去的，思考霍青桐到底喜不喜欢自己。结果，他看见了霍青桐和一个女扮男装的妹子在一起神态亲昵，陈家洛就醋意大发、自暴自弃，最后他选择了另一个女人的怀抱。</p>
<p>胡斐这个人更惨一点，他爱上了一个叫袁紫衣的妹子，那叫一个心生爱慕，小鹿乱撞。但是他也不敢表达，也是一天到晚猜来猜去，纠结袁紫衣到底喜不喜欢自己。两人不清不楚了一整本书，到最后，袁紫衣告诉胡斐，自己已经遁入空门，两个人不可能。</p>
<p>有没有觉得这两个人在感情中失败，还挺可怜的？但是，在武侠论坛，陈家洛和胡斐这哥俩，不仅没被同情，还常年高居渣男榜、最惹人嫌男主榜等各大负面榜单的前列，甚至超过很多反派。</p>
<p>为什么会这样？</p>
<p>关键原因就在于，他们在这种试探中太优柔寡断、太犹豫不决，以至于无论是武功低微、脚踏七条船的韦小宝，还是绝对反派、专干坏事的金轮法王，人气值和好评率都远远超过这两位男主。</p>
<p>也就是说，痛痛快快地勇敢追求心中所爱，成了，你抱得美人归；没成，你也可以昂首挺胸走出这段关系。任何人挑不出你毛病，拒绝你追求的姑娘，也得给你点个赞：“是个坦荡人”。</p>
<p>最糟糕的就是爱情中黏黏糊糊的人，当断不断、循环往复、来来回回、不清不楚，既浪费自己的时间，也浪费他人的时间。</p>
<p>当你一直焦虑对方是否喜欢你时，你在这段感情关系中的行动策略已经不取决于你自身的意志，而是被他人的情绪操控，处于一种被决定的状态，这和上一讲所说的以我为主的原则是冲突的。</p>
<p>所以，破局之道的第一要点就是，你要先改变自己这个状态，千万不要因为对方可能喜欢你，你才去喜欢人家，你最需要做的不是焦虑对方是否喜欢你，而是要确定自己是否喜欢对方。确定了这一点之后，我们才可以进入下一个环节。</p>
<h3 id="你是主动派-or-被动派？"><a href="#你是主动派-or-被动派？" class="headerlink" title="你是主动派 or 被动派？"></a>你是主动派 or 被动派？</h3><hr>
<p>当你确定了自己的心意之后，后续策略无非就是两种：一种是原地等待，创造机会让对方举着爱的号码牌来找你；一种是你主动出击，大胆地去确认对方对你的心意。</p>
<p>所以，现在你的面前，摆着两条路，一条是被动等待，一条是主动出击，你会选择哪种？</p>
<h4 id="如果你选被动等待"><a href="#如果你选被动等待" class="headerlink" title="如果你选被动等待"></a>如果你选被动等待</h4><p>做出这个选择很好理解，这样更安全。只要等对方去推动关系后，你再去跟进，你就可以一直立于不败之地。进可攻退可守，主动权永远在自己手上。但是我还是有一件重要的事情要告诉你，这件事是关于自我：主动出击并不会受制于人。</p>
<p>很多人觉得，在爱情中先行动的人是输家，投入更多的人是输家，这其实没有看到本质。</p>
<p>当初，郭靖为了要跟黄蓉在一起，郭靖又是请客吃饭，又是赠衣赠马，是不是看起来，他是主动示好、率先行动的一方，但在郭黄两人的情感中，掌握主导权的永远是郭靖。</p>
<p>他要闯赵王府，黄蓉就陪他闯，他要守襄阳，黄蓉就陪他蹲在襄阳几十年。</p>
<p>因为你看见和你认为的主动出击，都是主动出击讨好对方，是把决定权交到了对方手里，是渴望对方关注自己。但是，郭靖的主动示好，是他的本性如此，不管黄蓉认不认同，他在那个情况下都会请客吃饭。</p>
<p>所以，你根本不需要去猜测对方心意到底如何，你要拥有一种勇气，一种哪怕到了最后对方不喜欢自己，但你做过的事情仍然是你愿意做、喜欢做的事情的勇气。</p>
<p>“为爱痴狂，并非为你痴狂，所谓少年，不过如此而已！”</p>
<p>你可能不知道，往往这个过程的你是最能展现自我价值的时刻。</p>
<p>赵敏和张无忌在一起，赵敏主动，全书倒追男主，但魅力爆棚；</p>
<p>段誉和王语嫣在一起，段誉主动，全程跪舔女主，但人气超高。</p>
<p>因为他们享受这种主动出击的过程，即便他们喜欢的人对他们态度毫无改变，他们依然享受。</p>
<p>所以，选择被动等待的策略并不意味着始终等待对方先行动，适时主动出击不但不会让你受制于人，而且能够让你更加享受这段关系。</p>
<p>还有我想说，当你选择被动策略时，意味着你的目标对象承担了更多的责任和压力，一点点的主动，也会让 Ta 感受到莫大的安慰。在恋爱中，永远要做个善良的人，这比恋爱更加重要。</p>
<h4 id="如果你选择主动出击"><a href="#如果你选择主动出击" class="headerlink" title="如果你选择主动出击"></a>如果你选择主动出击</h4><p>如果你选的是主动出击，那么我很开心你有这样的勇气，在你“出征”前，我想交代给你一件事情，这件事是关于魅力的吸引力法则：吸引力不仅取决于价值，也取决于可得性。</p>
<p>价值很好理解，就是身高体重、家世学识、颜值收入等等这些客观条件，传说中的高富帅、白富美，都是在形容价值，当然，我们都知道，价值越高的人吸引力越大。</p>
<p>可得性的意思，就是成功牵手的期望值。期望值过高，人家觉得吃定你了；期望值过低，根本没戏，这样即便你价值很高，也没有吸引力。这期望值必须不高不低刚好合适，有个最佳范围。</p>
<p>比如说，对于一个男生来说，如果范冰冰和隔壁颜值很高的同事小姐姐，同时放在他面前，让他选择，他大概率会选后者，因为前者对于他来说，可得性太低。</p>
<p>你看，这个法则也有力解释了一个现象，就是为什么男神女神经常没人追，为什么有些人条件一般却很有异性缘。有时候，单身，可能不是你不够好，而是你太好。</p>
<p>短时期内，人的价值很难发生大幅变动，而决定两个人吸引力大小的关键变量就是可得性。</p>
<p>无论对方价值高低，当你主动出击时，又纠结对方爱不爱你时，一定是对方可得性处于最佳值。而你恰恰相反，对方一旦稍加示好，让你解读出积极信号，你就会喜上眉梢，使你可得性过高，吸引力大大降低。</p>
<p>能猜对人家心思不是高手，适当让人家猜你心思才是高手。</p>
<p>所以，主动不该是每天一成不变的硬刚，而是以一种时强时弱、时快时慢的节奏，让对方无法准确预测你下一步行动，同时知道你的心意，也期待你的行动，更害怕你的失去。</p>
<img data-src="/2022/11/24/love/02/02_1.jpeg" class="">

<p>也许，你发现了，我给被动等待的人的建议是，别太被动；我给主动出击的人的建议是，别太主动。这看似朴实无华的道理，蕴藏了深意，总结就是：既不刻意讨好，也不掩饰喜欢。</p>
<p>主动和被动从来都没有明确的界限，两个人的关系应该像弹簧，Ta 强你就弱，Ta 弱你就强，和谐的起点就是让爱情的小树苗在相互试探、相互追逐中茁壮生长。</p>
<h3 id="爱情是从“我”入手"><a href="#爱情是从“我”入手" class="headerlink" title="爱情是从“我”入手"></a>爱情是从“我”入手</h3><hr>
<p>其实，找对象的本质是个信息交换的过程，“喜欢你”是这个过程中最基础、最先发的信息。最好的关系是，既不用表白也不用猜，互相喜欢这件事，你们就是“两个心里都知道的”。</p>
<p>因为喜欢一个人，不管怎么藏都是藏不住的，再迟钝的汉子，也能第一时间感知到。比如说，《天龙八部》里面，绝对感情迟钝、钢铁直男的萧峰。</p>
<p>阿朱：“我小时候睡不着，我妈便在我床边唱歌儿给我听。只要唱得三支歌，我便睡熟啦。”</p>
<p>萧峰：“这会儿去找你妈妈，可不容易。”</p>
<p>萧峰面对马夫人这样的人间绝色，喝酒后被猛撩，他一样毫无知觉，甚至都忘记了这件事。但是阿朱陪在他边上没几天，萧峰就说“四海列国，千秋万代，就只有一个阿朱！”</p>
<p>真心爱慕和蓄意撩拨，完全不同。真正的喜欢，是一片赤诚的坦然相对，是自然而然的真情流露，是不加修饰的一尘不染，你根本不会有丝毫犹豫就能确定。</p>
<p>而人总是想给自己留一点余地，你明知道对方大概率不是特别喜欢自己，但想作弊看看对方的底牌，然后我再考虑在这个爱情的赌桌上加注，所以要反复猜测对方到底有多喜欢自己。</p>
<p>但是，要记住，找一个人谈恋爱绝不是因为这个人在暗暗喜欢你，而必须是因为你足够喜欢这个人。因为足够喜欢，所以勇敢，这种勇敢不是直勾勾地表白，也不是惨兮兮地跪舔，而是坚持自我、展现自我、享受自我的过程。</p>
<p>所以，即使看牌的机会有很多，但真心喜欢的人错过一个就少一个，偶尔也勇敢点，该 all in 就大胆上。毕竟，有时候，感情不是稳扎稳打的将就，而是一往无前的梭哈。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>打游戏都希望自己有能开全图的作弊器，谈恋爱都希望自己有知人心意的金手指。</p>
<p>这虽是人之常情，但不是明智之举。因为它本质上是一种不自信，不自信会降低你的自身魅力，也会干扰你的决策判断。所以，相比猜测对方心思而言，不如先改变自己的状态。</p>
<p>如果你选择被动等待，那么我想告诉你，主动出击并不会受制于人；如果你选择主动出击，那么你要记住吸引力不仅取决于价值，也取决于可得性，可以主动，但要有节奏的变化。</p>
<p>最后，我想说，爱情的牌怎么打，不单单取决于对方的底牌，更重要的是自己有哪些牌。如果你确定自己足够喜欢足够爱，拿着 4 条 A 就该勇敢甩出啊。</p>
<p>比起开全图的上帝视角，飞龙骑脸他赢得不是更香吗？</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>03 冒犯有时是必要的：如何开启一段亲密关系？</title>
    <url>/2022/11/24/love/03/</url>
    <content><![CDATA[<p>今天，我们来聊一个话题，如何开启一段亲密关系。</p>
<p>从陌生到认识、从认识到熟悉、从熟悉又到暧昧、从暧昧到确定关系，在每一个阶段，我们都想和自己喜欢的人更进一步，想要有更亲密的感情。这是每个人谈恋爱的必经之路。</p>
<p>但是正因如此，这个问题也成为了恋爱过程中争议最大，也是雷区最多的一个问题。</p>
<p>阶段多、变数也多，过程不一样，人和人的情况又各有不同。想找到一种可以一刀切的方法，来一揽子解决这个问题，这几乎是不可能完成的任务。</p>
<p>而问题就在于，偏偏有不少人根据自身经验给出所谓的必胜方法，却犯了瞎子摸象的经验主义错误，让我们离修成正果、恋爱胜利的目标，越来越远。</p>
<p>那有哪些错误示范呢？我们一起来看一看。</p>
<span id="more"></span>

<h3 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h3><hr>
<p>第一就是土味情话流。在抖音快手上，有大量土味情话系列的视频，类似于：</p>
<p>“你知道我的缺点是什么吗？”</p>
<p>“什么呀？”</p>
<p>“缺点你。”</p>
<p>用这样的土味情话跟陌生妹子或者小哥哥聊天，如果人家没听过还好，再或者有点创意、新颖一点也行，要是你直接照搬照抄的话，那绝对是溢出屏幕的尴尬之情。</p>
<p>以前我一直觉得大家都是把这当作段子看的，直到最近一两年，我发现还真有拿这来实战的。至于效果，凡是能看到这个专栏的人所接触到的对象圈层，肯定都不吃这套。</p>
<p>第二就是公式模板流。类似于考试作文模板，列出各种情况的聊天公式，让人自行带入内容。</p>
<p>倾听 + 共情 + 好奇 + 欣赏</p>
<p>悬念开局 + 角色代入 + 植入关系 + 画面感</p>
<p>不得不说，有几个公式给的还有点意思。可是问题主要在于，光有公式，却没有足够的内容去支撑模板。如果仅仅掌握模板就能 hold 住聊天，那么看过高考作文书的人，高考作文都该拿满分。</p>
<p>第三就是 cos 角色流。典型的就是霸道总裁、高冷别扭怪，就是那种压根你就不要表白，直接上肢体接触，什么过马路拉手、下雨打伞搂肩膀、对视三秒直接亲、吃对方嘴上的奶油等等。如果说上面的作文模板最多是把对象吓跑，那么这个方法可能给你直接送进派出所。</p>
<p>类似的错误示例还有很多。一些初入情场的老实孩子，简单照抄照搬，反而弄巧成拙。</p>
<p>你知道为什么这些模板用起来没有效果，还很尴尬吗？因为这些东西是适用于那些已经进入恋爱关系的人的，什么土味情话、cos 霸道总裁，都是老夫老妻拿来增添点生活乐趣的。</p>
<p>小情侣玩这些模板，是胜利凯旋的赞歌，可是你却把这些东西当作冲锋陷阵的号角。尴尬了自己，也尴尬了别人。恋爱目标没达成，还实实在在地留下了不走心、只会套模板的印象。</p>
<p>说白了就是，你对你们之间关系的亲密程度并没有一个准确的判断。</p>
<h3 id="从关系维度入手"><a href="#从关系维度入手" class="headerlink" title="从关系维度入手"></a>从关系维度入手</h3><hr>
<p>大到一个国家，小到一个企业，每一种事物都有不同的发展阶段，每个阶段的主要矛盾都不一致。恋爱也是如此，我们无法按照统一的方法划分阶段，但是我们可以从关系维度入手。</p>
<p>在确定关系之前，我们可以把两个人的关系，简单地分为前期、中期和后期。因为，每一个阶段的主要矛盾都不一样，我们的行为侧重点也就不一样。</p>
<h4 id="前期：务必真诚"><a href="#前期：务必真诚" class="headerlink" title="前期：务必真诚"></a>前期：务必真诚</h4><p>在两个人刚认识的前期，双方都不太了解对方。这个阶段，大家主要考量对方是否靠谱。所以，在这个阶段，真诚就显得尤为重要。但真诚是一种看上去很简单，做起来很难的事情。</p>
<p>在现代社会，人太需要给自己戴上各种面具，塑造各种人设。有面对老板的、面对同事的、面对客户的、面对父母的、面对同学的……你要考虑的东西太多太多。但是，正因为这样，每个人都希望感情是一片净土，希望在感情中可以真诚纯粹。</p>
<p>不光是对方，你也会希望自己找到的是一个真诚没有套路的人。</p>
<p>世纪佳缘曾做过一个问卷调查，调查男女双方谈论婚姻时最重视的品质是什么。最后，真诚这一项，以碾压性优势超过了自信、体贴、睿智、财富。求真是人类的永恒追求之一。</p>
<p>比如说，《笑傲江湖》中，真小人左冷禅远比伪君子岳不群受欢迎，就是求真本质的一种体现。</p>
<p>那怎么才算是真诚呢？有人说，既然我喜欢，就去表白，这是不是够真诚；还有人说，我喜欢的人穿的衣服不好看，我直接告诉她，是不是够真诚？可为什么这样的“真诚”，往往换不来一个好结果呢？</p>
<p>第一，这确实不是真诚。你看见一个姑娘，心生好感，你内心真实的想法会是“我喜欢你”吗？绝对不是，你要是真正的喜欢一个人，真正的内心感觉应该是非常具体细腻的：</p>
<p>“昨天你跟我讲 xxx 的时候，好有道理，我觉得你浑身都在发光。”</p>
<p>“昨天本来很丧，不知道为什么跟你在一起喝杯咖啡就好了。”</p>
<p>你要是喜欢一个姑娘，内心也绝对不会觉得这件衣服不好看，而是这件衣服本来是不配你，居然被你穿出这种效果。</p>
<p>这不是话术，这就是真诚！真善美为什么是人类的永恒追求？“真”这个东西本身就具有强大的力量和无法抗拒的魅力，你觉得真诚让你碰壁是因为你真的不够真！</p>
<p>而且真这东西太宝贵了，哪怕是非常迟钝的人，也能够清晰地感知到真正的真诚。大家要么虚伪的客套，这叫社交距离；要么炽热的真诚，这是真心以待，都能维持好感。</p>
<p>最怕的就是虚伪的真诚，就和岳不群一样，会引发本能的厌恶。</p>
<p>第二，不够真诚怎么办。多数人在多数情况下，确实没有让你到刻骨铭心的程度，那么碰上一个还可以的对象的时候怎么办？尽量真诚或者说不要显得太假，技巧就一句话——目的性不要太强。</p>
<p>就好像你进商场购物，导购对你微笑，夸你衣服合体；就像你进饭店吃饭，服务员向你微笑，给你洗涮碗筷。绝大部分情况，你是不是第一时间就会一眼看破他们的虚伪，然后感到十分反感，因为他们的微笑往往很假，唯一支撑他们微笑的理由就是让你花钞票。</p>
<p>偶尔，你会发现不是特别在意你买不买东西的导购，如果他是发自真心喜欢这只口红，那么你反而更愿意在他这里买口红——我想这就是李佳琦走红大江南北能成为带货一哥的原因。</p>
<p>偶尔，你会发现不是特别在意你点多少菜的服务员，如果他们是发自真心在意这家火锅店，那么你反而更愿意在这家店吃饭——我想这就是海底捞走红大江南北能成为火锅一哥的理由。（请运营小姐姐月底找海底捞结一下广告费……）</p>
<p>把对方当成一个人，而不是一个需要拿下的恋爱目标，仅此而已。</p>
<p>有人问过我，真诚会不会显得很傻。我说，嗯，有时候是会有点傻，但是只要你在爱情中，感情是真挚的，不管有多热烈，不管看上去有多傻，都会赢得人的尊重，否则就会引起人的厌恶。</p>
<h4 id="中期：敢于冒犯"><a href="#中期：敢于冒犯" class="headerlink" title="中期：敢于冒犯"></a>中期：敢于冒犯</h4><p>关系发展到中期，两个人已经对彼此足够熟识，可能处于暧昧期，也可能处于朋友阶段。这一阶段，在靠谱的基础上，双方更看重的是对方带来的情绪和体验。</p>
<p>所以，我给你的建议是，敢于冒犯。冒犯是突破现有人际关系距离，入侵对方的领域，形成新的平衡的过程。比如，《天龙八部》里，乔峰和阿朱相恋，其实就是阿朱不断“冒犯”的过程。</p>
<p>阿朱易容进少林之后，受了玄慈大金刚掌隔空掌力所伤，恰好被乔峰所救。</p>
<p>不过阿朱伤势很重，需要乔峰不停用真气为其续命。两人非亲非故，一面之缘，但是，阿朱还是请乔峰不断损耗真气救助自己，这真可谓是不情之请，算是一种“冒犯”。</p>
<p>乔峰大英雄气概发作，答应了阿朱这个要求，最后独闯聚贤庄请薛神医治病，小半是为了阿朱，倒有大半是一口气咽不下。但阿朱病好以后克服重重困难，找到乔峰，在整个中原武林与之为敌的情况下坚定支持他，为乔峰提供了特别需要的情绪价值，这是阿朱“冒犯”之后的回报。</p>
<p>所以，冒犯——回报的循环，就是两人升级关系的过程，阿朱和乔峰就是在这样的多个轮次中，不断加深关系，最终许下塞上牛羊之约，确定了关系。</p>
<p>在现实生活中，不同的关系层级也有不同的社交距离。比如大街上素不相识的两个人，你问人家要电话号码，当然就是不符合陌生身份的一种“失礼”。比如我俩普通同事，我贸然请你单独来家里吃饭，那也算是没有分寸感的一种“冒犯”。</p>
<p>关于如何正确地“冒犯”，我有三点告诉你：</p>
<p>一来要讲究善意，我问你要电话，是为了能跟你联系，不是转手给人卖掉信息；</p>
<p>二来要讲究分寸，不要越级突破，明明是点头之交，跑人家楼下唱歌摆鲜花求人家做自己女朋友就是过于急躁了；</p>
<p>三来要讲究平衡，今天麻烦你帮我取了快递，明天给你带一份水果。</p>
<p>两个人要建立亲密关系，就不能总是客客气气按照社交礼仪，时刻注重保持双方的合适距离，把界限分得很清楚，必须有人率先打破现有关系水平，提出一些略有“冒犯性”的要求。</p>
<p>当然，敢于冒犯不是粗鲁猥琐，冒犯并不是让你把人按在墙上壁咚，也不是打着心直口快的幌子说黄段子，而是敢于示弱，告诉别人，你需要帮助。示弱是开启亲密关系的精髓所在，强而示之弱，能而示之不能，这既代表了你的态度，也显示了你的能力，更为对方提供了价值需求。</p>
<p>示弱不代表无能，而是勇敢地深入一段关系，没有冒犯，关系也就无从推进。</p>
<p>在感情的世界里，没有“君子动口不动手”，只有“自己动手，丰衣足食”。</p>
<h4 id="后期：及时止损"><a href="#后期：及时止损" class="headerlink" title="后期：及时止损"></a>后期：及时止损</h4><p>你看，建立亲密关系的本质过程，就是两个人互相冒犯，侵入到一方觉得受不了，就散了；又或者侵入到足够近，双方还能接受，那就瓜熟蒂落，水到渠成。</p>
<p>所以，一般到了后期，不是要成了，就是久久都没成。成了固然好，但是如果花费了很长的时间和精力，关系还是没有进一步的突破呢？这也正是我想说的，要及时止损。</p>
<p>谈恋爱如同炒股票，不怕你没有把握住机会，就怕你被套牢。</p>
<p>你甚至可以完全不用了解如何开启亲密关系，因为只要尝试足够多，就可以碰到喜欢你的人，这个开启过程是自然而然、无师自通的，但是你必须学会及时止损！人的一生很长，足够你遇到相伴一生的爱侣；人的一生很短，不要把时间浪费在根本不爱你的人身上。</p>
<p>那么当对方有哪些表现，你就应当立刻抽身离开呢？不算其人本身人品、性格的缺陷，我认为有以下几种情况，你就可以考虑马上止损了。</p>
<p>明确拒绝或暗示你，你俩不可能。（说到这得补一句，人家说现在不想谈恋爱的意思不是现在不谈，是不想跟你谈，要听懂拒绝。）</p>
<p>有意或无意让你知道，她有对象 &#x2F; 喜欢的人，无论这个人是不是真实存在的。</p>
<p>从来不主动，爱答不理，有你也行没你也行，对你不感兴趣，不愿意主动了解你的生活。</p>
<p>只索取不付出的，包括但不限于金钱、情感、时间、精力等等。</p>
<h3 id="对套路-Say-No！"><a href="#对套路-Say-No！" class="headerlink" title="对套路 Say No！"></a>对套路 Say No！</h3><hr>
<p>其实，开启亲密关系，并不需要高深莫测的技巧。对于喜欢你的人来说，你只需要开个头，对方一定会想法设法回应，跟你共同推动关系向下一阶段发展，不要过于迷恋撩人的技巧。</p>
<p>如果太讲技巧，反而会弄巧成拙。比如说，有很多男生的撩妹技巧很深厚，但是在和女孩子接触的时候，痕迹过重，显得油腻，在女生那里反而频频吃瘪，越装越惹人讨厌。</p>
<p>正确的办法不能搞定错误的人，但错误的办法可以搞砸正确人。</p>
<p>开启亲密关系，并没有百试百灵的办法，要勇敢地对套路 Say No！世界上没有任何一种恋爱技巧，可以让你学会了以后，直接搞定刘亦菲或者吴彦祖，务必要抛弃不切实际的幻想。</p>
<p>毕竟，喜欢你的人不用你拼命追，不喜欢你的人拼命也追不到。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>好的开始是成功的一半，成功开启亲密关系是让人特别激动兴奋的一件事。</p>
<p>在这个过程中，教程虽然特别多，但是千万不要照抄照搬，否则就会赔了夫人又折兵。</p>
<p>那么，我们到底该如何开启亲密关系？要从双方的亲密关系维度入手，我们可以简单地把这一进程分为前期、中期和后期，要把握好每一阶段的主要矛盾，有意识地推进关系。</p>
<p>首先是前期，务必要真诚，真诚足以打动适合你的人；然后，到了中期，要敢于冒犯，你要起个头表达好感，敢于打破社交距离冒犯一个人，既是示好的方式，也是提供进一步接触的机会。</p>
<p>但是冒犯要注意，一要善意，二要谨防越级，三要记得找补。冒犯的最高级是示弱。</p>
<p>到了后期，如果关系迟迟没有进步，一定要学会及时止损。因为不喜欢的人拼命也追不到，所以不要在一棵树上吊死，一定要有止损的意识及时抽身。</p>
<p>最后，要记住，不要玩套路。开启亲密关系，是两个人互相了解、互相试探、逐步加码的过程，正确的办法不能搞定错误的人，但错误的办法可以搞砸正确人。</p>
<p>搞清局面，将心比心，才是问题解决的关键。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>04 亲密关系的本质是分享：如何把握暧昧的窗口期？</title>
    <url>/2022/11/24/love/04/</url>
    <content><![CDATA[<p>我曾经做过一个小调查，问很多情侣这样一个问题，“你们在这段感情中印象最深刻，让你最心动的事情是什么？”</p>
<p>事情当然各不相同，但发生的时间惊人一致，百分之七十都发生在暧昧期。</p>
<p>大家普遍反映，在暧昧期的时候，对方的一举一动都会引起自己几分猜想，两个人相处时还带着点拘谨和不自然，会不停地试探，试探中带着点期待，没有哪个阶段会这么让人心跳不已了。</p>
<p>的确，从心理学的角度来讲，有理论说一个情绪周期是 28 天的，还有说新鲜感只能维持三个月的，还有从生物学角度分析激素分泌周期的。但是，无论我们采取哪一种说法，男男女女在一起确实有个微妙的窗口期。</p>
<p>在这个窗口期，双方既建立了初步的信任，又还保留着神秘的面纱，相互之间吸引力、安全感都处于最佳状态。我们管这个窗口期就叫作暧昧期，把握住这个时期，升级关系会事半功倍。</p>
<p>所以，这一讲我们就来聊聊，在这段非常关键的暧昧期，我们应该做些什么。</p>
<span id="more"></span>
<h3 id="怎样判断自己处于暧昧窗口期？"><a href="#怎样判断自己处于暧昧窗口期？" class="headerlink" title="怎样判断自己处于暧昧窗口期？"></a>怎样判断自己处于暧昧窗口期？</h3><hr>
<p>在分析应该做什么之前，我们得先学会判断自己和对方真的进入了暧昧期。不光可以检查自己是不是想多了，还可以及时适当地提醒自己，该改变自己的状态和心态，来迎接这一阶段。</p>
<p>从我接触过的人来看，最短的认识一天就开始暧昧，最长的我见过维持了八个多月的。暧昧这件事，不像炒菜，有个煎炒烹炸的时间指标，而是一种感觉指标，偏感性。</p>
<p>所以，要记住，我们不能用时间的长短来判断是否进入了暧昧窗口期。</p>
<p>其次，暧昧的核心感觉是不确定性，既对对方的心意不确定，也对自己的心意不确定，正是这种不确定加强了这段关系的吸引力。这就好比 100% 获得两千万和 10% 的机会获得 10 亿，虽然后者的收益期望值比前者高五倍，但绝大多数人仍然愿意选前者，这叫风险厌恶。但是同理，当你打牌赢了上万块时获得的愉悦感，远远超过月底搬砖结工资时候获得那约定好的上万块。</p>
<p>所以，如果说恋爱像是发工资，暧昧就像是赌博，同样是收钱，但心态和感觉完全不同。</p>
<p>根据暧昧的这种特点和性质，我总结了以下进入暧昧期和退出暧昧期的几个标志。</p>
<h4 id="进入暧昧期的三个显著标志"><a href="#进入暧昧期的三个显著标志" class="headerlink" title="进入暧昧期的三个显著标志"></a>进入暧昧期的三个显著标志</h4><p>第一是特别感。</p>
<p>特别感是一种神奇的感觉，张无忌遇到周芷若可以感觉很特别，胡一刀遇到苗人凤可以感觉很特别，郭靖遇到男装的黄蓉也可以感到很特别，令狐冲遇到老丈人任我行同样可以感到很特别。</p>
<p>特别感就是一种独有的吸引力，大千世界、芸芸众生，唯有在你身上见到这种别样的特质，这当然是一种好感。同时表达特别感又很安全，朋友之间、对手之间、恋人之间都可以有特别感。</p>
<p>因此，一旦有异性表示，你在任何一个方面有 Ta 从未遇到过的特别之处，哪怕是一个很奇怪的特别，都说明你俩关系可能已经进入暧昧期。</p>
<p>此时此刻的你，至少已经与别人不一样，值得 Ta“另眼相待”。</p>
<p>这个时候，你看诸葛丞相说的那句“我从未见过如此厚颜无耻之人”，是不是有种万人会场公然秀恩爱的 cp 感了？</p>
<p>第二是细节感。</p>
<p>如果说特别感是一种吸引力，那么细节感就是一种注意力。</p>
<p>比如说，你随口说过的一句话，做过的一件事甚至是一桌人聚餐时多吃了两口喜欢吃的菜，这些小小的细节，却被对方不经意间都记在心里，那么你们细节感就很满了。</p>
<p>特别感是因，细节感是果，在这个注意力极其珍贵的移动互联网时代，能够在你身上投入相当程度的细节记忆力，已经充分说明了你的重要性。但同时，表达细节感的时候又带有一点犹豫。</p>
<p>毕竟，一个细心的人、体贴的人对谁都可以满满细节感，也不能实锤就是喜欢吧。所以，如果出现了这种欲说还休的感觉，把细节感的张力拉满，这就是一种暧昧的小表现。</p>
<p>第三是抗拒感。</p>
<p>我们刚才说了，暧昧的本质是不确定性，那么抗拒感就是不确定性的原因。所谓暧昧，一定是两个人互有一定好感的同时，还有一定防备。这种抗拒感可能因为抗拒确立双方关系，也可能是抗拒关系太快发展、抗拒肢体接触、抗拒主动表白、抗拒在朋友前暴露对方存在等等……</p>
<p>金海心有首歌，叫《那么骄傲》，里面有句歌词是，别那么骄傲，我随时可能走掉。而这种随时可能失去对方的抗拒感，却恰恰是暧昧期特有幸福感的重要来源。</p>
<p>如果出现以上三个信号，那么恭喜你，大概率你和对方已经进入暧昧窗口期。</p>
<p>当然聪明如你，看到这里肯定也想到了，这不仅是个判断标志，也是实操手册。如何与异性营造暧昧氛围，按着这三条来，不比买个花、点个蜡烛什么的来劲多了。给你举几个例子：</p>
<p>偶尔表达对方的特别感，“哇，你是我遇见过的姑娘里面，第一个会自己动手装家具的耶。”</p>
<p>在不经意间表露自己的细节感，“哈哈，你上个月有一次听这首歌的时候循环了好几遍，我就猜你喜欢这首歌~”</p>
<p>在安全范围内，制造一点点抗拒感，“今天聊得很开心，明天还要上班，早点休息吧。”</p>
<h4 id="退出暧昧期的三个显著标志"><a href="#退出暧昧期的三个显著标志" class="headerlink" title="退出暧昧期的三个显著标志"></a>退出暧昧期的三个显著标志</h4><p>如果在窗口期，你没有果断把握机会，随着时间流逝、生理心理各种因素共同作用，你们也许就会失去成为恋人关系的可能，向好朋友的方向狂奔。所以能识别退出暧昧期的标志也很重要。</p>
<p>第一，抗拒感逐步消失。</p>
<p>有人觉得，抗拒感逐步消失是不是说明对方在接受我？不是的，因为如果你在暧昧期没有什么有效行动的话，抗拒感逐步消失的更大一种可能就是，你的异性吸引力在逐步消退。</p>
<p>可能以前拒绝你晚上来家里坐坐，是怕控制不住自己和你擦枪走火。现在邀请你进屋，不是同意和你做点什么，反而是笃定你俩啥也干不了。是你在对方眼里的异性攻击力不断消退，显得越来越安全，所以人家不拒绝和你进一步深入接触。</p>
<p>这也就是为什么一旦成了朋友，再想转身份成为恋人就会难度翻倍！</p>
<p>第二，开始公然损你。</p>
<p>你知道暗暗喜欢你的朋友和真正朋友之间最大的区别是什么吗？</p>
<p>真朋友可能会在别人面前损你，抖你的糗事；但喜欢你的人，私下里或许也会挖苦你几句，但在有其他人在场的情况下，Ta 绝对会小心翼翼地避过所有可能让你没面子的事情。所以，当对方开始频频当着其他人的面，毫不顾忌开玩笑嘲讽你的时候，你们的暧昧期就即将到头了。</p>
<p>第三，规律性逐渐增强。</p>
<p>暧昧的核心在于不确定性，而这种心理感觉消失的表现就是一切可预测。</p>
<p>本来两个人是忽冷忽热、忽近忽远的关系，现在两人关系在靠拢的过程中形成了平衡。每天固定会聊天道晚安，每周固定时间约会吃饭，互相了解程度增加，你说 A 大概率猜到对方会说 B。当两个人一切互动开始不可避免地固化之后，暧昧的因素也就即将消失了。</p>
<p>所以，当以上三个情况逐一出现时，暧昧窗口期即将关闭，此时你必须抓紧时间、加快进度了。</p>
<p>不过，和暧昧期即将关闭相比，还有一种情况我们需要注意，就是恶性暧昧关系。</p>
<p>什么是恶性暧昧关系？在异性关系的发展过程中，自然进入的暧昧关系，终点指向确定的恋爱关系，可以称之为良性暧昧关系。然而恶性暧昧关系，指的是不想承担责任，不愿给予承诺而只享受暧昧的红利。如果你遭受这种关系，你必须学会坚决斩断。</p>
<p>良性暧昧关系和恶性暧昧关系的区别主要有三点：</p>
<p>一是良性暧昧的感觉是双方，恶性暧昧的感觉是单向的；</p>
<p>二是良性暧昧关系可互动可升级，恶性暧昧关系始终无法升级；</p>
<p>三是良性暧昧关系的发起方抗拒感较弱，恶性暧昧关系的发起方反而抗拒感较强。</p>
<p>最后，恶性暧昧关系的时间一般长于良性暧昧。</p>
<h3 id="窗口期最重要的任务"><a href="#窗口期最重要的任务" class="headerlink" title="窗口期最重要的任务"></a>窗口期最重要的任务</h3><hr>
<p>我们现在已经学会如何分辨暧昧窗口期的进入和退出“标志”了，那么，我们在这段重要和关键的时期，到底应该做什么呢？仅仅是说几句话术，多约出来见几次面吗？</p>
<p>并不是。暧昧窗口期最重要的任务，就是借助这段时间特有的吸引力，迅速升级双方关系。那么问题来了，亲密关系或者说恋爱关系的本质是什么？什么叫升级关系？</p>
<p>血缘关系很简单，看 DNA；雇佣关系也很简单，看合同。那亲密关系看什么？有人觉得相互确认关系就是情侣，也有人觉得对外宣布关系了才算情侣，还有人觉得要上了几垒才算情侣。</p>
<p>但是，现代社会越来越开放，就算上了本垒也未必就能成为情侣。在我看来，所谓关系，更多是精神上的定义，也是更稳定可靠的定义。恋爱关系的核心在于信息交互！</p>
<p>信息交互的层级决定了两个人关系的远近，交互层级越浅，可交互人数就越多，关系就越疏离；交互层级越深，可交互人数也就越少，关系也就越亲密。</p>
<p>比如说，如果有一个异性和你成为少数一两个可以相互交换某些深层次信息的时候，注意！是相互交换。无论你们有没有表白，你们已经实质上进入一段亲密关系中了。</p>
<img data-src="/2022/11/24/love/04/04_1.jpeg" class="">

<p>我粗略地将信息交互的层级分为六层：</p>
<ol>
<li>兴趣爱好</li>
</ol>
<p>这是非常开放的信息，也是作为朋友的起步层级。</p>
<p>如果两个人之间愿意交流兴趣爱好，在一起打牌、玩游戏、看话剧等等，并就这些爱好展开聊天互动，就可以成为朋友。这个层级人数最多，也是你和异性之间互动的起点。</p>
<ol start="2">
<li>价值观</li>
</ol>
<p>这个信息相对私密，起码要进入密友的程度，才会围绕这个主题展开信息交换。</p>
<p>你很难想象两个相识不久，只是在一起作为牌搭子的人会在一起谈人生、谈理想、谈未来，那是很尬的。能谈这些的，一定得是非常好的朋友。当你和某个异性进入这个话题，说明你们之间关系已经开始不一般，有一些感觉了。</p>
<ol start="3">
<li>社交关系</li>
</ol>
<p>每个人都有自己的核心社交圈，当你向某个人开放自己核心社交圈的时候，这个人显然已经是你极其亲近的人。当你和异性能够频频地、又自然地出现在对方核心社交圈内，无论互相怎么介绍，在旁人看来，你们之间肯定有点什么了。</p>
<ol start="4">
<li>情绪</li>
</ol>
<p>成年人的世界没有容易二字，崩溃都需要找个合适的时间。分享情绪信息给他人是一件非常危险的事情，一般也只有家人会无条件接受你的情绪输出。所以说，当你能够和一名异性在任意时间分享情绪信息的时候，你们可以说已经实质上建立了情侣关系。</p>
<ol start="5">
<li>性</li>
</ol>
<p>滚床单不等同于性层面的交互，其实握个手、抱一抱都算作这方面信息的交互，当然了，滚床单也可能完全不涉及这个层级的互动。语言、肢体甚至眼神都可以是这个层级交互的媒介，而这也是可能恋爱甚至结婚多年都达不到的交互层级。</p>
<ol start="6">
<li>隐秘</li>
</ol>
<p>人心里都有一个隐秘的角落，藏着自己不为人知的秘密、不堪回首的事情，这是一个人最软弱的要害。当你可以放心和一个人互相分享这个隐秘的角落时，你们已经成为密不可分的整体了。</p>
<p>窗口期最重要的任务，就是根据这个信息交互层级，一层一层地深入下去。主动方首先表露自身某个层级的部分信息，然后引导对方表露。当双方都可以稳定开展某个层级的信息交互后，就可以开启下一个环节了，亲密关系就会越来越近。</p>
<p>这个进度表最大的好处在于，不会给你们之间带来很多压力。云淡风轻一层层聊下去，每一层都很自然，也不像送人礼物，约会吃饭之类的需要承担被追求的压力。</p>
<p>比如说，当你们都开始顺利交换情绪信息，人家什么开心的事先告诉你，难过的事情也告诉你后，在你这里寻求你给 Ta 的情绪支持，那你还要表什么白呢？</p>
<p>但是，注意，千万不要越级自爆。刚刚认识一个同样喜欢打游戏的异性，一起玩了几把游戏，你就直接越级去聊性话题，就自爆内心最深处的秘密，那叫交浅言深，毫无效果且危害极大。</p>
<h3 id="粉红色的回忆"><a href="#粉红色的回忆" class="headerlink" title="粉红色的回忆"></a>粉红色的回忆</h3><hr>
<p>曾经有个颜值不错，性格更加不错的姑娘问我，为啥感觉对她有意思的男生不少，但最后都处成了兄弟？我只能告诉她，搞对象如同烹小鲜，火候没到贸然越界会吓跑对方；火候过了又失去新鲜感只能做好朋友，必须把握这个既熟悉又陌生的机遇期。</p>
<p>《倚天屠龙记》里面我最喜欢的赵敏，她就非常善于把握时机，绿柳庄初见张无忌时，虽然敌友难辨，她也疯狂秀了自身的价值，之后又狠狠坑了张无忌的明教一把。张无忌为了逼问离开陷阱的方法，把赵敏的鞋袜都脱了搞人家的 jio，这时候气氛已经有那味了。</p>
<p>不过两个人初次相见，相互之间防备心还很重，赵敏就啥也没说。直到武当山交锋，互有胜负后赠珠花示好，升级暧昧气氛，元大都再遇后才开始表露心迹，节奏这块拿捏的死死的。</p>
<p>回到今天一开始我说的那个调查，难道确定关系后的热恋期不香吗？为什么这么多人对暧昧期的印象如此之深？因为，暧昧期的确有它的魅力所在，你看电视剧里那些处于暧昧期的小男生小女生，看个电影吃爆米花，只是手不小心地碰到了，两个人就脸红心跳个不行。</p>
<p>在暧昧期，你爱的那个人仿佛身上有光，你看 Ta 的时候眼里都自带滤镜；你们不需要多大的磨合，Ta 说什么你都爱听，更没有柴米油盐的烦恼，让你们疲于生计，忘了爱情。</p>
<p>“虽然我不确定会不会真的喜欢你一辈子，但是，当下爱你的程度，让我想说出这句话。”</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>暧昧是恋爱的窗口期，是双方安全感和神秘感处于最佳状态的机遇期。</p>
<p>尚未进入暧昧窗口期，两个人恋爱火候还没到，推进关系可能会把人吓跑；已经退出暧昧窗口期，两人恋爱火候已老，推进关系变成朋友兄弟。所以要精确判断窗口期的进出标志：</p>
<p>进入标志：1. 特殊感；2 细节感；3 抗拒感。</p>
<p>退出标志：1. 抗拒感逐步消失；2. 开始公然损你；3. 规律性逐渐增强。</p>
<p>还要强调一句，面对恶性的暧昧关系，一定要学会立即斩断。</p>
<p>恋爱关系的核心在于信息交互！窗口期就是要推进信息交互层级的深入。</p>
<p>六个交互层级层级越浅，关系越疏离；层级越深，关系越紧密。两个人交往中表白不重要，能够交互什么信息很重要，真正的高手都是在不知不觉之中拉近双方关系的。</p>
<p>我知道，你也知道，我们有一天可能会分开，但都不知道是哪一天。</p>
<p>或许是明天，或许是永远——暧昧让人最难受的是不确定性，让人最惊喜的也是不确定性。愿你珍惜这段暧昧时光，也愿你能找到那个让你在不确定中相信确定的那个人。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>05 创造型与消费型活动：两个人在一起没事干怎么办？</title>
    <url>/2022/11/24/love/05/</url>
    <content><![CDATA[<p>今天是我们这堂恋爱课的第五讲了，前四讲我们一直在探讨双方在没有确定关系之前，有哪些注意事项和原则。从这一讲开始，我们就要进入恋爱后的世界了。</p>
<p>不过，这谈恋爱后，和谈恋爱前相比，问题是只多不少。其中，最常见的一个问题，也是起码三成以上情侣最终分手的原因，就是两个人在一起没事干，觉得谈恋爱越来越无聊。</p>
<p>热恋期不会有这种问题，两个人身处热恋期，在一起干啥都得劲，就是躺在一起发呆都很甜；恋爱一年以上，这个问题也不是很要紧，因为两个人有很大的可能也找到了相处模式。</p>
<p>最要命的就是热恋期刚过这段时间，两个人尚未磨合完毕，最初的新鲜感、激情又消耗殆尽。这时候，情侣之间会出现一段不知所措的空白期。每次约会不是吃饭，就是看电影，特别单调；聊天也没有共同话题，虽然也开始绞尽脑汁想一些新鲜的点子，却反而弄巧成拙、频频踩雷。</p>
<p>两个人内心自然都不约而同产生一个疑惑，是不是我俩其实没那么合适，在一起只是一时冲动？</p>
<p>最终，两个人也找不到答案，恋情慢慢地走向破裂，就这样无疾而终。很多人就此错过一段姻缘，付出了大量的时间、精力和情绪，美好的恋情却遗憾地收尾了。</p>
<p>所以，这一讲我们就来分析下这个问题。即使你还没有确定关系，我也建议你跟着我一起来探讨这个话题，毕竟，“两个人在一起没事干”这个问题会发生在各个阶段。</p>
<span id="more"></span>

<h3 id="消耗价值，边际递减"><a href="#消耗价值，边际递减" class="headerlink" title="消耗价值，边际递减"></a>消耗价值，边际递减</h3><hr>
<p>首先，我们来对这个问题作一个简单的分析。</p>
<p>两个人在一起没事干，换句话说就是，两个人不知道如何组织两个人在一起的时间。而这种组织时间的能力，不仅是热恋期刚过，其实包括追求阶段在内的整个恋爱过程都特别需要构建。</p>
<p>那么，既然要解题，就要先了解一下题的背景。要是想学会如何组织两个人在一起的时间，起码我们得知道两个人在一起的时间，能做点什么，有哪些活动。</p>
<p>其实，大部分情侣在一起的活动，一般来说可以分为以下三类：</p>
<p>消耗经济价值的活动；</p>
<p>消耗时间价值的活动；</p>
<p>消耗情绪价值的活动。</p>
<h4 id="消耗经济价值的活动"><a href="#消耗经济价值的活动" class="headerlink" title="消耗经济价值的活动"></a>消耗经济价值的活动</h4><p>消耗经济价值的活动就是以消耗钞票为主的活动，比如去餐厅吃饭、看演出、买礼物……在《了不起的盖茨比》中，盖茨比和黛西相处的模式就是这种。</p>
<p>这种活动的好处是，不需要特别多的准备，门槛也低。反正餐厅有贵有贱、礼物有好有坏，总有一款适合你。当然，这里面也有门道，讲究个性价比，在行的一百块钱能花出一千块的效果；不在行的，一千块钱可能只是花了个寂寞。</p>
<p>这应该算入门级活动，所以，如果仅仅停留在这个层次，对推进两人关系其实帮助不大。</p>
<h4 id="消耗时间价值的活动"><a href="#消耗时间价值的活动" class="headerlink" title="消耗时间价值的活动"></a>消耗时间价值的活动</h4><p>消耗时间价值就是不花钱或少花钱，主要是消耗时间，例如看电影、打游戏、聊天、逛街……</p>
<p>这种活动需要一定的前期积累，有一定的技能门槛。比如，逛街你得认识各种牌子吧，人试个衣服化妆品，你能品个优劣；就算打游戏带妹上分，你也得先练几局，别自己菜的抠脚。</p>
<p>两个人在一起，起码要有这种程度的活动，才能算是真正谈恋爱。能够腻在一起浪费时间，起码要有相近的爱好，有共同的话题，互相之间也有足够的兴趣。</p>
<h4 id="消耗情绪价值的活动"><a href="#消耗情绪价值的活动" class="headerlink" title="消耗情绪价值的活动"></a>消耗情绪价值的活动</h4><p>什么是消耗情绪价值的活动呢？就是无论你花费了多少时间还是金钱，但是一定刺激了你们两个人分泌多巴胺的活动。比如说，密室逃生、坐过山车、极限运动、赌博……有部法国电影叫《两小无猜》，男女主人公见面就玩各种刺激的活动，就属于这种相处模式。</p>
<p>网上有很多人推荐这种活动，说是当一个人处于紧张环境中，就会分泌多巴胺，这个人就会把这种记忆跟你绑定在一起。据我观察，这话可能只说对了前一半，刺激性活动确实能够让人记忆深刻，但跟你绑定的未必是什么美好的多巴胺，很可能是惊恐和惊吓。</p>
<p>这三种活动，可以统称为消费型活动。</p>
<p>它们有一个共同的特点，就是存在明显的边际递减效应。再贵、再精美、再喜欢的礼物，你送第二次，也很难博得对方开心了；再好看的电影、再炫酷的演出，你陪人家看第二次，也很难找到当初的感觉了；再吓人的密室、再惊险的活动，玩得久了总会感到腻味。</p>
<p>这也就是你们度过热恋期后，两个人会感到在一起没事干的根本原因。</p>
<p>你们的大部分活动都只是消费型活动，而消费型活动天生受到边际递减效应约束。你们要是想通过这种消费型活动，突破这个约束。你们只能选择不断加量，不断重复，就如同吸毒一样，但你们的钞票、时间和情绪总是有限的，最终还是摆脱不了这种空虚。</p>
<p>如何解决这个问题呢？如果想让星光照进自己生活，最聪明的办法是关上屋里的灯。</p>
<h3 id="创造价值，方为上策"><a href="#创造价值，方为上策" class="headerlink" title="创造价值，方为上策"></a>创造价值，方为上策</h3><hr>
<p>下面我要隆重推荐第四种相处模式：创造价值的活动。</p>
<p>创造价值的活动，不是简单购买或使用已有事物，而是两个人一起“无中生有”地创造新事物。</p>
<p>比如一起做饭、健身、做手工、考证、创业等等。虽然，创造价值的活动也会消耗你们的时间、金钱和情绪，但这种活动一定有所产出，而且是好处多多。</p>
<p>好处一：有利于营造专属记忆。</p>
<p>在工业时代，绝大多数消费型活动都是流水线产品（当然您要是有钱，样样都是私人订制，可以自行跳过这一点），然而创造型活动却是在生产只属于你们两人的，独一无二的体验和记忆。当你们生命中有了足够多这样的记忆，就永远不用担心没有共同话题。</p>
<p>好处二：有利于推进双方关系。</p>
<p>共同完成一件事的奋斗过程是最容易培养感情的过程。因为历经风雨后的关系愈加的珍贵，所以那些一起扛过枪、一起同过窗的人往往有特别深厚的情感羁绊。</p>
<p>郭靖黄蓉相识是源于小饭店里推衣赠马，但感情升温还得是共同夜闯赵王府寻药救王初一；</p>
<p>杨过小龙女相识是源于孙婆婆的好心，但感情升温还得是共同脱光衣服，修炼玉女心经；</p>
<p>张无忌和赵敏相识是源于绿柳庄里张无忌耍流氓，但感情升温还得是共同寻找金毛狮王对抗明教总坛等一应强敌。</p>
<p>好处三：有利于克服边界效应。</p>
<p>创造型活动不但不会随着次数增加产生厌倦，反而容易上瘾。战胜困难取得成功的快感，是最为强烈又令人着迷的。而且消费型活动会受到资源约束，创造型活动却可以永无止境地发展。</p>
<p>那么，我们该如何去设计两个人共同的创造性活动呢？</p>
<p>其实也非常简单，只要你们把以前爱干的消费型活动往前推一步，也许就是创造型活动。</p>
<p>比如把刷抖音变成拍抖音，你可以和对象共同研究拍摄技巧和套路，然后成为 Ta 的专属摄影师或者模特，一起设计你们的创意视频，每周都拍根本不会腻（除非你们懒）。比如看电影变成拍电影，额，这个太难了划掉，变成写影评，两个人共同写影评记录观影感受。</p>
<p>当你们习惯这些创造型活动带来的快乐，就可以考虑共同升学考证、共同创业这些高端操作了。</p>
<h3 id="成长，永不过时"><a href="#成长，永不过时" class="headerlink" title="成长，永不过时"></a>成长，永不过时</h3><hr>
<p>原来和对象每次吃人均一百块的餐厅，改吃个人均一千块的，一定会有很好的体验；习惯了每次带对方吃牛排，突然整顿火锅，也一定会有很好的体验。但是，当你自己买菜回家给 Ta 做，不管你烧出什么奇形怪状的东西，一定会别有一番体验。</p>
<p>加量很好，换门类也不错，但是都是治标不治本，只有设计和创造才是绿色健康可持续。</p>
<p>这就是为什么创造性活动能起到这么大的作用。因为从根本上来说，培养了更好的你。</p>
<p>买一个名牌不会让你更高贵，刷一天抖音只会徒增你胳膊的疲惫，一次又一次的娱乐活动只能满足你即时的快乐，但每一次创造型活动的背后都是技能的提升、经验的积累和信心的沉淀。</p>
<p>当恋爱开始和工作、和自我成长接轨，你们就会被对方规划到未来的日子里。</p>
<p>所以，最好的感情经历，莫过于两个人相互陪伴，共同成长。</p>
<p>送礼物、打游戏、去网红地打卡、看最近大火的电影这些活动，依旧可以增温你们的感情，但是只有共同克服困难、携手陪伴进步，才会成为你们想一直走下去的理由。</p>
<p>要记住，在感情里，经营一段感情永远都比寻找一段感情更为重要。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>经营爱情是人生的必修课，而且是性价比巨高的必修课。</p>
<p>其中最为关键的就是经营两个人在一起的时间。但是，很多人却忽视了经营的重要性，让时间久、感情变腻等理由背了锅。两个人在一起没事干，其实就是没有组织时间的能力。</p>
<p>所以，从问题出发，我们分析了情侣常见的三种活动模式，分别是消耗经济价值的活动、消耗时间价值的活动和消耗情绪价值的活动。但无论是哪种，都会受边际递减效应的影响。</p>
<p>唯有创造型活动能够克服边际效应的影响，营造专属记忆和推进双方关系。想要设计创造性活动，也很简单，把以前爱干的消费型活动往前推一步，也许就是创造型活动。</p>
<p>最后，我们要学会赋予爱情更多能量和意义，让爱情推动人成长，因为成长才是永恒的课题。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>06 小心看上去平平无奇的陷阱：如何防范高级渣？</title>
    <url>/2022/11/24/love/06/</url>
    <content><![CDATA[<p>古往今来，在恋爱这个话题分组下，总有很多让人印象深刻的痴男怨女，但其中，也不乏一些渣男渣女。可以说，在深深地爱着的很多，正在渣人或者变渣路上的也不少。</p>
<p>近几年，相关的话题更是热度不减。网上充斥着大量的“鉴渣”攻略，这些攻略详细地列出了 123，教你如何分辨男男女女怎么脚踏 n 条船，有哪些是他们万花丛中过、片叶不沾身的迹象。</p>
<p>但其实，以我做情感咨询的经历来看，就算不用特别教，那些真正的海王、捞女，正常人都能一眼分辨且高度提防。老实人只是老实，又不傻，对被吊着当备胎、当钱包、当饭票这些事情其实是很敏感的，教他们防范这种渣，有点画蛇添足、多此一举的感觉。</p>
<p>所以，为了区别市面上那些林林总总的鉴别海王、踢翻鱼塘的“低级攻略”，我们这一讲就突出了“高级”二字。一般，我不爱用“高级”这样的字眼做题目，因为一看就显得很低级。</p>
<p>但是，因为今天我们要讲的高级防渣，防的其实是大众渣。</p>
<span id="more"></span>

<h3 id="高级防渣，防的是什么？"><a href="#高级防渣，防的是什么？" class="headerlink" title="高级防渣，防的是什么？"></a>高级防渣，防的是什么？</h3><hr>
<p>越是大众，越是“杀人于无形”。真正致命的渣，看起来往往朴实无华。</p>
<p>比如说，之前有个新闻，WePhone 的开发者苏享茂被前妻翟欣欣逼得自杀身亡。网友纷纷猜测与好奇，这翟欣欣到底长什么样子，可以逼得自己老公自杀，难道是天仙下凡？</p>
<p>后来，照片流出来后，要说这翟欣欣吧，还真不算什么倾国倾城的美女，照片里她的打扮也都比较正常，根本不像一个玩咖。但越是这样看上去人畜无害的翟欣欣，渣起来却要了命。</p>
<p>如果你爱看娱乐八卦，那你一定听过王宝强的前妻马蓉；如果你爱看学术圈八卦，那你也一定听说过“学术圈四大妖姬”的赫赫威名。保守地说，这几位的颜值最多也就是中人之姿，却能搅动风云，将人玩弄于股掌之上。所以，千万不要以为看上去平平无奇的大众脸，就不会渣。</p>
<p>那么在恋爱中，什么样的算是“大众渣”呢？请记住，遇到以下这三种人，务必果断止损。</p>
<h4 id="第一种：自我感动渣"><a href="#第一种：自我感动渣" class="headerlink" title="第一种：自我感动渣"></a>第一种：自我感动渣</h4><p>第一种叫作自我感动渣。如果纯粹是自我感动，那倒好说，也没什么危害，谁还不能自嗨一下呢。但在我这些年见过的许多自我感动型选手中，没有一个是止步于自嗨的。</p>
<p>好一点的，比如说小龙女的师傅，林朝英。</p>
<p>林朝英这个人特别喜欢王重阳，然后天天不是找王重阳大战三百回合（是真的比武那种大战），就是用计谋打赌赢王重阳一个古墓，她还专门自创了一门武功专克王重阳的全真剑法。</p>
<p>拜托，人家王重阳好歹也是五绝之首，天天被你打败不要面子吗？还怎么跟你在一起？</p>
<p>可是，林朝英觉得自己心里特别委屈，因为她花了好多心思在王重阳身上。但说白了，她根本不知道王重阳要什么，死后王重阳去祭奠她，心里还很不舒服，写下了“重阳一生，不弱于人”。</p>
<p>这种自我感动不过是只认自己的经验来付出，根本不考虑别人感受。有一个这样的伴侣，你要么就是天天被她折磨，还得鼓掌表扬；要么就是天天拒绝折磨，两人吵架。</p>
<p>还有更厉害的，比如小龙女的师姐，李莫愁。</p>
<p>李莫愁特别喜欢一个叫陆展元的。她跟陆展元处了一段时间后，因为追求爱情违反门规，干脆退出师门。但是陆展元又移情别人，和别人结了婚。本来陆展元和李莫愁自由恋爱，一清二白，分手也是正常，但李莫愁认为自己都为了你叛出师门，你居然不爱我，跑去杀人满门。</p>
<p>这种自我感动更像一种要挟，通过对方并不需要的牺牲，占领道德高地，强迫对方接受自己。</p>
<p>这种自我感动最极端的形式，就是自我伤害。曾经有个男生就来问我，他前女友找他求复合，他只是稍微犹豫了一下，他的前女友就从行驶的出租车里面跳出去了。男生说，这是不是证明，这姑娘太爱他了？现在，两个人分手以后都还没找，是不是该考虑一下复合的事情。</p>
<p>我回答他，兄弟，快跑，想啥呢，有多远躲多远，千万不要复合。</p>
<p>如果一个人今天能打着爱你的旗号跳车，明天她就可能会因为不满意你的爱，推你下车；一个人今天要是能打着爱你的旗号拿刀划自己，明天她就可能因为不满你的爱，拿刀捅你。</p>
<p>有的渣要钱，这种渣要命，不分男女。所以我放在第一位说，你千万要注意甄别。</p>
<h4 id="第二种：偏执控制渣"><a href="#第二种：偏执控制渣" class="headerlink" title="第二种：偏执控制渣"></a>第二种：偏执控制渣</h4><p>第二种叫作偏执控制渣。谁都希望把一切掌控在自己手上，对于恋爱对象有控制欲也实属正常。两个人在一起本来就是互相影响、互相妥协的，但是我们特别要提防偏执控制狂。</p>
<p>经典老剧《不要和陌生人说话》里的安嘉和就是典型的偏执控制狂。冯远征老师用其过人的演技塑造了一个频繁使用暴力以维护自己对妻子绝对控制权的角色，被称为中国第一家暴代言人。</p>
<p>这种人的偏执和控制，归根结底就是一句话：我不要你觉得，我要我觉得。</p>
<p>不过，用暴力控制对象的这种行为，还是很好分辨的。一旦恋爱对象对你动了手，不管什么理由，立刻分手。动手这件事，只有零次和无数次，不存在其他情况。</p>
<p>但是，有一种暴力之外的偏执控制，它更多地表现在软控制，也就是所谓的 PUA。</p>
<p>大部分控制狂并不是面目狰狞的，像冯远征老师所演的，而是在你表现出他希望的样子时，彬彬有礼，极致温柔；但一旦你违背了他的意愿，他就会向你疯狂输出负面情绪，包括但不限于：</p>
<p>贬低你，否定你；</p>
<p>让你感到内疚、惭愧；</p>
<p>数落你的缺点和错误；</p>
<p>将自身不安的根源强加于你。</p>
<p>很多人觉得 PUA 很厉害，其实并没有那么高深。背后的原理，无非就是巴浦洛夫训狗那一套，将自己的正负面情绪输出作为奖励 &#x2F; 惩罚，训练对象服从自己，形成条件反射。</p>
<p>你可能觉得自己意志坚定，不会轻易被洗脑。那么，你可以去看看北大包丽的新闻，她就是被男朋友 PUA，最后自杀身亡的。接受过高等教育的人尚且如此，我们也不能太理想化自己的意志。</p>
<p>所以，一旦你发现，你的恋爱对象企图通过这种方法控制你的生活，你就要考虑分手远离了。</p>
<h4 id="第三种：全面依赖渣"><a href="#第三种：全面依赖渣" class="headerlink" title="第三种：全面依赖渣"></a>第三种：全面依赖渣</h4><p>这第三种平平无奇的渣叫作全面依赖渣。恋人作为最亲密的人，互相支持、互相慰藉是很正常的。但是，恋人之间不应该有过多的依赖感，尤其是全面依赖感，这很容易改变感情的性质。</p>
<p>前两年的热播剧《我的前半生》中，马伊琍饰演的罗子君就是因为对雷佳音饰演的陈俊生过于依赖，事事依靠陈俊生，把自己给养废了。讽刺的是，剧情后续试图拍出罗子君离婚后自立自强的形象，但其实还是事事依靠老干部靳东饰演的贺函，只能说罗子君在依赖这方面有天赋。</p>
<p>有人说，能够什么事都依赖伴侣，那也是凭本事赖上的，有什么不行的？</p>
<p>其实，全面依赖和偏执控制是一体两面。如果你能全面依赖一个人，慢慢地，你就会想偏执控制 Ta；你能偏执控制一个人，最终必然会导致你全面依赖那个人。</p>
<p>前面说的翟欣欣、马蓉就是在经济上依赖，学术圈四大妖姬是在学术上依赖。我都不用直接接触，我都能猜到，这几个人对伴侣必然有偏执控制和情感操控的心思。</p>
<p>这种恶性循环发展到一定阶段，可能就会直接上手了，也就是家暴。</p>
<h3 id="如何防范高级渣？"><a href="#如何防范高级渣？" class="headerlink" title="如何防范高级渣？"></a>如何防范高级渣？</h3><hr>
<p>识渣讲完了，但是识渣容易防渣难。</p>
<p>很多找我做情感咨询的人，就表示过，明明在一段感情中很难受，也意识到对方很渣，可就是沉沦于其中无法自拔。即使知道只有零次和无数次，还是会一次又一次地原谅对方。</p>
<p>离开，这个办法的确说起来很简单。可是，能下定决心、快刀斩乱麻的人太少了。</p>
<p>但你知道吗？人的体验和感受都是有阈值的，渣也算其中一种。当一个人渣别人的时候，Ta 会获得某种心情的愉悦、刺激感的满足等。随着时间推移，次数增加，阈值上限会越来越高。</p>
<p>今天，可能 Ta 只是低等级的渣，明天就是高等级的渣，这种属性一旦形成，会自动强化。</p>
<p>你改变不了，只有离开才是最好的选择。如果觉得困难，你可以提醒自己以下三点：</p>
<p>坚持自我，不要迷失；</p>
<p>天涯何处无芳草，世上没有唯一；</p>
<p>拯救别人是上帝干的事，你要做的是拯救自己。</p>
<p>也许每一段感情都会有办法维持，但不是每一段感情都值得继续维持。不要等对方渣的阈值上限提高才选择离开，也不要让自己遭受痛苦和悲伤的忍耐上限提高，痛苦也是会让人沉沦的。</p>
<p>所以，一定要有勇气断绝和离开“渣”的怀抱，你才有走出黑暗、拥抱阳光的机会。</p>
<p>接下来，我还要说一点，破山中渣易，破心中渣难。防渣除了要防别人渣，更要防自己内心的渣，这才是高级防渣的真正含义。请你记住，当你凝视深渊的时候，深渊也在凝视你。</p>
<h3 id="底线思维，了解一下"><a href="#底线思维，了解一下" class="headerlink" title="底线思维，了解一下"></a>底线思维，了解一下</h3><hr>
<p>人生在世，有几种意识可以培养，好处多多，其中最重要的一种就是底线思维。</p>
<p>理财利息说的贼高，本金被卷了；职场 996 前景说的大好，人猝死了……我们普通人本钱有限，很多事情赚得再多，赔一次就会让全部努力付之东流，甚至再无翻身的机会。</p>
<p>所以，你一定要给自己立个底线，这个底线就是为了防止你这种情况的发生。</p>
<p>在恋爱过程中也是这样，对绝大多数人来说，投入到感情中的金钱、精力、时间和机会成本都是非常宝贵而有限的。如果你在最好的年华被渣男 &#x2F; 渣女耽搁两三年，你的择偶质量可能就要凭空下降一档。更何况，那些对爱情的信心和憧憬，被狠狠撕碎一次后，就再也找不回来了。</p>
<p>所以培养恋爱中的底线思维，加强识渣防渣能力非常重要。</p>
<p>追不到男神女神最多失落一阵子，追到了渣男渣女很可能要失望一辈子。选择离开，未尝不是一种更好的选择。毕竟，对于普通人来说，及时止损永远比盈利更重要。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>防范海王、捞女、绿茶其实很容易，这种人我们一看自己段位不够是不会跟进的。</p>
<p>难得在于防范大众渣。因为，真正坑死人的，都是那些看上去平平无奇、人畜无害的。</p>
<p>自我感动、偏执控制和全面依赖，遇到这三种渣男 &#x2F; 渣女务必要远离，没有第二条路。</p>
<p>还有，要记住，己所不欲勿施于人，不仅要防范别人的渣，还有自己的渣。</p>
<p>给自己留下底线，底线思维很重要，识渣防渣就是恋爱过程中最重要的底线思维之一。</p>
<p>山中渣易破，心中渣难除。</p>
<p>愿你不受世间疾苦，也愿你温柔以待世人，这才是真正的“高级”防渣。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>07 无法回避的现实问题：“亲对象”也要明算账？</title>
    <url>/2022/11/25/love/07/</url>
    <content><![CDATA[<p>俗话说得好，谈钱伤感情，谈感情伤钱。身处情感关系中的双方，总是对“钱的问题”唯恐避之不及，担心会尴尬、会影响到感情，但是却会偷偷以钱为标尺，衡量自己在对方心中的位置。</p>
<p>特别是在进入谈婚论嫁或者长期同居状态后，柴米油盐酱醋茶等等一系列现实的经济问题，开始超越琴棋书画诗酒花的精神问题，成为影响两个人关系继续深入的主要矛盾。</p>
<p>而且，在这个现实问题上，男孩女孩没有任何一方是“无辜”的，是可以回避掉的。</p>
<p>因为，男孩会很苦恼。就算是两个人的大额开销采取了 AA 制，但是他作为男生，还是应该尽量去负担那些小额的开支。不光如此，作为男朋友，他认为自己应该在各种节日购买礼物，还要时常接济由于买买买月光的女朋友。这让他感到有些不堪重负，又不知道从何说起。</p>
<p>女孩，也很纠结。虽然两个人采取了 AA 制，甚至自己的男朋友经常会多付一些，送给自己的礼物价格也远远高于她为对方准备的。但是，毕竟自己的收入远远低于男朋友，她觉得对方还是不够爱自己，常常发生争吵。吵完后，又觉得自己好像错了，女生不是应该经济独立吗？</p>
<p>所以你看，即便是 AA 制，也可能让两个人同时感到不快，并进一步影响双方的感情。花钱这件事就是这样，在两个人的恋爱过程中，越前期越无所谓，越后期越影响大。</p>
<p>今天，我们就来聊一聊，在一段感情中，钱到底该怎么花？</p>
<span id="more"></span>

<h3 id="情侣消费的常见模式"><a href="#情侣消费的常见模式" class="headerlink" title="情侣消费的常见模式"></a>情侣消费的常见模式</h3><hr>
<p>一对情侣在一起，主要开销大体包括约会活动费用、礼物费用和旅行费用；同居或者结婚后还有双方的共同生活费用，以及男女双方的个人开销这几块。</p>
<p>首先，我们来看一看，当下情侣之间相处，有哪些常见的消费模式。</p>
<h4 id="男生买单模式"><a href="#男生买单模式" class="headerlink" title="男生买单模式"></a>男生买单模式</h4><p>第一种模式，就是男生买单模式。</p>
<p>顾名思义，就是男生负担全部或主要开销，最常见的是在一场旅行中由男生承担大部分费用。然后男生会从承担约会费用到共同生活费用，甚至最后是女生的个人开销，难度依次升级。虽然现在讲究个男女平等，但是在中国传统观念中，男女交往由男生买单仍然是非常自然的一个选项。</p>
<p>这个模式比较适用于男生经济条件较好的情况，这时候，女生往往就会主要负担家务、情绪等其他方面的责任。好处在于两个人的经济关系和社会主流方向贴合，不容易出现什么分歧，坏处就是男生负担可能会比较重，女生在经济上形成依赖，难免在相处中会引发关系失衡。</p>
<h4 id="男女-AA-模式"><a href="#男女-AA-模式" class="headerlink" title="男女 AA 模式"></a>男女 AA 模式</h4><p>这种模式现在比较普遍，指的是两个人对于产生的共同开销，比如约会和共同生活费用会进行 AA。常见于两个人相识前期，且更多见于一线大城市的白领们，思维更能对抗传统观念。</p>
<p>但实际上这种模式问题也很多，一是伤感情，双方算的太细容易伤感情；二是压力，当双方经济能力不对等的时候，容易给低收入一方产生较重的负担；三是委屈，即便是两个人共同开销，肯定用的也不是一样多，简单 AA 每次都会有人吃亏，日积月累就会造成很强烈的损失感。</p>
<h4 id="轮流买单模式"><a href="#轮流买单模式" class="headerlink" title="轮流买单模式"></a>轮流买单模式</h4><p>第三种模式，就是轮流买单模式，又可称为模糊 AA 模式。</p>
<p>双方轮流买单，支付约会活动费用，推而广之，循环往复。比如共同生活费用，你负责电费我就管水费，你出房租我就出伙食，大家算个大概齐就行，出的差不多。</p>
<p>这可能是大部分人理想中的开销模式。我问过很多人，他们觉得 AA 过于生分，一方全买又过意不去。最好是大家都很自觉地互相承担，抢着买单然后最终两个人分担开销。不过这个模式的缺点在于囚徒困境，因为没有明确规则，所以必须两个人都做相同选择才行，不然很容易崩。</p>
<h4 id="共同基金模式"><a href="#共同基金模式" class="headerlink" title="共同基金模式"></a>共同基金模式</h4><p>这种模式比较友好，就是双方每月各拿出一定数额的收入，放进一个“共同基金”中，用于支付共同开支。不过，这个模式多见于长期同居或者已经结婚的恋人之间，有信任基础。</p>
<p>这个模式优点很多，既讲灵活也讲公平，很多家庭都是采取这种消费模式。</p>
<p>不过，这个模式最大的短板在于，两个人对共同基金的投入份额和支出用途可能会存在一定的分歧。如果没有两个人较为一致的观念，很容易就这一进一出两个问题发生争执。</p>
<h4 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h4><p>每对情侣的情况各不相同，消费模式自然也是百花齐放。有女生全包的、有男生管饭女生管穿的，也有前半月男生买单尽情潇洒，后半月女生包养细水长流的……</p>
<p>所以你看，其实情侣之间的消费模式，会受两个人的观念、收入、消费习惯和家庭影响等等因素影响，并无定法。没有哪种模式百试百灵，也没有哪种模式是只有优点没有缺点的。</p>
<h3 id="情侣谈钱的时候，究竟是在谈什么？"><a href="#情侣谈钱的时候，究竟是在谈什么？" class="headerlink" title="情侣谈钱的时候，究竟是在谈什么？"></a>情侣谈钱的时候，究竟是在谈什么？</h3><hr>
<p>那你可能要问了，既然消费模式没有普世的最优解，那么我应该选哪种？</p>
<p>选哪种这个问题，应该由你和你的对象共同决定。不过，今天我想跟你说点比消费模式更高层级的东西。也许你听完我的分析过后，你就可以解决包括消费模式在内的更多的困难。</p>
<p>我们在谈钱的时候，究竟是在谈什么？</p>
<h4 id="谈感情"><a href="#谈感情" class="headerlink" title="谈感情"></a>谈感情</h4><p>当你在审视你和另一半之间经济开销的时候，你考虑的实际上是双方对这段感情的投入程度。因为，真金白银的投入，的确是检视一个人投入程度的重要指标之一。</p>
<p>如果一个男生明明经济条件很好，却吝啬于和你在一起的每一顿饭钱，我们当然有理由怀疑他的真心；如果一个女生明明自己有收入，却要她的伴侣承担全部开销，并不断索要贵重礼物，我们当然有可能怀疑她把这个男生当成钱包和饭票。</p>
<p>但是，如果你们双方都有金钱投入的时候，仅仅是在消费事项和投入比例上产生矛盾，我不建议你把经济问题上升到感情问题。因为这时候你们谈钱，大概率谈的是下面的两个问题。</p>
<h4 id="谈价值"><a href="#谈价值" class="headerlink" title="谈价值"></a>谈价值</h4><p>常有人说自己三观跟着五官走，但在一段亲密关系中，三观还是比五官更为重要。三观相合不是虚无缥缈的嘴炮，体现在生活的方方面面。特别容易凸显的，就是在消费问题上。</p>
<p>有人觉得谈恋爱就该男生付钱，但也有女生觉得男生全部付，是大男子主义；</p>
<p>有人觉得共同开销就应该 AA，还有人觉得男生吃饭吃的多，凭啥 AA；</p>
<p>有人觉得谁提议谁买单，有人觉得怎么我爱吃日料你爱吃麻辣烫，活该我倒霉呀；</p>
<p>有人觉得怎么花钱应该靠自觉，谈钱太俗气，有人觉得先说定后不乱才不会伤感情；</p>
<p>……</p>
<p>价值观这东西，你聊不出对不对，只有合不合。</p>
<p>就比如在武侠江湖中，你站在方证、冲虚两个外人的视角上，你目睹岳不群坑女儿、偷剑谱、练辟邪，作为外人，你会觉得岳不群真是虚伪无耻，野心勃勃。</p>
<p>但是，你要是站在岳不群的视角，你觉得自己是忍辱负重、死中求活，通过个人不懈的奋斗保住了祖宗基业，把华山派死局盘活了。而方证、冲虚维持武林旧秩序，那才是虚伪无耻，野心勃勃。令狐冲要不是人生开挂，先捡风清扬老爷爷后捡圣姑，那就是胸无大志的败家玩意。</p>
<p>所以，一个月生活费两千块的女学生，很难理解自己年薪三十万的男朋友，为什么两个人出来约会如此抠门。毕竟，在她看来，生活费两千块是全部可以用掉来买买买的。</p>
<p>但是，在她男朋友看来，手头的钱除了当前支出，还要储备买房的钱、应急的钱，养老的钱等等，每一笔都要精打细算的。你看，三观不一致，说不到一起去，肯定是白天不懂夜的黑。</p>
<p>情侣谈钱的时候，就是在谈消费观。衣食住行应该怎么分配、远中近期资金应该如何储备、先买房还是先租房；买房买多大、租房租哪里等，这一项一项是非常具体，无所遁形，绕不过去的。</p>
<p>消费观是价值观的最直接反映，所以谈钱是个验证和磨合三观的好机会。</p>
<h4 id="谈妥协"><a href="#谈妥协" class="headerlink" title="谈妥协"></a>谈妥协</h4><p>正如这个世界上没有完全相同的树叶，也没有完全相同价值观的人。</p>
<p>两个人三观完全一致，那是不可能的，我们也无须抱着这样的目标去寻找爱人。问题更加关键的地方在于，当两个人意见不一致的时候，能不能相互接受、相互配合。</p>
<p>比如说，任我行的价值观就是千秋万载、一统江湖，这和令狐冲的琴瑟和谐、笑傲江湖的梦想自然没法磨合。但是最后向问天当了教主，他价值观是大路朝天、各走半边，这和令狐冲虽然不一样，却差不多一个意思，还是可以磨合的。</p>
<p>换在现实生活中，有人觉得应该少挣多花，所以去借套路贷之类的，这和秉持多挣少花原则的人肯定没法磨合。但是，有人觉得应该多挣多花，有人觉得应该少挣少花，这在一定程度上和多挣少花的人完全可以互相包容，无非是一个度的问题。</p>
<p>在这个过程中，可能两个人会暴露出很多不一致的问题：</p>
<p>多挣是多少？</p>
<p>多花和少花的界限在哪？</p>
<p>如何排除情绪、意气之争进行协商？</p>
<p>……</p>
<p>这都是你们在谈钱的时候要训练的事情。与此同时，这些问题的度究竟维持在什么程度，以及你们愿意为对方付出多大程度的妥协，也是一个重要的感情考验。</p>
<p>但是，好在消费观念是可变的，今天我觉得天天喝星巴克难以负担，是多花了；可能明年我收入爆炸增长，就觉得天天喝星巴克也不过如此。</p>
<p>怕就怕出现决不妥协的价值观排异。我不喝星巴克，我还要说喝星巴克的都是小资装逼犯；我不吃汉堡包，我还要说那不就是个肉夹馍；我不用化妆品，我还要说买化妆品都是交了智商税。</p>
<p>你要记住，越强大的人，越能兼容别人的价值观。这是爱的能力的修炼，也是人生的修炼。</p>
<p>所以，如果你和对象谈钱，仅仅是在讲我花多了你花少了，又或者是今天这钱该不该花，那你们就会陷入无休止的争吵中去，永远没有尽头。你如果跳出钱来谈钱，从更高层级去谈感情、谈价值、谈妥协，这才是更长远、更全局的，达成一致后，钱怎么花的问题自然也会迎刃而解的。</p>
<h3 id="如何谈钱不伤感情？"><a href="#如何谈钱不伤感情？" class="headerlink" title="如何谈钱不伤感情？"></a>如何谈钱不伤感情？</h3><hr>
<h4 id="谈不谈"><a href="#谈不谈" class="headerlink" title="谈不谈"></a>谈不谈</h4><p>其实很多人在这个问题上就停住了，很多人觉得和伴侣谈钱太刺耳，不能提。但实际上，这个问题你回避不了，你在心里憋久了，总会找一个出口爆发。不要觉得谈钱是算计，其实不谈更煎熬。两个人在一起，经济不平等，多花钱的人固然难受，少花钱的也未必就舒服。</p>
<p>最痛苦的莫过于在交往中无时不刻地计算，对方在自己身上花了多少钱、自己这份爱在对方那里余额还有多少、自己还能值多少钱。有时候这不是想占便宜，是怕占便宜却无能为力地彷徨。</p>
<p>所以情侣之间，钱还是要谈一谈的好。</p>
<h4 id="何时谈"><a href="#何时谈" class="headerlink" title="何时谈"></a>何时谈</h4><p>应该谈钱，不代表立刻马上就要谈钱。时机很重要，错误的时间说正确的话，那依然是个错误。</p>
<p>如果你们刚刚建立情侣关系，这时候开销不多，两个人了解也有限，非要就消费模式定个 123，那就显得你对人家防范心理过重了。除非你有王位等着继承，否则，我建议你还是等合适时机，再来谈论钱的问题。</p>
<p>什么叫合适时机？</p>
<p>第一种情况就是双方关系稳固了，准备进入谈婚论嫁阶段了，这时候必须要谈一谈这个问题。虽然恋爱关系本质是精神关系，但是婚姻却是法律关系，法律关系的本质是经济关系，经济关系就肯定是要谈一谈经济问题的。</p>
<p>第二种情况就是当花钱的问题给你造成了实际负担和困扰，那你必须要谈。恋爱既然本质上是精神上追求幸福，那么当恋爱关系附带的花钱问题让你不幸福，你就必须正视这个问题了。</p>
<p>在这两种情况下谈，利大于弊，对感情的帮助大于伤害。</p>
<h4 id="怎么谈"><a href="#怎么谈" class="headerlink" title="怎么谈"></a>怎么谈</h4><p>到了谈的时候，要把握这几个原则，双方更容易达成一致：</p>
<p>第一，相互体谅</p>
<p>能力有大有小，消费有多有少，所以你要本着相互体谅的态度去求同存异。我们最理想的心理状态应该是这样：你有倾其所有的态度，对方却没有理所应当的想法。</p>
<p>第二，量力而行</p>
<p>钱不是问题，没钱才是问题。我认为绝大多数关于花钱的争执，还是在于经济能力跟不上物质需求。顾头不顾腚，顾腚就不能顾头，这才引发矛盾。就像韩国电影《寄生虫》里所说的，钱就是熨斗，能烫平一切褶皱。作为一个穷人，我想象如果有足够多钱的话，这方面矛盾自然会消解。</p>
<p>不过，除了提高经济能力，还有一个解决方法就是降低物质需求，不能开源，就节流。两个人在一起，经济开支出现压力，共同降低消费水平，量力而行也是一个比较可行的方向。</p>
<p>第三，控制范围</p>
<p>无论是 AA 还是一起花钱，都只是消费观的一种差异而已。</p>
<p>你们要做的是求同存异和磨合价值观。万万不要放大问题矛盾，说一个女生物质，说一个男生不爱自己，这一下就把中性的价值观问题，上升为人品问题和感情问题了。</p>
<p>第四，不行就分</p>
<p>如果对方真的很物质，真的不爱自己，没什么好谈的，也不可能靠谈解决问题，那就分手吧。</p>
<p>在一段感情中，绝不轻言分手，但也绝不害怕分手，这样反而更容易保持独立，吸引对方。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>怎么花钱是两个人交往过程中绕不开的话题，爱情当然高于面包，但没法脱离面包谈纯爱。</p>
<p>今天，我们总结了当今情侣之间花钱的几种常见模式，主要有男生买单模式、男女 AA 模式、模糊 AA 模式以及共同基金模式，我们还分别研究了各个模式的利弊。</p>
<p>结论就是，没有完美的花钱模式，所以解决问题的关键在于认清花钱模式背后的本质，然后根据自身情况加以选择。情侣之间谈钱，其实谈的是感情、谈的是价值、谈的是妥协。</p>
<p>我们要跳出就花钱谈花钱，要从更高的层级来审视花钱的问题。</p>
<p>如何谈钱也有很重要的三点要注意，一是必要性的问题；二是时机的问题；三是方式的问题。</p>
<p>最后，我想说，仰望星空，脚踏实地。两个人的爱情不会因为谈钱变得琐碎，就此向现实低头，而是会因为谈钱变得更加真实，就此更加灿烂。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>08 七年未必痒：如何营造亲密关系的新鲜感？</title>
    <url>/2022/11/25/love/08/</url>
    <content><![CDATA[<p>你发现了吗？童话故事的最后，都是王子和公主从此过上了幸福的生活；很多电视剧和电影的结尾，也是只演到男女主人公走入婚姻的殿堂。可是，再往后呢，再往后就不敢写了……</p>
<p>因为，故事在这里戛然而止，一切爱情的美好才可以停留在原地，停留在人们心里。</p>
<p>在金庸武侠里，唯一敢于破例的就是《神雕侠侣》。射雕里古灵精怪的蓉儿妹妹成了神雕里面令人生厌的中年黄大妈、黄帮主、黄女侠，以至于我小时候读神雕一度认为是别人冒名写的。</p>
<p>但是不得不说，在一段感情里，可悲的也莫过于此。两个人经得起轰轰烈烈的紧张冒险，却躲不过平平淡淡的似水流年。三年之痛、七年之痒，握着你的手，就像左手牵右手……</p>
<p>之前，有很多朋友也跟我咨询过，为什么在一起久了，明明感觉自己还是很爱对方的，却总是提不起精神和另一半相处，甚至精神上会偶尔开个小差，对一些一面之缘的小姐姐却想入非非。</p>
<p>其实，这个问题很普遍，不仅会出现在相处多年的情侣之间，也常见于恋爱的各个阶段，</p>
<p>就比如说，两个人谈恋爱了一段时间，都觉得对方的各方面感觉还不错，可是就差了那么一点点触电的感觉。还比如说，有人留言问我，对方说和我相处像朋友多过像恋人怎么办？</p>
<p>这些都指向同一件事——新鲜感。</p>
<p>新鲜感有一种魔力，可以让普通人光彩照人、魅力爆棚；可以让寻常事咫尺兴波、跌宕起伏。这种魔力有多强，失去就有多痛。它可以轻松让你爱上一个人，也可以让你失去一个人。</p>
<p>今天，我们就来探讨一下关于新鲜感的话题。</p>
<span id="more"></span>

<h3 id="新鲜感的本质是什么？"><a href="#新鲜感的本质是什么？" class="headerlink" title="新鲜感的本质是什么？"></a>新鲜感的本质是什么？</h3><hr>
<p>第一个问题，新鲜感究竟是什么？是一种感觉？还是一种对于未知的好奇心理？</p>
<p>有一位著名心理学家，曾提出了一个“恋爱三角形理论”。他认为一段完美的爱情应该由以下三个因素构成——激情、亲密和承诺。</p>
<img data-src="/2022/11/25/love/08/08_1.jpeg" class="">

<p>我们口中所说的新鲜感，就是激情因素中的一种。如果给激情下个定义，激情就是两个人在一起因相互吸引而产生的高强度体验。据统计，激情的巅峰期往往只能维持半年左右。</p>
<p>有人认为，激情就是多巴胺的分泌，但这个想法对我们来说，没什么意义。在我看来（说明这是个独家理论），支撑激情的两个主要因素，分别是不确定性和异性攻击性。</p>
<p>不确定性很好理解，什么是异性攻击性？其实，和我们之前提到的“敢于冒犯”差不多。</p>
<p>这个理论很好地解释了为什么和“渣人”谈恋爱特有激情。第一，因为“渣人”的攻击性特强，一切都以拿下你为目标，持续推进关系；第二，他们又很不靠谱，也就是不确定性特别强。</p>
<p>老实人吃亏就吃在这，一方面，老实人非礼勿视、非礼勿言，攻击性弱到让有些人觉得“禽兽不如”；另一方面，老实人计划性极强，他们习惯把一切行动安排好，讨厌 list 出现任何变化。</p>
<p>所以，当你还在追求期或热恋期的时候，如果对方埋怨你木讷、不解风情、直男 &#x2F; 直女，你不妨从这两个角度下手，增加你们关系中的激情因素比重，提升双方的新鲜感。</p>
<p>还有一个问题，为什么新鲜感难以保持？我们用上面的理论，同样可以来解释这个问题。因为双方呆的越久越熟悉，不确定性就越弱；同时该攻击的也都攻击完了，变得很安全。</p>
<p>你可能会想起来，这节课和我们在第 5 讲，探讨两个人在一起没事干怎么办的问题时，面临的困境有些类似，都属于激情过后的如何面对低谷期的问题。但是第 5 讲，我们主要从“亲密”和“承诺”这两个因素来展开，讲的是如何通过构建三角形的另外两级来替代激情的消逝。</p>
<p>亲密和承诺就像一道菜的食材，而激情却是食材的调味品。光吃调味品的话，入口可能很鲜，但是吃不了几口；但是如果没有调味品，再好的食材也会差了点味道。</p>
<p>那么，接下来，我们就来看看，如何持续营造新鲜感，给爱情调调味。</p>
<h3 id="新鲜感的提升思路是什么？"><a href="#新鲜感的提升思路是什么？" class="headerlink" title="新鲜感的提升思路是什么？"></a>新鲜感的提升思路是什么？</h3><hr>
<p>首先，我们要明确，提升新鲜感，是和旧人做新事，不是和新人做旧事。通过不断更换伴侣寻找新鲜感的做法，无异于饮鸩止渴，从长期看是有损于新鲜感建立的。</p>
<p>其次，我们还要明确，提升新鲜感并不是靠所谓的创意和惊喜，没有人的创意是可持续的，最伟大的作家也做不到。你在网上搜索的所有创意套路也都是有限的，且很可能别人见过。</p>
<p>所以，从不确定性和攻击性两个维度来看，持续营造亲密关系的新鲜感主要有以下两种思路：</p>
<h4 id="思路一：于变局中开新局——拥抱变化"><a href="#思路一：于变局中开新局——拥抱变化" class="headerlink" title="思路一：于变局中开新局——拥抱变化"></a>思路一：于变局中开新局——拥抱变化</h4><p>每个人都有自己的生活习惯和规律，当两个人成为情侣的时候，其实互相磨合对方的习惯和规律就是一件特别有新鲜感的事情。你会发现，哦，原来生活还可以这样过。</p>
<p>所以，情侣刚在一起的时候，新鲜感十足，每天都在享受新鲜感带来的变化。</p>
<p>但是磨合完毕后，一切又变得完全可以预测，新鲜感也随之消失。所以，营造新鲜感的第一个重要的方法，就是拥抱变化。可能你要问，生活中哪里会有那么多变化呢？</p>
<p>拥抱变化其实很简单。</p>
<p>生活中每一件小事，我们都可以用 5W+1H 来总结。也就是，时间、地点、对象、目的、人员、方法。咱们除了人不变，其他都是可以变的，一变感觉就全变了。</p>
<p>比如说，之前我帮助一个朋友解决新鲜感的问题。我就问他，你和女朋友下班回家都干啥？他说，没啥事呀，吃完饭就躺在床上刷剧。我说那好办，你就改成坐在沙发上刷剧试试。</p>
<p>结果就因为挪了这么几步路，换了一个地方刷剧。他说两个人的感觉就变得不一样了，沙发上搂着的感觉跟床上搂着的感觉完全不同。他还想继续说下去，我及时制止了他。</p>
<p>拥抱变化更是一种心态，一种富有新鲜感的心态。</p>
<p>我有个朋友和对象出去旅行总是一肚子气，她作为一个女生，会把行程规划的井井有条、十分精致。但是她男朋友什么攻略都不做，出门一问三不知又拖拖拉拉，导致她频频打乱自己的计划，就会发生争吵。她男朋友还常常抱怨，跟她出去玩是个苦差事，比上班打卡还累。</p>
<p>于是，我就劝她，尝试一次没有行程单的旅行，每天就列一个必去的景点，其他都随心安排。结果怎么着，那次她玩完回来跟我说简直 high 爆了，虽然没有精确到分钟的行程计划，但是也不会按照预想，逐一地去看已经反复筛选过的景色，最美好的都是旅途的相遇。</p>
<p>这就是新鲜感，有的人浑身充满这种感觉，Ta 对于别人来说，就会有强烈的吸引力，但这种感觉是需要进行专门训练的。是的，拥抱变化不仅是一种意愿，也是一种能力的训练。</p>
<p>最基础的训练，就是观察变化、记录变化。比如说，每隔一个周期，可以是天，也可以是周，是月，记录一次你们两个人发生的事情，观察和之前比有哪些变化。</p>
<p>坚持一段时间，你很快就会变成一个“善变”的人，给爱人带来足够的新鲜感。</p>
<h4 id="思路二：于危机中育先机——制造矛盾"><a href="#思路二：于危机中育先机——制造矛盾" class="headerlink" title="思路二：于危机中育先机——制造矛盾"></a>思路二：于危机中育先机——制造矛盾</h4><p>当你们把情侣该做的事情都做完了，你们的苦恼也就从求而不得变成了按时上班、赚钱养家，这样的话，你们的异性攻击性直接降为负数，怎么办呢？</p>
<p>其实很简单，就是一句话：有困难要上，没有困难创造困难也要上。</p>
<p>明明没有危险的事情，要制造危险：你的小宝贝要被渴死在沙发上了，能不能有好心人端杯水出来拯救她啊；</p>
<p>明明没有门槛的事情，要制造门槛：你要是晚上陪我看十五分钟曼联的比赛，今天的晚饭就由我来做；</p>
<p>明明没有矛盾的事情，要制造矛盾：你明知道我今天心情不好，为什么要左脚先进门，罚你说一分钟好听的话来夸我。</p>
<p>你可能会说，这样是不是很作呀？</p>
<p>对，会作的女人最好命嘛，不但女生要会作，男生也要会作，作就能制造新鲜感。</p>
<p>端水、做饭、夸人可能是两个人每天都要做的事情，但是当你为这些日常的事件制造了一点困难后，立刻就会产生别样的新鲜感，成功之后你还会有满足感。就像打游戏一样，刀刀都死一屏幕的怪一点意思都没有，要好死不死才打死一个怪才有意思。</p>
<p>但是，这个矛盾的制造一定要讲究时机，讲究方法。原则就一条，要记住，越是毫无矛盾的事情越要作，这叫有情趣；越是容易发生矛盾的事情，越不作，这叫识大体。</p>
<p>这个矛盾可以是你们两个人之间的，也可以是你们和外部的。</p>
<p>比如说，给娃娃贴上讨厌人的名字，再痛殴一顿；或者找辆灰尘很重的车子，在窗上一起画只小猪，一起做一点小小的违背传统道德的事情，也会极大产生新鲜感。</p>
<p>香港有部电影《志明与春娇》，两个人就是在禁烟背景下，从烟友发展而成的爱情。</p>
<p>所以你看，新鲜感从来不需要什么炫酷的招式。新鲜感就是使某一天与其他日子不同，使某一个时刻与其他时刻不同，如此而已。重剑无锋、大巧不工。</p>
<h3 id="内生的新鲜感"><a href="#内生的新鲜感" class="headerlink" title="内生的新鲜感"></a>内生的新鲜感</h3><hr>
<p>最后，关于新鲜感，我还要讲一点注意事项，就是什么是真正的新鲜感。</p>
<p>你可能要问，什么？还有真正的新鲜感？难道刚才我讲的都是假的新鲜感？当然不是，上面所说的方法确实是营造且持续营造新鲜感的好方法。但是通过前面的课程，你可能已经了解，我这个人特别喜欢讲道与术的差别，上面说的方法，只是术，下面我想再上升到道的层面说两点：</p>
<p>第一，享受新鲜感，就不能过于追求新鲜感。</p>
<p>这就跟吃饭一样，在口味太重尝不出味的时候，定期清淡饮食一两天，之后吃什么东西都有别样的味道。这个道理用佛家的话来讲就是：空即是色、色即是空</p>
<p>新鲜感也是一样，当你在内心将其作为奢侈品而非必需品的时候，才能更好地享受新鲜感。我们必须认识到，新鲜感不是亲密关系的全部。管你黛西艾比莫妮卡，过年回家还不是乖乖回到翠花丫蛋和二妮的状态。因为你和父母之间，不用新鲜感，也可以保持几十年如一日的生活模式，</p>
<p>所以，平淡和规律才是生活的常态，能够坚守常态的人才有能力享受偶尔打破规律的新鲜感；相反，企图把无规律的新鲜感作为常态的人，必然遭受失去新鲜感的反噬。</p>
<p>进一步地，你还需要认识到，亲密关系也不是生活的全部。</p>
<p>亲密关系也只是你生活的一部分，如果将其置于生活之上，那就是本末倒置。相反，保持独立的生活，保持独立的人格，你才能保持给对象的神秘感。360 度无死角展现在对象面前的人是不可能有新鲜感的，千呼万唤始出来、犹抱琵琶半遮面的人才有新鲜感。</p>
<p>第二，生活是新鲜感的源头。</p>
<p>武侠小说里的男女主人公可能会面临很多问题，生离死别、正邪有别，但就是不会出现没有新鲜感的问题。你看郭靖这样木讷的人，按理说营造新鲜感的能力很弱，但是也没这问题，为啥呢？</p>
<p>因为武侠里，他们的日子一天天太新鲜了。又是国仇家恨、又是拜师习武、又是路见不平、又是闯关打怪的，天天肾上腺素爆棚，哪里有功夫闲下来想没有新鲜感的事情。</p>
<p>每个人都是一个世界，亲密关系的新鲜感是你进入对方世界，分享自己世界的过程中产生的。</p>
<p>有的人可能比较擅长营销，他分享自己世界的窗口时，就十分酷炫，所以很容易让人着迷，大家都觉得这个人有激情。所以，纵然我们在前面讲了如何多维度地展现自己的世界，如何高亮度地装扮自己的窗口，但是最根本的还是你这个世界够大、够精彩。</p>
<p>在作家圈里，刘慈欣遣词造句的能力不算一流，但《三体》火到出圈的背后，就是足够精彩的世界，不假外物的内生新鲜感才是真正的新鲜感，这就是三体对大量文学作品的降维打击。</p>
<p>过好自己的每一天，就是营造自己新鲜感的降维打击。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>情侣交往的各个阶段，特别是关系稳定之后的长期阶段，往往会出现缺乏新鲜感的问题。</p>
<p>今天，我们利用恋爱三角形理论（激情、亲密和承诺）分析了激情因素的产生，也就是新鲜感的实质，指出新鲜感的关键其实在于不确定性和异性攻击性。</p>
<p>利用这个理论，我们讲了两个提升新鲜感的方法，一是拥抱变化；二是制造矛盾。拥抱变化是一种意愿，也是一种要训练的能力；制造矛盾要选择合适的时机，以及合适的方法。</p>
<p>最后，我们从内生角度，探讨了更加持久稳定的新鲜感构建方法。一是降低预期，保持独立，不要一味追求新鲜感；二是花若盛开，蝶自然来；你若精彩，天自安排。</p>
<p>愿你每一天的太阳都是新的。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>09 相亲与恋爱套路不一样：相亲有哪些需要注意的？</title>
    <url>/2022/11/25/love/09/</url>
    <content><![CDATA[<p>最近几年，在春节期间，很多单身的男男女女回家之后，除了和家人欢聚和团圆之外，还有一个重要的任务，就是在父母亲戚的催促或者朋友的牵线下——相亲。</p>
<p>曾经就有朋友告诉我，过年回家的时候，相亲了好几个人，最后虽然对象没找到，但是三天之内看了四遍的《流浪地球》，写的影评大受好评。</p>
<p>这要只是多看了几遍电影，倒也还好，最怕的就是相亲碰上一些奇葩。</p>
<p>比如说，有第一次见面就约人家姑娘晚上九点出门压马路的；有还没见过面就喊姑娘过年陪自己回农村老家的；还有第一次微信聊天就交代跟自己谈恋爱的三大纪律八项注意的。</p>
<p>所以，一说起相亲，就总有人吐槽这些另类的、夺人眼球的奇葩体验，导致不少人对相亲心存顾虑。还有人把对长辈催婚的不满情绪代入了随后的相亲环节，产生了一些先入为主的不良印象。</p>
<p>正是因为相亲中的这种负面体验内容频频上热搜，相亲妖魔化似乎成为了一种潮流。</p>
<p>其实，相亲只是一种开启恋情最为常见的方式，是一种打破社交圈壁垒结识异性的有效方式，也是一种缩短试探期，加速恋情的高效方式。因此，我们既不应该妖魔化这种方式，还要正确地认识到相亲与其他恋爱模式的特殊之处，有效地利用这种模式。</p>
<span id="more"></span>

<h3 id="先别排斥相亲"><a href="#先别排斥相亲" class="headerlink" title="先别排斥相亲"></a>先别排斥相亲</h3><hr>
<p>其实相亲就是以恋爱为目的，通过他人介绍去结识异性的方法，和其他认识异性的方式，没有什么本质区别。所以，在介绍相亲这件事之前，我们先纠正几个对相亲的错误认识：</p>
<h4 id="错误一：相亲是对爱情的玷污"><a href="#错误一：相亲是对爱情的玷污" class="headerlink" title="错误一：相亲是对爱情的玷污"></a>错误一：相亲是对爱情的玷污</h4><p>很大一部分拒绝相亲的朋友，往往是对感情特别认真和投入的人。</p>
<p>因为，他们认为爱情是一件非常神圣的事情。然后觉得，相亲这种速配模式本身是对爱情神圣性的玷污，更何况相亲中还总是夹杂着一堆物质条件的匹配，让人更加难以接受。</p>
<p>首先，这种对感情的认真态度是非常值得肯定的，但是有一句话，还是不得不讲的：神圣的事情不拒绝现实的细碎，现实的细碎无损于神圣的意义。</p>
<p>比如说，苏联卫国战争就是件足够神圣的事情，但这样伟大的胜利不是靠口号和理想就能完成的，是由无数件细碎甚至卑微的小人物小事件支撑的。很多时候，红军战士哪怕一枪不发，顶着伤痛和敌人周旋，在斯大林格勒的极寒大雪中孤独地活下来，本身就是神圣的一部分。</p>
<p>爱情的神圣之处也在于，它不仅能容纳阳春白雪，也能容纳下里巴人，而且丝毫无损爱情的神圣。《小时代》里摇着高脚杯，满身奢侈品的叫爱情，难道《乡村爱情》就不叫爱情？</p>
<h4 id="错误二：相亲是对人的商品化"><a href="#错误二：相亲是对人的商品化" class="headerlink" title="错误二：相亲是对人的商品化"></a>错误二：相亲是对人的商品化</h4><p>在相亲前，或者相亲的时候，往往有一个双方条件交换的过程。比如说，最为知名的相亲角——上海人民公园，那里有拿着子女信息的大爷大妈，把相亲搞得就像是互投简历。</p>
<p>许多人就觉得，相亲这件事太物质、太功利了，是把人作为商品。实际上，任何感情最终走到一起，必然存在一个价值匹配的过程。只不过有的匹配是多元的，而相亲初期的匹配是一元的；有的匹配是隐性的，而相亲是显性的；有的匹配是长期试探的，而相亲是一锤子买卖。</p>
<p>但是，实质上都是感情双方的价值和需求匹配过程，只是形式的不同。</p>
<h4 id="错误三：相亲意味着我没异性缘"><a href="#错误三：相亲意味着我没异性缘" class="headerlink" title="错误三：相亲意味着我没异性缘"></a>错误三：相亲意味着我没异性缘</h4><p>还有一部分朋友认为相亲是最后的办法，如果自己去相亲的话，被别人或者朋友知道，就意味着自己在平时生活中找不到对象，很丢脸，所以不到万不得已，不想走到相亲这一步。</p>
<p>我们要改变这种认知，相亲不过是一种社交模式，这种模式与你在酒吧喝酒认识异性、在饭局吃饭认识异性，或者是在牌桌上打牌认识异性，其实没有什么本质区别。</p>
<p>两个人最终走到一起，最根本的还是看人。</p>
<p>一个优秀的人能够选择你，就是你价值的体现。至于这个人是相亲认识的，还是喝酒吃饭打牌认识的，又或是图书馆健身房公益活动认识的，并不存在什么高下之别。</p>
<h4 id="错误四：相亲对象不靠谱"><a href="#错误四：相亲对象不靠谱" class="headerlink" title="错误四：相亲对象不靠谱"></a>错误四：相亲对象不靠谱</h4><p>有人经历了几次不成功的相亲后，就开始对相亲这件事充满失望，觉得相亲对象不靠谱。甚至还常有人说，别人给你介绍什么样的对象，你在别人眼里就是什么人。</p>
<p>其实大可不必生气，当你没有给出任何明确相亲条件的时候，介绍人牵线的心态特别简单。只要是男的单身，女的也单身，那就是天造地设的一对，没有比这更合适了。</p>
<p>假设媒人的社交圈内，只出现了刘亦菲和隔壁二狗子两个单身男女，他都敢把刘亦菲介绍给隔壁二狗子。情商低的介绍人甚至还会加一句，年纪都这么大了，别太挑，我看二狗子这人就挺好。</p>
<p>所以，当你没有方向的时候，哪里都是逆风，与相亲无关。</p>
<h3 id="读懂相亲与其他恋爱模式的异同"><a href="#读懂相亲与其他恋爱模式的异同" class="headerlink" title="读懂相亲与其他恋爱模式的异同"></a>读懂相亲与其他恋爱模式的异同</h3><hr>
<p>相亲只是一种认识异性的方式，依然和所有其他恋爱模式一样，要走完两个人相互了解、相互吸引的过程，最终才能走到一起。所以，千万不要觉得今天相亲看对眼了，明天就可以去民政局领证了，就像不要在大街上问一个异性要到了微信，就把两个人孩子去哪上幼儿园都想好了。</p>
<p>但是相比于其他模式，相亲确实有一些独特之处，知道这些特点，才能制定出合适的相亲策略。</p>
<h4 id="第一，讲究效率"><a href="#第一，讲究效率" class="headerlink" title="第一，讲究效率"></a>第一，讲究效率</h4><p>在其他模式下认识的异性，由于相识场景各不相同，信息交互可能非常不充分，因此效率可能比较低。我甚至见过一种情况，就是追了人家姑娘三个月以后才知道人家有男朋友。</p>
<p>但是相亲因为有介绍人环节的存在，一些显性条件的提前筛选是比较有效的。</p>
<p>比如照片、年龄、学历、工作单位这些情况不容易踩雷。当然，你还要学会分辨介绍人的话，他们一般不会故意欺骗，但一定会有选择地进行吹嘘。例如：</p>
<p>男的，长得很好，身高 170，人有上进心，性格很好，风趣幽默，年薪 20 万。</p>
<p>这里面只有性别、身高和年薪三件事是有效信息，其他都是虚的，这是信息筛选的第一层。</p>
<p>第二层，就是在这个有效信息里面，身高 170 和年薪 20 万这两条都含有比较敏感的数字，一般这种恰好整数的，你也要长个心眼，可能都是要差一点的。</p>
<p>比如说，身高 166<del>169 的一般都会报 170，年薪 16</del>19 万的一般都会报 20 万。所以，身高 171 是真的 171，但是 170 一般会少一点。当然，还存在女生个子比较高，为了成功率往低里报的情况。在南方就有很多这种情况，女生报 175 的身高，往往都超过 175.</p>
<p>第三层，不仅要看他说了什么，更要看他没说什么。比如只说年薪不说工作单位，那么工作单位多半没什么好吹的，职务也可能并不高。只说了身高没说年龄，一般年龄会有点偏大。</p>
<p>第四层，不仅要看有效信息，也要看虚话。比如说长得很好，但没有细节，那一般不会长得特别惊艳。长得特别帅，一定会有进一步的细节介绍。但是，既然说了长得很好，肯定不会特别难看，特别难看的话，介绍人也会回避掉，这个信息就会选择不说。</p>
<p>再比如说，性格很好，幽默风趣这两条呢？幽默风趣未必是一定的，但是人起码是比较外向的。如果不太爱说话、比较闷的，介绍人就会介绍对方说，为人稳重，老实可靠。</p>
<h4 id="第二，目的明确"><a href="#第二，目的明确" class="headerlink" title="第二，目的明确"></a>第二，目的明确</h4><p>其他模式认识的异性，在没有明确关系之前，双方可以是多元发展的。可以做朋友、可以做兄妹、可以做事业伙伴，即便你察觉到对方的异样，在没有积累足够好感度之前，你也可以装傻充愣，假装不知道。甚至在表白的时候还可以无辜地说，我只是想学编程，你居然想睡我。</p>
<p>但相亲的目的是很明确的，双方认识的唯一目的就是搞对象，双方应该建立这个基本共识，不然就不用谈了。因此，在双方确立关系之前，所有负面反馈都应该视为拒绝，不接电话、约不出来、回消息慢，都可以视为拒绝。相亲是不能拿慢热、懵懂之类的原因当借口的。</p>
<h4 id="第三，推进速度"><a href="#第三，推进速度" class="headerlink" title="第三，推进速度"></a>第三，推进速度</h4><p>在之前的课程里，你可能也感觉到了，感情是没有一个明确的时间界限的。我认为每一段感情都有自己的时间表，所以从不给一个客观的时间范围，说到什么时间干什么事。</p>
<p>不过由于提问的人很多，我给出一个大概的时间供你参考。</p>
<p>排除校园恋爱这种可以多年长跑的，自由恋爱从确立关系到一年左右的，是比较适合考虑结婚问题的，而相亲由于目的明确，推进速度可以更快。从首次见面到一个月左右时间确定关系，是比较正常的；如果相亲三个月后还不确定关系的，可能就存在某些问题，可以考虑止损了。</p>
<h4 id="第四，并行策略"><a href="#第四，并行策略" class="headerlink" title="第四，并行策略"></a>第四，并行策略</h4><p>爱情有一个鲜明的属性，就是排他的唯一性。</p>
<p>所以恋爱必须是单线的，同时追求几个对象，那肯定不是真爱，也违背了传统道德，一旦被发现，可能要付出非常惨痛的社交成本。甚至有些女生特别多的师范院校，专门有渣男墙挂人的。</p>
<p>不过相亲只是结识，不算追求，所以是可以并行的。</p>
<p>特别是在过年期间，你完全可以密集安排几个相亲。在没有给出明确答复之前，你可以和不同异性见面相亲。但是相亲一般最晚一周之内要给对方一个明确答复，是否继续接触。一旦你给出肯定答复，就应该停止相亲活动，这是对相亲对象和介绍人的基本尊重。</p>
<h4 id="第五，黑白名单"><a href="#第五，黑白名单" class="headerlink" title="第五，黑白名单"></a>第五，黑白名单</h4><p>其他模式结识的异性，一定是某个瞬间身上的闪光点打动了你，因此你会喜欢上 TA，这种叫作白名单模式。白名单里的人，一定是某些特点吸引了你，比较有魅力，相处比较有激情的。</p>
<p>但是，这个名单里的人由于了解少，很可能也有雷，你们的恋爱过程会是个排雷的过程。随着了解的加深，你要看对方身上有没有让你无法忍受的缺点，没有才能走下去。</p>
<p>相亲恰恰相反，能够走进你相亲名单的人，往往是没什么雷，看着条件都还行，但一时没什么特别打动自己的。这种我建议你采取黑名单模式，只要见面后没有发现什么特别大的缺点，不进黑名单的都可以尝试接触。毕竟，相亲那一两次特定的场合环境，是很难展现一个人闪光点的。</p>
<h3 id="相亲注意手册"><a href="#相亲注意手册" class="headerlink" title="相亲注意手册"></a>相亲注意手册</h3><hr>
<p>下面，我们来聊聊相亲的一些原则和注意事项。</p>
<h4 id="相亲原则一：明确"><a href="#相亲原则一：明确" class="headerlink" title="相亲原则一：明确"></a>相亲原则一：明确</h4><p>在第一次相亲见面前，最好不要在线聊太长时间。毫无基础的两个人聊起来很容易尬，尬聊久了就容易崩。一般互相交换联系方式后，最好一周内安排“真身”见面。</p>
<p>第一次见面后，最好当天就能有明确答复，最长一般不超过一周。这个答复可以直接和相亲对象交流，也可以通过介绍人转达，觉得行就是行，不行就是不行。如果几天没有答复，一般视作不同意，没答复介绍人还催问你什么意向的话，那说明对方对你的印象还不错，介绍人在给你兜。</p>
<h4 id="相亲原则二：礼貌"><a href="#相亲原则二：礼貌" class="headerlink" title="相亲原则二：礼貌"></a>相亲原则二：礼貌</h4><p>俗话说，买卖不成仁义在，相亲即便没有看上对方，也最好给予基本的礼貌和尊重。</p>
<p>这种礼貌体现在见面时，不要一看对方不是很中意，就爱搭不理地，甚至不停地玩手机；又或者出言讥讽，指点江山。特别是不要讲，自己是被父母逼来的，特别减分。</p>
<p>对任何相亲对象都保持尊重，可以极大提高你的社会评价。就如同千金买马骨，千里马就会源源不断上门的。相反，一旦你做出了什么失礼的举动，很容易失去优质的相亲机会。</p>
<h4 id="相亲原则三：委婉"><a href="#相亲原则三：委婉" class="headerlink" title="相亲原则三：委婉"></a>相亲原则三：委婉</h4><p>拒绝对方要委婉，你不是情感导师，不用干我这活，去给人家指出相亲中存在的不足和缺点。</p>
<p>拒绝人家的话，你可以直接发好人卡，说不太合适就好了。同时，也要读懂对方的委婉，当人家给出一个非常宽泛而不具体的理由拒绝你时，也千万不要再追问别人自己哪里不合适了。</p>
<h4 id="相亲原则四：果断"><a href="#相亲原则四：果断" class="headerlink" title="相亲原则四：果断"></a>相亲原则四：果断</h4><p>相亲始终是效率优先的，根据我这么长的咨询经历，相亲第一次没有看中的，很难通过后续发展挽回了。所以，一旦对方表现出不耐烦、不感兴趣，一聊天就去洗澡睡觉的，一定要果断止损。</p>
<p>以上这些属于原则性和指导性内容，适用范围比较广。</p>
<p>最后，我再介绍一些适用范围相对窄一些，根据经验总结出的相亲 tips：</p>
<p>相亲时间：最好选择晚饭或者周末的下午，时间相对充裕；</p>
<p>相亲地点：最好事前征求对方意见，男方给几个选项交给女方来选，不要选太便宜的路边摊，也不要选太贵的大酒店；</p>
<p>相亲穿着：干净整洁即可，男方特别注意头发，女方不要化浓妆；</p>
<p>相亲话题：自身情况的介绍，和介绍人的关系或趣事，兴趣爱好以及对对方的印象，实在不行就谈谈自己的工作，千万不要开黄腔，也不要攻击对方；</p>
<p>相亲技巧：一句话开场就可以极大缓解双方的尴尬，万一谈不成就当交个朋友也是好的，这是降低对方的压力和紧张，以退为进。一句话总结就能赢得对方好感，听介绍人提起你好几次，夸你非常优秀，今天见面发现你真的很棒，正所谓伸手不打笑脸人，夸人永远不吃亏。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>相亲是一种建立亲密关系的常见方法，甚至是占比最高的一种方法。</p>
<p>但是为数不少的朋友对相亲心存顾虑，比较排斥。今天，我们首先分析和纠正了四种对相亲的错误认识，希望你能够不受当前网络妖魔化相亲的影响，以一颗平常心面对相亲。</p>
<p>其次，我们就相亲和其他恋爱模式进行了比较，介绍了相亲的五个特点，一是讲究效率；二是目的明确；三是推进速度；四是并行策略；五是黑白名单。当然，不管相亲有多少特点，相亲也仅仅是以恋爱为目的，结识异性的一种方法而已，恋爱该有的流程都不能省略。</p>
<p>最后，我们给出了相亲注意手册，给出了四条相亲原则，分别是明确、礼貌、委婉和果断。然后，给你提供了一些关于相亲时间、地点和话题的具体的 tips。</p>
<p>根据六度分隔理论，只要经过五次介绍，你就可以和世界上任何一个人相亲。所以，不要紧紧盯着窝边草，好好相亲，可能 gakki 都真的会变成老婆哦！</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>10 恋爱成功不是只有结婚一条路：分手是我错了吗？</title>
    <url>/2022/11/25/love/10/</url>
    <content><![CDATA[<p>这些年，我被问过最多的情感问题大体上归为两类，一类是如何开始，一类是不想结束。</p>
<p>无论多么艰难的开始，总是伴随着希望和憧憬；但表面再和平的分手，也总伴随着内心的挣扎与伤痛。曾经爱得有多么刻骨铭心，结束之后，就有多么的念念不忘。</p>
<p>感情结束，关系终结，回忆消散。有人开始陷在过去的伤痛中，不知如何走出来；也有人一心想要挽回求复合，天天辗转反侧；也有人选择用大量短期高强度的刺激来麻痹自己。</p>
<p>人生若只如初见，何事秋风悲画扇。</p>
<p>我们当然希望把美好永远定格在初见时心动的那一刻，但越是害怕失去，往往越容易失去。</p>
<p>所以，无论你是单身，还是正处于一段恋情之中，又或是不幸正在分手的阵痛期，这一讲，我都希望和你来聊聊分手这个悲伤的话题。</p>
<span id="more"></span>

<h3 id="分手后千万不要干这几件事"><a href="#分手后千万不要干这几件事" class="headerlink" title="分手后千万不要干这几件事"></a>分手后千万不要干这几件事</h3><hr>
<p>为什么我们都不愿意分手？因为，分手不仅仅是和一个人的告别，更是对一种已经习惯的生活方式、一段充满美好的青春时光和一个酝酿多时的未来期许在挥别。</p>
<p>所以，伤心、难过和痛苦都是非常正常的情绪，我们称之为恢复性悲伤，不用刻意控制。</p>
<p>但是，如果我们长时间地陷入这种情绪无法自拔，出现以下几种情况，我们称之为破坏性悲伤，这个时候，我们就得有意识地进行调节了：</p>
<h4 id="1-纠缠"><a href="#1-纠缠" class="headerlink" title="1. 纠缠"></a>1. 纠缠</h4><p>有些朋友难以接受分手的事实，第一反应就是用尽全力去挽回这段感情。</p>
<p>但是，我们要知道，很多事情并非是大力就能出奇迹的。</p>
<p>一天发一百多条微信，甚至平铺六十秒语音方阵；</p>
<p>一个小时打几十个电话轰炸，不接就一直打；</p>
<p>白天去公司找人聊聊，半夜在人家楼下站着；</p>
<p>通过对方家人朋友去喊话；</p>
<p>……</p>
<p>我其实完全理解，当一个生命中如此重要的人要消失在你的世界里时，你心情有多么迫切。无论是语音、文字还是见面，只有建立起和这个人的联系，才能够缓解那种无处不在的溺水感。</p>
<p>但是两个人的关系，不能仅仅考虑自身的情感需求。当这些做法影响到他人生活的时候，必须加以控制。而且就挽回这件事来说，这样死缠烂打毫无帮助，且会进一步增加对方的恶感。</p>
<h4 id="2-跪舔"><a href="#2-跪舔" class="headerlink" title="2. 跪舔"></a>2. 跪舔</h4><p>比纠缠更用力的，恐怕就是跪舔了。</p>
<p>当一段感情终结时，道歉、表态以试图挽回这段感情是很正常的。但是，很多人会把这种道歉表态上升到写万言血书、立生死大誓、斥巨资买礼物之类的行为，就把自己降格了。</p>
<p>自爱者人恒爱之，自轻者人恒轻之。即便没有分手，还处在一段亲密关系之中，两个人关系一旦失衡，也是很容易导致感情破裂的，更何况是已经分手想要挽回？</p>
<p>之前有个新闻，说一个姑娘不远千里从浙江赶到北京，穿着婚纱参加前男友的毕业典礼。结果她前男友连感动都没有，直接拒绝了她。跪舔的行为看似大胆，看似牺牲，其实都是自我感动。</p>
<p>记住，分手后千万不要妄图用诸如“付出”“痴情”“跪舔”来挽回对方，这些事情会让前任看不起你，也会让未来的你看不起现在的你，更会降低你的社会评价，给你未来的对象凭空增加很多包袱。</p>
<h4 id="3-自虐"><a href="#3-自虐" class="headerlink" title="3. 自虐"></a>3. 自虐</h4><p>比跪舔更用力的，莫过于自虐了。我一般不批评人，但是自虐的确是件傻事。</p>
<p>自虐自伤是自轻的最高级，也是情绪不稳定的最高级，同样还是暴力倾向的一种前兆，基本集合了所有的情感大雷。一旦我们做出这种行为，几乎就直接宣判了感情的死刑。</p>
<p>除了自伤之外，自虐还有一些其他的表现形式，比如借酒消愁、比如一场大病、比如消沉低落。这些广义上的自我伤害可能会引起一些人甚至包括前对象的关注。</p>
<p>当年，令狐冲被小师妹甩了之后就是这个状态，不过丝毫无助于挽回。</p>
<p>但是，就算自虐赢得了对方关注，也不会长久。记住，怜悯永远换不来爱情。</p>
<h4 id="4-甩锅"><a href="#4-甩锅" class="headerlink" title="4. 甩锅"></a>4. 甩锅</h4><p>不愿接受分手现实，除了以上三种企图挽回的思路，还有一种常见的态度，就是甩锅。</p>
<p>比如说，被提分手的时候，勃然大怒，“你还跟我分手，我跟你分手还差不多”；又比如，在分手的时候，指责对方种种不好，四处倾诉自己在这段感情中，受了多少委屈。</p>
<p>这是人之常情，人在失去的时候会本能地进行归因。当这个归因指向外部的时候，才会降低失去的焦虑感。我们都习惯于在一个失衡的环境下，合理化自己的处境，这符合人的天性。</p>
<p>但是，成年人的世界要讲成年人的法则，买卖不成仁义在。</p>
<p>如果对方真的是一个一无是处的混蛋，那这种甩锅在旁人眼里，不过是对你自己眼光的否定。所以，只要对方没有犯什么原则性的错误，比如出轨、家暴，还是得饶人处且饶人吧。</p>
<p>特别是男生，如果一个男生在分手之后，能把分手的责任都揽到自己身上，和外人说“是我当时太年轻了，还不懂爱”，会对自己形象有很大的加分。</p>
<h4 id="5-放纵"><a href="#5-放纵" class="headerlink" title="5. 放纵"></a>5. 放纵</h4><p>还有一种朋友，看似已经走出了一段恋情，马不停蹄地进入了一段新的恋情，甚至日日狂欢，夜夜笙歌，疯狂在朋友圈秀恩爱，其实这都是心里没放下。</p>
<p>宣布新的恋情，亦或是高调宣示自己有的是人追，说白了都是秀给前任看的。</p>
<p>恰恰说明其内心还在乎，但是这种走出恋情的方法，不会让前任觉得嫉妒，反而会让人家觉得自己离开是正确的。同时，这对新恋情也十分不公平，有把新对象沦为工具人之嫌。</p>
<p>而且，还要强调一点的是，如果一个人处于失恋的痛苦中，却迅速走入了一段新的感情，其实也是对自己的不负责任。因为这个时候人的判断能力是受到干扰的，很多人在经历一段爱情长跑分手后，倘若短时间就进入一段新感情并结婚，后面多少会有点后悔。</p>
<p>分手后痛苦是必然，失恋对于大部分人来说，也真的不是一件小事。</p>
<p>你越难受，说明你对这一段感情投入得越多。你曾经为对方不远千里来到一个陌生的城市定居，举目无亲重新开始；你为对方放弃了坚持多年的兴趣爱好，攒下所有积蓄期盼着能买房结婚；为对方主动萎缩了自己的社交圈，从学校风云人物变成街边买菜大叔……</p>
<p>这哪只是一段感情呀！这是全部的过去、现在和未来，这是纯粹的热血、青春和希望。</p>
<p>所以，说没就没了，难受是正常的。可是，就算是难受，我们也不能做上述五件事。这种坚持，才是给这段承载了太多的感情留一个最体面的落幕。</p>
<p>同理，如果分手后，你的前任有上面五种行为，我也不建议你考虑复合。</p>
<h3 id="恋爱不是单选题"><a href="#恋爱不是单选题" class="headerlink" title="恋爱不是单选题"></a>恋爱不是单选题</h3><hr>
<p>不知道你有没有发现，越优秀的人越难走出失恋的阴影。</p>
<p>因为他们从自身经历习得了这样一种逻辑：好好学习——考上好初中——考上好高中——考上好大学——找个好工作。只要足够投入、战胜对手，就会赢得回报。</p>
<p>然后这套逻辑在感情里就成了：用力爱 Ta——对象搞起——领红本本——白头偕老。所以，一旦他们和恋人分手，这个逻辑指向就是我肯定有哪里做得不够好，才导致了最终的失败。</p>
<p>所有破坏性悲伤，本质都是自我否定。</p>
<p>一旦进入自我否定，就仿佛进入了一场死循环。自身的行动会反复强化这种自我否定，拼命挽回是希望通过前任的再度认可，来证明自己纠错成功；迅速进入另一段未经成熟考虑的恋情，也不过是希望通过第三人的肯定，来认可自己。这些做法之所以弊大于利，原因在于两点：</p>
<p>第一，我们是在把自身价值寄托于他人的判断之上。这只能是镜花水月、梦幻泡影，以我为主的原则前面已经说过很多次，这次就不展开讲了。</p>
<p>第二，我们对恋爱成功的定义过于一元化了。喜欢一个人并不是只有成为情侣才叫成功，情侣也不是非要结婚领证才叫成功，结了婚也不是非得生了娃才叫成功……</p>
<p>成熟的重要标志之一，就是认识到人生是多元的。</p>
<p>恋爱不是升学考试，也不是闯关打怪，不存在非要拿了一血才能进入下个地图。生命中出现一个你喜欢的姑娘，如果她恰好也喜欢你，那么很好，你们可以相伴走过一段人生的旅程；如果她并不喜欢你，那么也很好，邂逅了别样的风景，也是为你的旅途增添了一抹亮色。</p>
<p>旅行重在那一刻的心情，重在你内心感受的美丽，不是非要写下 xx 到此一游或者在一块印着超级大 logo 的大石头旁边，打卡拍照发朋友圈才算旅游。</p>
<p>恋爱也是一样，如果每一段感情都得走向婚姻才算成功的话，那表白都应该选在民政局门口。</p>
<p>罗密欧与朱丽叶、梁山伯与祝英台、萧峰和阿朱都没结成婚，但是，你能说这感情不成功吗？事实上，按照平均一个人谈 3 次恋爱才会结婚的标准答案，分手才是常态。</p>
<p>要相信，今天的你我都是由过去的你我经历集合而塑造的。在一段感情中，成功和美好之处在于和这个人走过的独一无二的经历有多丰富，而不是这个人最后的肉身归属。</p>
<p>另外，从现实角度看，相比于和一个并不合适的对象走进婚姻，分手就是巨大的成功。毕竟，分手的成本比离婚可要小太多了。此外，分手还强行赋予你一种能力，一种保持独立生活的能力。</p>
<p>所以从各个角度看，分手仅仅代表一段感情的结束，并不意味着任何人或者一段感情的失败。当我们走出成者王、败者寇的内卷思维后，才能放下自我否定而去真正享受每一段感情。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>《孙子兵法》有云：昔之善战者，先为不可胜，以待敌之可胜。不可胜在己，可胜在敌。</p>
<p>毛主席也教导过我们，要从最坏处着眼，向最好处努力。所以，无论你处于爱情的什么阶段，了解一下分手这件事，总没有坏处。</p>
<p>今天，我们谈到了分手之后感到痛苦是很正常的，但是，我们绝不要做以下五件事——纠缠、跪舔、自虐、甩锅和放纵。</p>
<p>这既是基于现实主义的考虑，对个人社交形象的一种维护；也是基于理想主义的考虑，给一段真挚的感情留下最后的体面。</p>
<p>最后，我们溯源根本，这些破坏性悲伤的本质，其实都是一种自我否定。我们要摒弃一元的价值判断体系，采取更为多元的方法去判断人生。</p>
<p>分手不意味着失败，结婚也不意味着成功，每一段经历都是生命不可分割的色彩。</p>
<p>不轻言分手，但也不害怕分手，才会让你更好地享受恋情的美好。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>11 独身主义也不赖：选择不结婚究竟是选择了什么？</title>
    <url>/2022/11/25/love/11/</url>
    <content><![CDATA[<p>到目前为止，我们已经结束了对爱情全流程的讨论。从今天起，我们将开启三类常见爱情模式的全新话题。第一个要讲的，甚至不能叫爱情模式，而是一种反爱情模式——独身主义。</p>
<p>正如独身主义的口号宣称的一样，“单身一时爽，一直单身一直爽”。很多大都市的单身男女坚持自由至上的理念，认为任何人都有不结婚、不恋爱的自由，而且一个人也可以过得很好。</p>
<p>本来作为一个讲恋爱课的老师，我应该旗帜鲜明地反对这种砸饭碗的行为。</p>
<p>但是，基于个人的认知和经验，我对独身主义却是非常支持的。的确，每个人都有自己的恋爱自由权。但是我们要认识到，一个人可以过得很好，只是独身主义的前提条件，而不是根本动力。</p>
<p>真正让人坚持选择不恋爱、不结婚的，并不是一股子叛逆心理中的反爱情因素。实际上，恰恰相反的是，多数独身主义的根源在于对爱情有理想主义的坚守，宁可单身，绝不将就。</p>
<p>当然，这是价值观问题，价值观无对错之分。坚持理想一定会幸福吗？认命将就一定不幸福吗？</p>
<p>今天，我们就来对上述正反两个方面的因素做个分析。</p>
<span id="more"></span>

<h3 id="真的是自己想结婚吗？"><a href="#真的是自己想结婚吗？" class="headerlink" title="真的是自己想结婚吗？"></a>真的是自己想结婚吗？</h3><hr>
<p>如今，自由恋爱的观念深入人心，包办婚姻早已经像一张废纸，被扔进了历史的垃圾桶里，现在大部分的结婚都得经过本人同意才行。但是，本人同意就一定是本人意志的体现吗？</p>
<p>并不一定。</p>
<p>绝大多数人选择婚姻当然是为了选择真爱，但不容否认，也有一部分人其实是没有做好婚姻的准备，只是因为被“洗脑包”给洗脑了，慢慢变得盲从，导致自己匆匆忙忙就找人托付了终生。结果呢？要么是痛苦地凑合下去，要么是迅速地离婚。</p>
<p>那么，这些讨厌的结婚洗脑包有哪些呢？这些洗脑包主要分为两种：</p>
<h4 id="第一种：什么时间干什么事"><a href="#第一种：什么时间干什么事" class="headerlink" title="第一种：什么时间干什么事"></a>第一种：什么时间干什么事</h4><p>所有催婚的父母，似乎都不约而同地掌握着同一句至理名言——什么时间干什么事。</p>
<p>你上学的时候，他们会告诉你应该六根清净，两耳不闻窗外事，一心只读圣贤书。谈恋爱？那是绝不可能的事情，是坚决不允许的，这叫什么时间干什么事。</p>
<p>在你工作以后，他们又马上催你找对象，你仿佛就应该秒懂如何找对象，找到对象就要赶紧结婚，结了婚要赶紧生小孩，生了小孩还要赶紧生二胎，这叫什么时间干什么事。</p>
<p>其实，父母们这么想也是情有可原的。我们的上一代，是在集体主义和计划经济氛围下生长起来的人，每个人的人生节奏都差不多，也有相应的条件支撑。在他们的认知里，大家都得对着这个时间表来过，人生才不容易出错，离经叛道的人往往没什么好下场。</p>
<p>但是，时代变了。在当下的中国，人与人的差别在拉大，人生的道路也充满了无限多的可能。我们不能再用同一把尺子去丈量每个人的人生，这在客观上已经不适用了。</p>
<p>但是，还是有很多人在这个洗脑包的洗脑之下，认为三十岁不结婚就是不孝，三十岁不结婚以后就不好结了，所以选择用一种运动式甚至突击式的恋爱来抢占三十岁大关。</p>
<p>因为，纵使时代如风云一样改变，传统的观念却依然强大。</p>
<p>传统的惯性不会仅仅靠一代人的时间就能停下，甚至发生转折。比如说，《傲慢与偏见》写于 19 世纪初，工业革命都已经搞了半个世纪，可是里面的班纳特一家五个女儿还是没有继承权。要再过一百多年直到 1925 年，大清都亡了十几年，英国才废除限定继承权。</p>
<p>这样推算下来，我们想在短期内靠社会自身力量来扭转这种理念是很难的，必须要靠个人的清醒来对抗群体灌输。读书的时间干读书的事情没有问题，但是并不存在什么应该恋爱的时间，应该结婚的时间。你在什么时间遇到那个让你心动的人，什么时间才应该恋爱。</p>
<h4 id="第二种：找不到对象的是-loser"><a href="#第二种：找不到对象的是-loser" class="headerlink" title="第二种：找不到对象的是 loser"></a>第二种：找不到对象的是 loser</h4><p>在我小时候，单身羞辱还仅限于大龄男青年——老光棍。当时的外国电影里，中学生会因为没有对象、没有性经验而感到自卑，甚至受到公开羞辱，这还是一种无法想象的文化环境。</p>
<p>仅仅十来年过去，单身羞辱已经开始无差别火力覆盖了，大龄剩女、屌丝、老处男，直至女博士、老实人、直男癌、小镇做题家等等，只要没对象，总有一个帽子能扣上来。现在流行吹性魅力、吹征服力、吹约炮百人斩，以至于有些小三、绿茶、海王开始不以为耻，却反以为荣。</p>
<p>在这种语境下，个人的拼搏奋斗、学识谈吐都不重要。这个世界上，就分两种人，有对象的和没对象的。人的成功程度，完全取决于其对象的颜值……</p>
<p>连颜宁和杨丽萍这样的女神，都被中年大妈嘲讽说，一个女人最大的失败就是没一个儿女。</p>
<p>正所谓三人成虎，不少人也从内心深处开始认同，有没有对象，或者有多少对象才是衡量人生意义的标尺，为了脱个单不惜耗费大量的时间精力。如果说，到时间就该结婚这种观念，虽然强大，但是终将过去；那么，找不到对象就是 loser 的观念，正在慢慢地占据未来。</p>
<p>一个人，如果把证明自己生命价值和意义的事情，寄托在能否找到一个高颜值对象这种外因上，那么，他整个生活就是颠倒的，无异于缘木求鱼。</p>
<p>爱情可以产生在各种各样的环境和场景，但我希望你在进入一段亲密关系前，千万要反思一下自己，是不是因为这两种洗脑包给你制造的恋爱焦虑，才驱动你谈恋爱的。</p>
<p>反过来说，在当下，如果你坚持独身主义，恭喜你，你起码战胜了以上这两种洗脑包。</p>
<h3 id="独身主义意味着什么？"><a href="#独身主义意味着什么？" class="headerlink" title="独身主义意味着什么？"></a>独身主义意味着什么？</h3><hr>
<p>有人说，不结婚的独身主义好处多多，自己挣钱自己花，一个人吃饱全家不愁，想干啥就干啥，没人管，没人约束。可是，自由都是有代价的，从来没有不需要抵抗重力的飞翔。</p>
<h4 id="经济代价"><a href="#经济代价" class="headerlink" title="经济代价"></a>经济代价</h4><p>我们前面提过，婚姻作为一种法律关系，实质是一种经济关系。</p>
<p>这种经济关系能经过千百年的传承，说明其效率在一般情况下是高于单身的。</p>
<p>只要有过独身生活的人一定会深有感触，工薪阶层白领两个人在一起无论是租房、吃饭等开销的分担，还是攒钱的速度，都是显著优于单身的。除此之外，两个人通过婚姻关系连接，抗风险能力也会显著增强。独身在外地的朋友只要得过一次病，就能充分体会到其中的艰辛。</p>
<p>我相信，大部分选择独身的朋友，正值壮年，已经做好了承担这些经济代价的准备。但是，从社会的角度来说，希望你还要充分考虑到未来老龄化背景下养老的储备。</p>
<h4 id="舆论代价"><a href="#舆论代价" class="headerlink" title="舆论代价"></a>舆论代价</h4><p>相比经济代价，坚持独身的朋友的压力，更多地来自于舆论。尤其在小城镇，大多是熟人社会，高密度人际关系无处不在。坚持独身是一个态度问题，会被视为异类，继而招来无处不在的说教、嘲讽和排斥。对你抱有善意的人会向你施压，对你抱有恶意的人也会向你施压。</p>
<p>在大城市，舆论环境还算相对友好，大家轻易不会跨越社交边界，干涉别人私事，所以北上广深，坚持独身的朋友相对更多。但是可能依然要付出舆论代价，因为可能会被视为一个能力问题，“年纪大了不结婚，这人多少有点什么问题”。</p>
<p>我一个妹妹在上海外企工作，175cm 的高个，盘靓条顺，过年回来却因为没找对象被长辈集体教育。我打着吃宵夜的旗号把她解救出来，安慰她还好是在上海工作，环境比较前卫开放，我们这种小地方比较保守，女孩过了 30 岁不结婚会被看成异类。</p>
<p>结果她神色一下黯淡，说我在别人眼里早就是个怪胎了。</p>
<p>人生之艰难就是这样，有些事情，我们明知道别人是错的，但他们围观和讨论的成本，却要由对的人来支付。我说让你完全不在意，那是玄学，只能尽量远离这些压力源。</p>
<h4 id="情绪代价"><a href="#情绪代价" class="headerlink" title="情绪代价"></a>情绪代价</h4><p>如果说经济代价和舆论代价都是外部的，那么内部的就是情绪代价。任何人情绪都有高潮和低谷，爱人的陪伴是度过情绪低谷期的良方。可没有爱人，独身就要有强大的自我调节能力。</p>
<p>无人与我立黄昏，无人问我粥可温。</p>
<p>无人与我捻熄灯，无人共我书半生。</p>
<p>或许在年轻的时候，这不是个特别大的问题，按照《三重门》（也可能是花季雨季，记不大清楚了）的说法，小学生是一队一队，中学生是一堆一堆，大学生是一对一对。在我们 18 岁的时候，同学朋友确实一大堆，干任何无聊的事情，你都能找到人陪你一起。</p>
<p>但是，随着时间推移，能够肆无忌惮、无话不谈的朋友越来越少，有的淡出你的生活、有的要回归家庭，有的存在利益冲突，就像《老男孩》歌词唱的：</p>
<p>各自奔前程的身影</p>
<p>匆匆渐行渐远</p>
<p>……</p>
<p>抬头仰望着满天星河</p>
<p>那时候陪伴我的那颗</p>
<p>这里的故事你是否还记得</p>
<p>你曾认为会永远陪在你身边的人，会因为各种各样甚至你想都想不到的原因离开。相比之下，人生这条艰难路上，婚姻伴侣确实是你最坚定也是最稳定的同行者。</p>
<p>所以，如果人生艰难，你选择独身，只身向前的准备，你做好了吗？</p>
<h4 id="价值代价"><a href="#价值代价" class="headerlink" title="价值代价"></a>价值代价</h4><p>“价值代价”这个名字，起得可能不太准确，但确实找不到更好的词。什么意思呢？就是我们每一天都在追求人生价值，到最后，无非是为了“没有白来这个人世间走一遭。”</p>
<p>皮克斯在 17 年有部片子叫《寻梦环游记》，我朋友四岁的小孩看得嚎啕大哭。或许这是他第一次直观地感受到了死亡的恐惧。</p>
<p>人的一生，要死去三次。第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡；第二次，当你下葬，人们穿着黑衣出席你的葬礼，他们宣告，你在这个社会上不复存在，你从人际关系网里消逝，你悄然离去；而第三次死亡，是这个世界上最后一个记得你的人，把你忘记，于是，你就真正地死去。整个宇宙都将不再和你有关。</p>
<p>不结婚而保持独身，最高价值层面的代价在于，你将失去一个最容易与这个世界建立羁绊的途径。立德立功立言，我们普通人啥也立不了，程序员倒是可以流传一套代码，被后人吐槽“祖传屎山”又不得不用。但是绝大多数情况下，选择独身，你会发现与这个世界的羁绊越来越少。</p>
<p>哲学最终极的思考是“存在”（出自知名哲学家沃兹基硕德）。</p>
<p>学没学过哲学的人都会有存在性焦虑，缓解这种焦虑的唯一办法，就是在一段关系中能被聆听、被重视、被回应。权力之所以让人陶醉，就是因为权力天然地将人摆在一段关系中的中心位置。而婚姻关系，也是让人真正存在于关系之中，而非简单处于一段关系中的绝佳选择。</p>
<p>所以，遇到真喜欢的人，也不妨松松土，试一试，还能减轻一点双方的存在性焦虑。</p>
<p>我每天熬夜写课程、回答问题、接受咨询，很多朋友常常时隔多年还在向我表示感谢。其实我做的非常有限，是朋友们的支持和鼓励，让我和这个世界建立了多元的联系，是你缓解了我的存在性焦虑，让我感到没有白来这个人世间走一遭。借此机会，向你说一声谢谢。</p>
<h3 id="到底独身否？"><a href="#到底独身否？" class="headerlink" title="到底独身否？"></a>到底独身否？</h3><hr>
<p>你可能会问了，老师，又是洗脑，又是代价的，我到底要不要继续独身？</p>
<p>无论你是选择结婚，还是选择独身，都应是出自内心真正的热爱，而不是大众的裹挟。幸福不是因畏惧风险而改变，也不是因无惧风险而坚持。幸福是明知风险，但为了心中所爱，坦然承受。</p>
<p>最后给坚持独身主义的朋友讲个故事。</p>
<p>从前，有只小熊喜欢一只小花喵，它采了一大捧玫瑰花送给小花喵，扎得满手是血。可是，小花喵死活不肯收，说自己和小熊不合适。小熊只好把玫瑰一朵朵地发给路上偶遇的小动物，也有小狸喵、小白喵很喜欢小熊，说你要是能给我一整束玫瑰，我们就在一起吧。</p>
<p>但是，小熊再也没有一整束玫瑰了。</p>
<p>我们知道，玫瑰其实一直都有，怕的是满手是血，却没人愿意收。所以，希望支撑你只身前行的，不仅仅是对伤口的恐惧，而是更多的价值思考。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>今天我们讨论的是独身主义，这是相对小众，也非常需要勇气的一种选择。</p>
<p>首先，我们对支持“结婚才是正确”的两个洗脑包进行了批判：</p>
<p>一种叫“什么时间干什么事”，实质上是前人们生活习惯塑造的传统经验；</p>
<p>另一种叫“找不到对象的是 loser”，实质上是盲目接受外部的文化输入。</p>
<p>无论是害怕成为异类，还是彰显自身价值，都不应该是支撑恋爱结婚的理由。我们唯一能接受的理由，应该是真爱。</p>
<p>其次，我们对独身主义要付出的代价进行了分析：</p>
<p>外部的代价包括经济代价与舆论代价；</p>
<p>内部代价包括情绪代价与价值代价。</p>
<p>希望你能够在充分想清楚要面对的困难以后，再决定是否坚持独身。</p>
<p>最后，我想说，理想的婚恋环境，应该是大家都真诚地对待婚恋，但不将其作为人生的全部。</p>
<p>虽然，我们高度认同婚恋幸福的价值，因为这需要能力、精力甚至一点运气，但我们同样认同事业、爱好、友情等一切美好事物的价值，并允许支持鼓励人们将其作为毕生追求。</p>
<p>这样，单身的人会得到幸福和尊重，而不是一个内卷、焦虑和党同伐异的丛林环境。</p>
<p>这需要我们共同努力，以此共勉。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>12 姐弟恋也很可爱：姐弟恋有什么好处和注意事项？</title>
    <url>/2022/11/25/love/12/</url>
    <content><![CDATA[<p>如果一个男人找比自己小很多的女人做妻子，舆论往往会去抨击这个女人；那么，如果一个女人找比自己小很多的男人做丈夫呢？是的，舆论还是会抨击这个女人。电视剧里，俞飞鸿这种女神搞姐弟恋，尚且要被骂不要脸，普通人谈姐弟恋的压力也就可想而知了。</p>
<p>但是，无论传统舆论对此有多不满，姐弟恋却还是成为了一种不可阻挡的趋势。</p>
<p>王菲和谢霆锋是姐弟恋、文章和马伊琍是姐弟恋、秦昊和伊能静也是姐弟恋，姐弟恋仿佛成了女明星的标配。但也不光明星，试问，又有哪个女生不想体验一下萧亚轩的快乐？</p>
<p>据统计显示，在 1990 年，男大女小的夫妻占 70%，男小女大占 13%；到 2010 年，男大女小的夫妻占 43%，男小女大占 40%。事实上，根本无需统计数据，随着经济社会发展，女性经济社会地位不断提高，姐弟恋的趋势是一种必然，甚至可以算是对男大女小占比过大的拨乱反正。</p>
<p>既然一件事情能从偶然走向必然，从单发变为趋势，我们就有研究的必要。同时，也是应许多朋友的要求，特别是本课程责任编辑小奶酪的要求，今天我们就来讲一讲姐弟恋的话题。</p>
<span id="more"></span>

<h3 id="姐弟恋模式好处多多"><a href="#姐弟恋模式好处多多" class="headerlink" title="姐弟恋模式好处多多"></a>姐弟恋模式好处多多</h3><hr>
<p>首先，我们来给“姐弟恋”下个定义。你可能会说，什么？姐弟恋还要下定义？</p>
<p>对的，因为从狭义上说，只要女生年龄比男生大就叫姐弟恋。一般来讲，女生比男生大三岁以上才会显著呈现姐弟恋模式。很多女生比男生大一两个月的、一两岁的，可以统一处理为同龄人。</p>
<p>但在我的经验里，这种狭义的说法并不准确。如果女生生理年龄小于男生，但实际心理年龄却大于男生，换句话说，女生要比男生成熟得多，这其实也属于姐弟恋模式的恋情。</p>
<p>总的来说，无论男女生理年龄差有多少，必须心理上处于姐弟恋状态才能叫姐弟恋。</p>
<p>所以，即便你恰好处于男大女小的恋爱组合，又或者你也不准备进入姐弟恋，但这一讲，你也有看一看的必要。毕竟 ，经营爱情这个事，海纳百川有容乃大，它山之石可以攻玉。</p>
<p>分析完了姐弟恋的定义后，我们来看看它有哪些特点。相较于传统男大女小的恋情（叫兄妹恋有点怪怪的，以下简称传统模式），姐弟恋存在以下特点：</p>
<h4 id="第一，生理年龄差异"><a href="#第一，生理年龄差异" class="headerlink" title="第一，生理年龄差异"></a>第一，生理年龄差异</h4><p>这或许是姐弟恋最直观的差异，有很多人将其视为姐弟恋的难点之一。</p>
<p>但请你把关于年龄的刻板印象抛诸脑后，舆论压力、相处模式、生活差异其实都不是年龄差必然带来的问题。如果我们仅就生理年龄讨论生理年龄的话，姐弟恋其实是个优势。</p>
<p>男女在生理上存在差异，所以，男生女生的生理需求峰值是有所错位的。通常来说，女生活力最旺盛的年龄段是要晚于男生的。因此，姐弟恋相比传统模式，更容易在这方面达到适配。</p>
<p>比如说，在《鹿鼎记》里，神龙教教主夫人苏荃这个大美女嫁给了大自己很多的洪安通，却最终叛出神龙教，跟了小自己很多的韦小宝，除了形势所迫之外，很大程度和韦小宝恰好处于胡天胡地的年纪有关。联想到后来，韦爵爷一家在通吃岛住了那么久，孤男七女在岛上也没啥其他娱乐活动，老韦家未添一丁半口，如果是这个状态的小宝弟弟，恐怕就难以拿下苏荃姐姐了。</p>
<p>其次，从人口统计学来看，女性的平均寿命是要高于男性的。所以，从统计意义上讲，姐弟恋共同陪伴的时间也会长一点，不容易出现女方晚年长期处于丧偶状态的局面。</p>
<h4 id="第二，情绪供需差异"><a href="#第二，情绪供需差异" class="headerlink" title="第二，情绪供需差异"></a>第二，情绪供需差异</h4><p>姐弟恋模式最核心的定义，就是女方才是亲密关系中的情绪价值供给的主导者。</p>
<p>这里要敲黑板了！</p>
<p>这里引出一个非常关键的概念——情绪价值。情绪价值定义一套一套的，你只需要知道，它就是情绪收益与情绪成本之差。用大白话讲，就是跟你在一起，开心与难过的差值，就是情绪价值。</p>
<p>不单单是在情侣之间，我们在日常交往中，也一定会注意到，有些人就是具备高情绪价值，跟这种人在一起，就是会感觉特别舒服，你有啥好事都愿意跟他一块。但是，也有些人就是低情绪价值，他整天怨天尤人，杞人忧天，负能量爆棚，你一看见就避之不及。</p>
<p>说到这，就要讲一下如何才能提供情绪价值，最底层的就是要情绪稳定。</p>
<p>如果像炮仗一样一点就着，甚至像吃了枪药一样不点就着。别人说一句，你说三句，那你就是情绪价值的索取者和消耗者。能够保持自身情绪稳定，不受环境和对方影响，本身就是一种价值。</p>
<p>给你举个例子，《资治通鉴》里有描绘东晋淝水之战的文字，仗怎么打的记录甚是粗糙，整个过程甚至也有点玄幻。但是里面却特别详细地记录了东晋大佬谢安啥事不干，一个会都没开，到处郊游下棋，最后谢安听说打了胜仗，还轻飘飘地来了一句，“自有小字辈破贼”。</p>
<p>论卖弄和显摆，魏晋士人堪称史上第一高峰，但谢安这个作秀，绝对魏晋第一。</p>
<p>小时候不理解，谢安这种啥事不干的人，怎么成了淝水之战的代表人物？下面正儿八经打仗的谢玄反倒成了跟班。现在才知道，八十万敌军压境，己方就那么几万人，全国上下惶惶不可终日，一个能够保持情绪稳定的当事人是多么可贵，他是在以一人之力向满朝公卿提供情绪价值。</p>
<p>提供情绪价值，再高级一点的就是消解对方负面情绪，俗称“哄人开心”。在对方焦虑、紧张、害怕、愤怒、忧郁时，能够帮助对方走出负面情绪的泥潭，尽量不让对方消耗自身情绪价值。</p>
<p>著名人民艺术家范伟老师演过一部电影，陈数女神在里面饰演他的妻子。两个人有一次吵架，陈数情绪爆炸，吼范伟说，“你倒是说话啊！”范伟异常平静地对陈数说，“实在不好意思，吵架时候，你也美的不可方物，让我不忍打断。”简直太会了，我都要为他鼓掌。</p>
<p>提供情绪价值，最高级的是带动对方情绪。消解对方负面情绪，终归还是会有所损耗，真正的高手是把正面情绪传染给对方，最终生成更多正面情绪，实现正和博弈。</p>
<p>虽然这些年正能量这个词都要被玩坏了，但正能量爆棚的小太阳，确实是恋爱中的一个宝藏。</p>
<p>说回到姐弟恋的话题，在传统模式中，男方是情绪价值的主要提供者，或主动、或被动地要负责哄女孩子开心。姐弟恋模式则相反，女方会成为情绪价值的主要提供者。所以，即便有时女方生理年龄要小于男方，但如果女方更加成熟，情绪更加稳定，其实也可以称之为姐弟恋模式。</p>
<p>在恋爱里，男生本身的情绪需求和消耗就要小于女生，再加上姐弟恋中的女生更为成熟，对情绪价值的消耗与索取也比传统模式中的女生更少。总体来看，这或许也算姐弟恋的一个优点。</p>
<h4 id="第三，价值匹配差异"><a href="#第三，价值匹配差异" class="headerlink" title="第三，价值匹配差异"></a>第三，价值匹配差异</h4><p>相比传统模式，姐弟恋在价值匹配上也有所不同。</p>
<p>对于男方来说，姐姐更加成熟有女人味，经济相对更加独立，处事更加老练，对待感情也更加主动。对于女方来说，弟弟更加纯情，对感情更真挚热烈，激情更充沛，新鲜感更足。</p>
<p>当然，不同的人的价值需求可能不同。可能有的男生不喜欢成熟的，就喜欢萝莉型的妹子；有的女生也不喜欢纯情小男生，就喜欢成熟大叔。所以，这个优点各花入各眼，看个人偏好了。</p>
<p>现在，我们已经分析完了姐弟恋模式的三个主要特点。知道这些特点，有什么用呢？</p>
<p>第一，相信你也发现了，这三点不光是姐弟恋的特点，也是姐弟恋的优点。如果这三个优点有符合你心意的，或者是可以填补你的价值需求的，那么你就可以去尝试一下这种恋爱模式。</p>
<p>第二，也是我们接下来要讲的，正如一切有机遇的事情，就一定也会给你带来不小的挑战，姐弟恋也是如此。特点就像一把双刃剑，在给我们带来优点的同时，也暗中标好了价格。</p>
<h3 id="姐弟恋模式难处不少"><a href="#姐弟恋模式难处不少" class="headerlink" title="姐弟恋模式难处不少"></a>姐弟恋模式难处不少</h3><hr>
<h4 id="第一，年龄焦虑"><a href="#第一，年龄焦虑" class="headerlink" title="第一，年龄焦虑"></a>第一，年龄焦虑</h4><p>在前面我们提到，姐弟恋的年龄差异相对于传统模式是个优势，但这个优势只是生理上的。在心理上，它却特别有可能给你带来一种副作用——年龄焦虑。</p>
<p>我们都知道，两个人要是想结婚，需要做好物质上的准备、心理上的准备。可是，现在社会压力越来越大，在没有特别强力家庭支持的情况下，这些准备所需要的时间在延长。</p>
<p>体现在统计数据上，就是晚婚比例越来越高，结婚年龄越来越大。</p>
<p>2020 年，中国平均结婚年龄已经达到 27 岁，部分一线城市初婚的平均年龄已经超过 30 岁。按照这个数据考虑，姐弟恋中女方大男方 3 ~ 5 岁的话，男生 30 岁的时候，女方已经 33~35 了。</p>
<p>随之而来的，就会引发出两个心理问题。一个是二十来岁开始谈恋爱的话，两个人很可能要经历一场长达多年的爱情长跑，才能走进确定性更强的婚姻关系。另一个是女方风险成本过高，自己强势期的时候，让线让野保射手，射手发育完六神装出山，搞不好还要嫌弃自己后期不给力。</p>
<p>所以，无论是爱情马拉松对时间的考验，还是风险厌恶对人性的考验，都可能会给一段姐弟恋关系注入更多的焦虑和不安情绪，而这些消极情绪往往会成为两个人关系终结的导火索。</p>
<p>只有两种“良药”能与之对抗，一种是坚定，另一种是勇气。</p>
<h4 id="第二，能力焦虑"><a href="#第二，能力焦虑" class="headerlink" title="第二，能力焦虑"></a>第二，能力焦虑</h4><p>这种能力焦虑的情况，多见于一方还在上学，另一方已经工作。</p>
<p>所有走出学校的人都应该有过这种体会，就是经受过社会毒打后，会发现学生思维有很多幼稚之处。所以，一个学生和一个打工人，势必在很多现实问题上，存在认知的鸿沟。</p>
<p>实际上，在传统模式中，这样的认知差异也存在。</p>
<p>之前有新闻说一个 IT 企业的高管，娶了一个貌美如花又特别年轻的老婆。但是他老婆比较幼稚，居然模仿喜洋洋与灰太狼里面的红太狼，用平底锅重击该高管后脑勺，将其打成植物人……</p>
<p>但是，毕竟在传统观念中，男强女弱实属正常。社会的普遍共识就是，男方就应该比女方成熟一点、办事老道一些、能力强一些，而对于能力不足的女方，周围的人也更加宽容。</p>
<p>姐弟恋恰恰相反，女方凭借大几岁的先发优势，会在亲密关系中成为更强的一方。</p>
<p>这带来的的心理问题在于，男生可能会有挫败感，会因为丧失对两人关系的掌控权和主导权，开始感到焦虑；女方也会焦虑于男方的成长速度，特别是在对比周边成熟大叔的时候。</p>
<p>不过，这种能力焦虑会慢慢缓解。当双方都工作一段时间后，这种能力差就不太显著了。这也侧面说明了，20+ 的人谈姐弟恋和 30+ 的人谈姐弟恋，难度系数不在一个水平线上。</p>
<h4 id="第三，从众焦虑"><a href="#第三，从众焦虑" class="headerlink" title="第三，从众焦虑"></a>第三，从众焦虑</h4><p>虽然我们说，姐弟恋越来越多，但那是纵向比，横向比还是少。至少在观念上，我们很多人还是认为传统模式是多数，姐弟恋是少数。所以，这也导致了最大的焦虑——和多数人的不一样。</p>
<p>因为，和别人不一样这件事，本身就会带来焦虑。</p>
<p>人是社会化的人，从众心理是千百年来进化出的本能，是文化、教育甚至 DNA 共同塑造的。有个著名的心理学实验，安排了一群托面对电梯门站。不知情的测试者进入电梯，也会面对电梯门站立；一群托全部背对电梯门站，测试者进入，也会下意识背对电梯门站立，这就是群体压力。</p>
<p>这种从众焦虑的最大危害倒是不至于让你主动选择放弃姐弟恋以随大流，一般现代社会的人还是有这点抵抗力的。它最大的危害在于，每当你们发生矛盾和摩擦的时候，你们都可能会不自觉地归因，会认为矛盾发生是因为你们是和别人不一样的姐弟恋，而忽略了矛盾本身。</p>
<p>聚集成群的人，他们的感情和思想全都采取同一个方向，他们自觉的个性消失了。</p>
<p>——《乌合之众》</p>
<p>这样错误的归因，常常会导致更加错误的后果，破坏力非常大。</p>
<p>你也能看出来，姐弟恋的三点难处全部都有关于焦虑。世人皆认为，姐弟恋最难的是外部的阻力，是经济状况的悬殊、是家人的不同意和不支持、是舆论的指指点点等。</p>
<p>相比于内心的不确定和煎熬，外部阻力反而微不足道，击垮一个人的往往都是内部的矛盾。</p>
<p>但是，有年龄差异就一定会焦虑吗，女强男弱就一定会焦虑吗，和大家不一样就一定会焦虑吗？</p>
<p>不是风动，也不是幡动，是心动。</p>
<p>心生万相，万相皆空。姐弟恋也好，兄妹恋也好，都是虚妄。其实，这一切的背后，不过只有你们两个人而已。人对了，年龄不是问题，人不对，什么恋都是问题。</p>
<h3 id="姐弟恋的注意事项"><a href="#姐弟恋的注意事项" class="headerlink" title="姐弟恋的注意事项"></a>姐弟恋的注意事项</h3><hr>
<p>说着说着，似乎进入了看破红尘的境界，但最后，还是要说说姐弟恋的注意事项。</p>
<p>第一，正确对待他人意见。</p>
<p>姐弟恋经常遭到很多家人朋友的反对，但你一定要知道，人家反对的究竟是什么。拿上台面说的是嫌弃弟弟年纪小，实质上是不是在担心弟弟的经济能力，还是担心弟弟会始乱终弃。</p>
<p>你要做的就是，针对性地拿出有说服力的现实条件和未来承诺，去解决真正的问题。两个人不能一味地纠结于年龄大小，年龄又不能控制，总不能塞回肚子里重生一回。</p>
<p>第二，正确对待双方关系。</p>
<p>在姐弟恋的关系里，女方要做乘风破浪的姐姐，不要做唠唠叨叨的老妈子，还要学会抓住机会，偶尔地做一下弱不禁风的林妹妹；男方该示弱示弱，该撒娇撒娇，不要有太重的心理包袱，但是该爷们的时候也要爷们，该有担当的时候也不要逃避，要学会多主动去掌控两人的关系。</p>
<p>诚然，姐弟恋要比传统的恋爱模式更让人费心一点，可能需要两个人付出更多的坚持和勇气。但是，这世间的每一件事都如此，走过的荆棘和沼泽越多，美好的风景才会弥足珍贵。</p>
<p>最后，要记住，没有什么不靠谱，你们决定在一起，只是因为你们相爱而已。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>俗话说，女大三，抱金砖。</p>
<p>今天，我们就姐弟恋这个话题进行了探讨。如今，姐弟恋已经成为了一种趋势。但是，姐弟恋不仅仅是指生理年龄上女方大过男方，更是指一种女方相较男方，心理上更为成熟的恋爱模式。</p>
<p>姐弟恋这种模式有三大特点，分别是生理年龄差异、情绪供需差异和价值匹配差异。</p>
<p>其中，我们特别讲解了情绪价值这个概念。情绪价值是人际关系中最为重要的影响因素之一，稳定的情绪控制、消解负面情绪和带动正面情绪是提供情绪价值的三重境界。</p>
<p>但是，这三种差异除了给这种模式带来一定的好处之外，同时也埋下了隐患，带来了难处。</p>
<p>难处就在于年龄焦虑，能力焦虑和从众焦虑，三者都是由于姐弟恋这个概念，所产生的一种心魔，属于自寻烦恼。越是在意姐弟恋这个概念，就越容易因此受伤。</p>
<p>最后，我想说，合适的人，年龄不是问题；不合适的人，什么都是问题。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>13 千古难题真难办：如何跨越家庭背景的差异？</title>
    <url>/2022/11/25/love/13/</url>
    <content><![CDATA[<p>有一种说法，叫恋爱是两个人的事，婚姻是两个家庭的事。从谈恋爱修成正果到走入婚姻殿堂，需要跨越的阻碍有很多，但其中挑战最大、最困难的，莫过于跨越家庭背景的差异。</p>
<p>女生向的电影电视剧最爱拍的模式，就是霸道总裁爱上平民女孩，这模式在几百年前就有了——《格林童话》里面的灰姑娘嘛；男生向的电影电视剧最爱拍的模式，就是富家千金爱上落魄男孩，这模式在几百年前也有了——《聊斋》里面的狐妖勾引赶考书生嘛。</p>
<p>为什么童话和小说都喜欢编这种跨越家庭背景的爱情呢？的确是因为，这些在现实生活中也不多见，缺啥编啥，大家伙都爱看。由此可见，家庭背景的差异确实是一道千古难题。</p>
<p>近年来，关于凤凰男、扶弟魔之类的话题也总是霸占各大网站婚恋话题榜首，出一个爆一个，也从另一个侧面说明了，家庭背景差异这个话题确实给很多人造成了困扰，能够引发大家共鸣。</p>
<p>所以，关于家庭背景差异的话题，今天我们也来进行一个探讨。</p>
<span id="more"></span>

<h3 id="有哪些家庭背景差异？"><a href="#有哪些家庭背景差异？" class="headerlink" title="有哪些家庭背景差异？"></a>有哪些家庭背景差异？</h3><hr>
<p>在这个话题下，很多人经常会产生激烈的观点碰撞。但是，在我的经验中，其实为数不少的争论，都是因为对家庭背景的定义错位而出现的。所以，我们先对家庭背景差异做个说明。</p>
<p>纵观所有的家庭背景差异，都可以归结为以下三类。</p>
<h4 id="1-经济条件的差异"><a href="#1-经济条件的差异" class="headerlink" title="1. 经济条件的差异"></a>1. 经济条件的差异</h4><p>在众多的差异中，经济条件的差异是最直接的家庭背景差异。</p>
<p>当然，经济条件不仅仅指家庭存款，而是泛指双方调动资源的能力。比如说，政府官员、国企高管在家庭资产数量上，可能比不上私营企业老板。但只要私营企业没有大到一方首富的级别，一般在家庭背景上也没有什么差距，甚至官员家庭还高于同级别的企业家庭。</p>
<p>所以，我们说，经济条件的差异程度要足够大，才算得上是家庭背景的差异。</p>
<p>否则你好比，双方家庭都是高资产净值家庭，诸如一线城市拆迁户、内陆地区煤老板、沿海做实业和金融新贵。虽然他们内部也存在鄙视链，但不在我们今天的讨论范围之内。</p>
<p>同样，如果父母都是工薪阶层，一个在上海两套房，一个在上海三套房，资产可能差了几百万，但如果有人非要问怎么跨越这个家庭背景差异，是不是就有点矫情了。</p>
<h4 id="2-思维观念的差异"><a href="#2-思维观念的差异" class="headerlink" title="2. 思维观念的差异"></a>2. 思维观念的差异</h4><p>由经济条件差异衍生的，最直接的就是消费观的差异。不同家庭对钱的态度是迥然不同的。</p>
<p>当初，我上学的时候，老师请我们去酒店吃自助。工科男生的吃法，你应该也能想象，对着各种海鲜，就是一顿胡吃海塞。但是，唯有一个哥们就简单吃了点菜，吃了盘意面就停筷了。</p>
<p>这我当时完全不能理解，二百多块钱的自助，你居然还吃意面，简直脑子不好使。后来我才明白，对有些人来说，酒店自助太普通了，犯不着为了吃回本撑坏自己。</p>
<p>所谓的消费观，就是对花一笔钱到底值不值的判断。</p>
<p>同样花两百块吃顿饭，富裕家庭可能觉得开心就好，困难家庭可能就觉得不可理解，就产生了差异。差不多经济条件的家庭也可能在消费观上产生巨大差异，有的人愿意花钱买别墅，但不愿意花钱买服务请人打扫；有的人愿意买很多名包、名表，但觉得吃东西简单一点就好。</p>
<p>所以，对于思维观念上的差异，我们要以能否兼容为标准。因为很多情况下，思维观念不是一下子就能改变的，差异的确很难消除，但是如果双方可以各退一步，尝试兼容，会少很多矛盾。</p>
<p>除了消费观之外，还包括方方面面。比如谈恋爱，有的家庭觉得中学生谈恋爱简直天理难容，你要敢越雷池一步，腿都给你打折；有的家庭觉得只要不影响学习就好，甚至以此还会揶揄自家孩子，“我孩子长这么帅，为什么都没人给你写情书呢？”</p>
<h4 id="3-生活习惯的差异"><a href="#3-生活习惯的差异" class="headerlink" title="3. 生活习惯的差异"></a>3. 生活习惯的差异</h4><p>最后，还有生活习惯的差异，这个差异很少人提，但又不得不提。</p>
<p>毕竟，很多事上升不到思维观念这个程度，但隔阂又确实存在。比如说，南方女婿请北方丈母娘吃饭的著名故事，南方习惯是先喝汤再吃饭，而北方习惯先吃饭再喝汤。这个差异就导致了丈母娘对头道菜端个汤出来很不满，“咋地，这是要先给我灌个水饱啊？”</p>
<p>每个人特有的生活习惯之多、之顽固，不结婚的人是很难体验出来的。这些习惯是家庭从小到大一点一滴灌入进你生活的，从牙膏到底能不能从中间挤到炒菜到底要不要放辣椒，这些事情没法拿上台面争论个一二，却又无处不在。就像牙疼要不了命，但难受起来真要命。</p>
<h3 id="家庭背景差异重要吗？"><a href="#家庭背景差异重要吗？" class="headerlink" title="家庭背景差异重要吗？"></a>家庭背景差异重要吗？</h3><hr>
<p>也许你会问了，家庭差异真的有那么重要吗？谈恋爱、结婚真的要考虑家庭背景吗？</p>
<p>我知道，很多人都想听到否定的答案，想听到类似真爱至上的词语。可惜我不能这样，因为我认为，家庭背景是重要的，但又不是你想的那个重要法。</p>
<h4 id="1-家庭背景是天然的筛选器"><a href="#1-家庭背景是天然的筛选器" class="headerlink" title="1. 家庭背景是天然的筛选器"></a>1. 家庭背景是天然的筛选器</h4><p>当今社会，即便再现实的人，也很难理直气壮地宣扬，家庭经济条件有差异的情侣不能结婚。</p>
<p>事实上，穷小子娶富家女或是富二代娶平民姑娘的事情简直不要太多。甚至，有不少家庭资产过亿的人家紧紧地盯着科研单位的新入职博士，只要女儿喜欢，家里再穷的也愿意嫁。</p>
<p>所以，支持家境悬殊的人不能谈恋爱的，多半论证思路是：家境悬殊非常容易造成三观不合，三观不合就会在大量问题上产生矛盾，从小到大养成的价值观很难改变，最终导致两个人分手。</p>
<p>从概率上讲，这个观点是有一定道理的。</p>
<p>三观问题是很难通过一两次短暂接触就观察清楚的，家庭教育确实对三观形成存在重大影响。所以，以家庭背景作为筛选器，确实不失为一个快速又相对精确识别潜在恋爱对象的好方法。</p>
<p>比如说，如果你自我边界意识很强，对个人小家和原生家庭的界限非常介意。那么，在时间有限的情况下，你就要谨慎选择所谓的“凤凰男 &#x2F; 女”，两个人的很多想法会存在很大的不同。</p>
<p>你很难感同身受地体会到举家之力供养出来的大学生，Ta 们身上背负着多大的责任感，甚至是负罪感。他们也很难不委屈自己，宁肯自己吃糠咽菜，也要为原生家庭输血。</p>
<p>但是，这个方法又没很多人说得那么重要。在我们没有明确目标的时候，挑选恋爱对象肯定会有个条条框框的，不然一个个试太盲目。这个时候，家庭背景就是一个很好的框子。</p>
<p>可是，假设你已经有了一个恋爱对象，谈了一段时间准备进入婚姻了。</p>
<p>这个时候，你还要靠拍脑袋想出来的框子去框人，未免对自己的眼光也太不自信了。在过去的那段时间里，恋爱是都白谈了吗？从统计学上讲，条件概率是不知道样本全貌情况下的权宜之计，你都知道袋子里一共六红四白十个球了，还要啥贝叶斯呀。</p>
<h4 id="2-家庭背景是重要的价值构成"><a href="#2-家庭背景是重要的价值构成" class="headerlink" title="2. 家庭背景是重要的价值构成"></a>2. 家庭背景是重要的价值构成</h4><p>很多家庭表示，婚姻要追求门当户对，这无可厚非。但是，倘若把家庭背景作为唯一的条件来衡量，那是犯了一元论的毛病。除非家里有王位要继承，个人能力相对于王位无足轻重，所以只看门户不论其他。除此之外，我实在想不到非要只追求门当户对的意义。</p>
<p>但是，这并不代表家庭背景不重要，相反，家庭背景是婚恋中价值匹配中的重要一极。</p>
<p>在去年热播的《大江大河》里，主人公宋运辉就是出身农村的贫家子弟，他娶的程开颜是所在单位副厂长的女儿。论家庭背景，宋运辉差了一大截，但颜值高、学历高、能力高，个人综合素质和发展前景是碾压程开颜的。两个人为什么最终可以走到一起？</p>
<p>你说，程开颜的家庭背景是不是起到了很大作用？可以说是支撑双方价值匹配的重要因素。</p>
<p>如果两个人的个人条件大致差不多，家庭背景更为优越显然是一个极大的加分项。又或者一方家庭条件比较富足，特别是女方更多见，会愿意选一个家庭条件一般但个人综合能力非常强的。</p>
<p>两个人前期靠女方家庭积累，生活不愁；后期靠男方成长，独自 carry。这种事在体制内尤为多见，电视剧看得多，你也能发现，天朝自古以来就有榜下捉婿的传统。</p>
<p>当然，我们也多次说过，不同的人有不同的价值需求，甚至相同的人在不同时期，也会有不同的价值需求。比如，女生在交往过个人条件优越但家庭条件一般的男生之后，因为受不了迁就对方的生活标准而分手，可能就会把家庭背景作为下一任的重要考量。</p>
<h4 id="3-物质条件终究是一道坎"><a href="#3-物质条件终究是一道坎" class="headerlink" title="3. 物质条件终究是一道坎"></a>3. 物质条件终究是一道坎</h4><p>很抱歉，犹豫再三，还是写下了这句政治不太正确的话。</p>
<p>作为一个讲恋爱课的，我个人当然觉得爱情是神圣又伟大的。但如果对历史有所了解的话，你会发现，爱情并不是自古以来就如此伟大的。古代的婚配就是讲门当户对，讲血统阶级的。爱情被提高到神圣伟大的位置，那是文艺复兴期间作为人性光辉，用来对抗神性的。</p>
<p>无数艺术家歌颂爱情，只是迫于宗教势力强大，不好在明面上挖墙脚，所以打着爱情伟大神圣的幌子，行解放人性之实。而到了现代，歌颂爱情的主力也变成了消费主义的洗脑包。毕竟，“爱她，就给她买 xxx”的广告语都出来了，还能不疯狂宣传爱这个大前提吗？</p>
<p>所以，在这一讲，我也不得不如此“残忍”地跟你说，爱情固然神圣，但实际上没有我们想象得那么神圣，物质条件终究是一道坎，不考虑它是自欺欺人的。虽然我也很想讲，物质条件会导致三观差异 balabala，但很多时候，横亘在两个人面前的，就是物资条件本身。</p>
<p>如果你为了爱情，能够对抗物质的诱惑，甘于为了爱人降低生活标准，那么你非常棒；</p>
<p>但是，如果你迫于物质压力，选择了一个你相对没那么爱的人，我想说的是，你也没有任何错，不要自责，这是大环境决定和影响的。而且，爱情还是可以经营和培养的。</p>
<p>所以，综上所述，家庭背景差异很重要，但并不是最重要的。即使我说它不是最重要的，你也认为它不是最重要的，可是，你可能还是会受到家庭背景差异的影响，甚至是打压。</p>
<p>那么，怎么办呢？有没有什么方法可以尽可能地让我们跨越这个差异，坚持一下真爱至上呢？</p>
<h3 id="如何跨越家庭背景差异？"><a href="#如何跨越家庭背景差异？" class="headerlink" title="如何跨越家庭背景差异？"></a>如何跨越家庭背景差异？</h3><hr>
<h4 id="1-如何搞定父母"><a href="#1-如何搞定父母" class="headerlink" title="1. 如何搞定父母"></a>1. 如何搞定父母</h4><p>绝大多数人第一次意识到家庭背景所带来的鸿沟，就是在双方父母那里。</p>
<p>当然，我们说了，也不排除有开明的父母，认为只要小孩喜欢，人品没问题就全部 ok；但也有不少父母，害怕阶层跌落，坚决反对自家孩子“下嫁”的。改变对方父母的态度无非是三招：</p>
<p>第一招，就是拖，不要正面刚，要和对象继续谈。</p>
<p>一般来说，没有什么原则问题，父母强烈反对个一年半载，看到小孩还在继续坚持谈，态度怎么的也会软化一点，但是要提醒一句，在这个过程中，千万不要因此事发生正面冲突。有的人自尊心特强，看对方父母夹枪带棒的，就忍不住要怼回去，甚至还要发对象脾气。</p>
<p>这种行为无异于卖队友。要知道，夹在你和对方父母之间最为难受的人，就是你的对象。你怼人家父母的每一句话，都会十倍压力地反馈在你对象身上。所以，我们要学会控制情绪。</p>
<p>第二招，就是补，抓紧自我提升。</p>
<p>很多时候，对方家长也不是在意你的奋斗结果，毕竟这年头想在北上广买套房，光靠个人奋斗也挺难的。但是人家会在意你的奋斗态度，无论你是学历提升还是职务提升，要给人一个希望。</p>
<p>曾经就有一个妹子问我，她是单亲家庭，男朋友是自己的研究生同学，但男朋友是一线城市土著，有多套房产。男朋友妈妈不同意两个人在一起，可是男朋友却一直坚持，最后闹到了男朋友妈妈断了男朋友生活费的地步，要做房产公证，坚决要求两人分手。</p>
<p>你猜这事怎么着？他们两个人先是拖了一年，最终的解决契机还是人家妹子拿到了美国医学院的博士 offer。妹子出国前，男方妈妈一反之前的态度，居然反过来催着两人领证。</p>
<p>所以说，你得证明自己是有实力的，而不是一味地闹，实力是表达诚意的最好证明。</p>
<p>第三招，就是抬，要善于抬人一手。</p>
<p>如果在对方父母和你发生摩擦冲突的时候，出现一个解决契机，我们就别死要面子不肯低头了。这个时候，千万不要中二附体，搞什么昨天你对我爱答不理，明天我让你高攀不起了。</p>
<p>得饶人处且饶人，抬人一手，主动服软。聪明人都知道，善于给人面子的一定有里子。</p>
<p>但是这三招的前提就是，你对象坚定地跟你站在一起。如果你对象面对家里的压力，开口是我妈说了，闭口是昨天有人给我介绍对象，那你还是赶紧主动走人吧，不要影响人家继承王位。</p>
<p>如果你是“那个对象”，你的对象是被你家人质疑的那个，你也可以通过以上三招，去帮助你的另一半。在这个过程中，也有助于让你更了解 Ta 是怎样的一个人，是不是值得。</p>
<h4 id="2-如何搞定对象"><a href="#2-如何搞定对象" class="headerlink" title="2. 如何搞定对象"></a>2. 如何搞定对象</h4><p>如果对象都搞不定，也就不存在这个问题了。但这又是非常重要的一点，其实就只有一句话，如果你是家庭条件相对较好的那一方，真的喜欢，就要更加坚定，在当下还要多迁就和体谅一点；</p>
<p>如果你是家庭条件相对较差的一方，一定要对人家好一点，不要把对方的迁就视作理所当然。</p>
<h4 id="3-如何搞定自己"><a href="#3-如何搞定自己" class="headerlink" title="3. 如何搞定自己"></a>3. 如何搞定自己</h4><p>相比于搞定外人，跨越家庭背景最大的难题，其实还是自己本身。如果你是条件好的那一方，一切都还好说；如果你是条件相对不好的那一方，你的确要面对很多困难与阻碍。</p>
<p>如何接受对方和自己从小养成的迥然不同的消费观念？如何承认对方为了自己被迫忍受消费降级的事实？如何包容对方无意中流露出来的优越感？如何克服出身给自己带来的自卑感？</p>
<p>外邪易辟，心魔难除。</p>
<p>伟光正如电视剧版《大江大河》里的宋运辉，面对家境优越的程开颜，他也有失态的时候。哪怕当上东海常务副厂长的他，还是会吼，你以为我有今天是靠你们程家的关系吗？</p>
<p>所以，根本还是在于自我修炼，内在世界越充盈，对外在世界的芥蒂才会越小。</p>
<p>为什么科研单位的博士群体容易成为榜下捉婿的首选目标？对于拓宽人类知识边界，攻克全人类知识盲区的科研人员来说，太容易产生内在满足感了，不会轻易因为家庭背景差异产生心魔。</p>
<p>见天地、见众生，见自己，如是而已。</p>
<h3 id="爱情锦囊"><a href="#爱情锦囊" class="headerlink" title="爱情锦囊"></a>爱情锦囊</h3><hr>
<p>今天，我们对婚恋中家庭背景这一因素进行了探讨，这是结婚要面对的一个难题，也是一个非常现实的问题。</p>
<p>首先，我们对家庭背景差异进行了定义，分别存在经济条件差异、思维观念差异和生活习惯差异。在程度上，我们也以兼容与否为标准，排除了一些虽然存在但没那么厉害的家庭背景差异。</p>
<p>其次，我们就到底要不要考虑家庭背景差异这个问题进行了讨论。虽然说，家庭背景差异是筛选婚恋对象的一个有力条件，但这个条件不应该成为成熟恋爱关系中的阻碍。家庭背景是婚恋价值匹配中的重要一极，但也不是唯一一极，我们不能不考虑，但更要综合考虑。</p>
<p>其中，我们还特别提到，把物质条件作为爱情中价值需求的最大因素来考虑，并没有错。按《天龙八部》里的话来说，就是有情皆孽，众生皆苦。</p>
<p>最后，关于怎样跨越家庭背景差异达成婚姻关系，我给你提供了三个方向，分别是搞定父母、搞定对象、搞定自己。搞定父母有三招，能拖要补还会抬；搞定对象，就是要学会换位思考。</p>
<p>最关键的也是最难的，就是搞定自己，你才是你自己最大的拯救者。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>春节加餐1 公主，快放开那只巨龙！</title>
    <url>/2022/11/25/love/14/</url>
    <content><![CDATA[<p>今天是大年初一，首先，要祝你新春快乐！</p>
<p>如果你有人陪伴，我祝你在新的一年，感情升温，沐浴爱河，爱情的学分与日俱增；如果你还在寻找，那么也祝你在新的一年里，遇到良人，收获一段专属的、甜甜的恋爱！</p>
<p>这一讲，我们把恋爱的“知识点”先放放，在这个特别的日子里，我给你说个有趣的故事。</p>
<span id="more"></span>

<p>过了年三十，公主就十八岁了，但是她非常不开心。</p>
<p>隔壁黄金国的公主都被巨龙抓走好几次了，去救她的王子都能排到二里地之外了。自己却连巨龙长啥样都没见过，更别提王子了。搞得每次公主聚会的时候，自己都被嘲笑。</p>
<p>因此，在这次年夜饭上，她鼓足了勇气大声说：</p>
<p>“尊敬的坦格利安之子，鸡腿与拉面之国的君主，勇敢、刚毅、仁慈、智慧的北境守护者，亲爱的父亲大人，能否满足您女儿被巨龙绑架的卑微愿望。”</p>
<p>她父亲愣了一下，然后哈哈大笑，“当然、当然，我美丽的女儿，我想你今天晚上要把自己打扮得更漂亮一点。这样，明天巨龙抓走你以后，全世界的王子都会为你发疯的。”</p>
<p>宴会结束，国王连忙召来了国师，问他“怎么样，你和周边那几只龙谈的如何？”</p>
<p>“尊敬的坦格利安之子，鸡腿与拉面之国的君主，勇敢、刚毅、仁慈、智慧的北境守护者，我的主人，我和他们都谈过，但是我们确实拿不出那么多黄金或钻石。”</p>
<p>“那该如何是好，我已经答应了公主，要巨龙明天来抓她。”</p>
<p>“大年初一抓公主是各个王国的传统，抢在这种热门档期，我们更请不起。不过……”</p>
<p>“不过怎么样？”</p>
<p>“如果请那只龙的话，或许还有希望。”</p>
<p>“哎”，国王长叹了一口气，“也只好这样了。”</p>
<p>第二天，公主穿上了自己最华丽的长裙，盛装打扮了一番后，她就开始在窗口焦急地看着远方的天空。她问身旁的侍女，“听说巨龙出现时，会有电闪雷鸣，喷出的火焰可以融化一切，你说我会被哪只巨龙抓走？是生命的缚誓者阿莱克斯塔萨，黑龙公主奥妮克希亚还是万物的终结者黑龙之王纳萨里奥？”</p>
<p>就在这时，响起了敲门声。侍女打开门，走进来一只身高一米多点的巨……那只龙。</p>
<p>那只龙打了个哈欠说，“公主准备好没有？差不多我们就走吧。话说大年初一上班太辛苦了，你们这些公主，为什么总喜欢选今天被抓？”</p>
<p>公主有点懵，难道巨龙不是从天而降，凶神恶煞地抓走我吗？为什么你说的好像我们要去郊外野游一样？那只龙皱了皱眉头，“公主殿下，你这城堡是有顶的，那么大的花岗岩石头，我怎么从天而降？不过，凶神恶煞倒是好办。”巨龙揉了揉脸，做出一副凶狠的样子，“嘿，小美人，乖乖跟本大爷走吧，你就是喊破嗓子，也不会有人来救你的！”</p>
<p>“陛下，陛下，大事不好，公主被巨龙抓走啦！”</p>
<p>国王一听，猛地一拍大腿，“它终于… 啊不是，它居然胆敢劫持公主，快和我一起去阻止它。”</p>
<p>整个城堡的大臣、骑士、侍女们都走上了街头，一起见证自己国家的公主第一次被巨龙抓走的历史性时刻。他们纷纷举起绣着家族徽章的旗帜，伴着激昂战鼓的旋律齐声高呼着：</p>
<p>“恶龙，快放下我们鸡腿国公主！”</p>
<p>更有大户人家，拿出了不少炮仗向空中扔去，炸出一股浓浓的硝烟味道。国王站在城堡最高处，看着这一切热泪盈眶，“锣鼓喧天、鞭炮齐鸣、红旗招展、人山人海，咱们王国也算是等到这一天了。”</p>
<p>公主一边大喊着“快来救救我”，一边小声说，“巨龙巨龙，劫持公主的时候不是一般都要喷火的吗？”巨龙的前爪很短，所以只能把脑袋歪到一边，然后用前爪挠了挠头，“喷火很消耗法力的，算了，我是个有职业精神的龙。”</p>
<p>它猛地朝地面冲了下去，掠过了一条街道，高度低到公主甚至和几个看热闹的市民击了掌。巨龙瞄准了路边一棵低矮的灌木，biu<del>biu</del>biu 连喷三个拳头大的火球，将其焚为灰烬。</p>
<p>巨龙完成了喷火的任务，带着公主扬长而去，临走前对着国王喊，“快点拿赎金来换你的女儿。”</p>
<p>终于来到了巨龙的巢穴，公主并没有看到传说中堆积如山的金币，而是几个不大的洞穴，地上铺着柔软的地毯，还有一个铺上了天鹅绒被子的大床。</p>
<p>“巨龙先生，我是第一次被绑架，没什么经验，请问我在这里应该做些什么？其他国家的公主给我讲述她们被抓的经历的时候，她们都没有提到这一段。”</p>
<p>“嗯，你随意吧。我也是第一次抓公主回来，没什么经验。以前别的龙总嘲笑我连公主是啥样都没有见过，好在这次你们家国王答应提供二十年的鸡腿让我来抓你。”</p>
<p>“二十年的鸡腿！我的天啊！你不会吃腻吗？我现在想到鸡腿都反胃。”</p>
<p>“怎么可能？鸡腿是这个世界上最好吃的东西。”</p>
<p>公主作为鸡腿国国王的掌上明珠，从小到大鸡腿吃得太多。她以为自己再也不会主动去吃鸡腿了。</p>
<p>但是，她错了。</p>
<p>巨龙喷出的火焰居然超过了王国所有灶头的火力，喷出的冰雾还可以给食材急速降温，喷出的毒液可以萃取出绝无仅有的香料。它每天变着法做椒麻鸡、口水鸡、手撕鸡、葱油鸡以及只有他才能做出来的冰火毒龙照烧鸡，让公主吃的赞不绝口。</p>
<p>“你真的应该考虑一下做我们鸡腿国的镇国神兽！”</p>
<p>做人质的日子似乎还不错，唯一让公主忧心的就是，来救她的王子到底是什么样。</p>
<p>按照惯例，王子救了她，她就要和王子谈恋爱。</p>
<p>“巨龙先生，你说万一来的王子长得很丑怎么办？要是他睡觉打呼噜呢？他不爱洗澡呢？他不喜欢吃鸡腿怎么办？”</p>
<p>“公主陛下，童话都是这么编的，谁来救你都看缘分，现在烦也没用呀。总之，等王子出现，你和他幸福地生活在一起，我的任务就算完成啦！”</p>
<p>终于，公主担心的事情发生了。</p>
<p>隔壁国王的傻儿子带了一大票人跑到巨龙巢穴门口，大呼小叫让巨龙把公主交出来。巨龙按流程上去三拳两脚被王子打倒在地，王子还加了个钟，踩在巨龙身上，让随行的画师作画纪念。</p>
<p>公主心里一百个不愿意，眼泪在眼眶里打转，被王子一直拉着往外走，“美、美、美女，抓紧时间，打完这个小、小矮龙，咱们回去好好处。”</p>
<p>“等等！”</p>
<p>在场所有人的目光都聚焦到声音的来源处——趴在地上装死半天的巨龙那里。</p>
<p>“你说谁是小矮龙？谁小矮龙？你才矮，你们全家都矮！这生意没法做了，钱拿走，人留下。”</p>
<p>巨龙一把拽回了公主，面对蜂拥而上的侍卫，完美地展现了巨龙的尊严。在打折了十几把长枪大剑，喷出了熊熊烈焰之后，王子和他的随从们屁滚尿流地逃跑了。</p>
<p>巨龙想拍拍肩膀上的灰耍个帅，可惜前爪太短够不着只好作罢。</p>
<p>“公主陛下，对不起了，搅黄了你的王子对你的营救。”</p>
<p>公主紧紧地拥抱了巨龙，“巨龙先生谢谢你，你真是太棒了！”</p>
<p>于是，一人一龙达成协定。如果来的王子公主喜欢，公主就大喊“王子！王子！快来救救我吧！”如果来的王子公主不喜欢，就大喊“王子！王子！这条恶龙太强大了，千万不要为了我受伤！”巨龙根据公主的口号，决定到底是放水装死，还是把来人痛扁一顿。</p>
<p>可几个月过去了，来的王子一波又一波，公主从来没喊王子过来救她，总是让人不要受伤。</p>
<p>巨龙有点懵，“公主陛下，今天来的那个王子看着不错啊。”</p>
<p>“咦，他比麻杆还细，剑都举不起来，一看就很挑食。”</p>
<p>“那昨天那个王子呢，看上去很强壮啊”</p>
<p>“他总是抠鼻孔，好恶心。”</p>
<p>“那前天来的那个……”</p>
<p>“停，不想跟你说话了，笨蛋。”</p>
<p>“哦，哎，你还没说今天鸡腿想吃什么口味的呢。”</p>
<p>日子一天天这样过去，转眼又是一个大年初一。一个骑着白马的王子出现了，他高大威武、英俊潇洒、仪表堂堂、谦逊有礼，背后还带着七彩光环，这是男主角才有的待遇。</p>
<p>巨龙觉得这个王子肯定没得差了，扭头看公主。</p>
<p>结果公主还是大喊，“王子！王子！这条恶龙太强大了，千万不要为了我受伤呀”</p>
<p>王子微微一笑，“美丽的公主，感谢你的善良，但请不要为我担忧。”然后他对巨龙说，“听说你打跑了上百个王子，但今天还是请你务必不要为难我。”</p>
<p>他拍了拍腰间的宝剑，“因为，此剑出鞘，必要见血方还。”</p>
<p>巨龙看见王子强大的气场，感觉有些害怕。可根据之前与公主的约定，还是硬着头皮冲了上去。</p>
<p>可惜，王子一闪身就避开了巨龙的火球，一挥手就拨散了巨龙的霜息，剑不出鞘，临空虚劈就斩开了巨龙的毒液，把巨龙劈倒在地。</p>
<p>他略略躬身，对巨龙说，“作为巨龙，您已经做得很好了，请不要再进行无谓的挣扎。”然后他向公主行了一个骑士礼，“公主陛下，我们走吧，您自由了。我的国家有美丽的风景和美味的食物，不知我是否有幸能邀请您前去一游？”</p>
<p>公主却没有把手搭上去，而是摇了摇头，“不去”。</p>
<p>“嘿，这还有个喘气的呢，你当我不存在啊。”巨龙从地上爬起来，又一次冲向了王子。他知道魔法奈何不了王子，改成了近身肉搏。虽然一次次被打倒，但仗着龙鳞的坚硬，他并没受太重的伤，反而瞅准了机会，咬中了王子的小腿，一发力将其护腿的铠甲咬碎了。</p>
<p>王子发怒了，“孽畜，天堂有路你不走，地狱无门你闯进来！”，他终于从剑鞘中抽出了宝剑，剑光一闪，巨龙胸前裂开了一条口子，鲜血四溅。</p>
<p>巨龙感到了胸口的剧痛，体力正在急速地流失。面对王子劈下的剑，它做不出任何闪避的动作。</p>
<p>终于要结束了吗？这难道就是宿命？公主和王子幸福地生活在一起，恶龙被王子斩下了头颅。可王子的剑越落越慢，直到停住不动。公主不知何时已经半跪在了巨龙身前，双手虚拖，架住了这一剑。</p>
<p>“老娘说了不去，你听不懂人话吗？”</p>
<p>公主猛地抬起了头，一时之间风云变色，电闪雷鸣。她左手一挥，剑断；右手一挥，甲裂；正中一脚，将王子踢飞了十几米远。</p>
<p>“坦格利安之女，鸡腿与拉面之国的公主，北境守护者，不焚者丹妮莉丝，命令你立刻离开这里，永远不许回来。”</p>
<p>公主一回头，云销雨霁，彩彻区明。她手上凝起一片白光，洒在巨龙胸口，顿时止住了伤势。她扶起巨龙半躺在自己怀里，问它“没事了吧，还疼不疼呀？”</p>
<p>巨龙疑惑，“童话里公主都是和王子幸福地生活在一起，现在王子被你打跑了可怎么办啊？”</p>
<p>公主白了他一眼，“笨蛋，老娘想跟谁幸福地生活在一起就和谁一起，童话管得着么？”</p>
<p>仅以此文和各位小伙伴拜个年！</p>
<p>愿各位还在单身的朋友，过年回家能抓到属于自己的公主和巨龙。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>春节加餐2 恋爱课答疑集锦：人潮之中彼此相视而窃喜</title>
    <url>/2022/11/25/love/15/</url>
    <content><![CDATA[<p>今天是大年初四，假期已经过半了。不知道这一次回家过年的你，有没有被催恋爱、结婚？有没有为自己新的一年，想好一个恋爱目标？有没有什么恋爱计划？</p>
<p>恋爱课专栏已经上线更新一段时间了，每一天都能看到很多小伙伴在留言区留言。</p>
<p>有的人记录着自己对爱情的理解，写下自己的感悟；也有的同学留下自己在感情中的疑惑，迫切地想寻找到问题的答案；还有的同学给其他留言的小伙伴指点迷津，出谋划策。</p>
<p>总的来说，恋爱课的留言区很“热闹”，很“丰富”，也很“接地气”，也让我感触颇深。</p>
<p>虽然专栏每一讲的内容有限，但是我们专栏的留言内容成为了专栏最好的补充。于是，我将留言板中的答疑和精彩留言进行了一个汇总，帮助你更好地理解恋爱这门学问。</p>
<p>截至大年初一，基本做到了精选留言的一一回复，非常感谢小伙伴们的评论。</p>
<p>有许多非常精彩的洞见，这使看回复成为了一件非常开心的事情。我简单把回复分成四类分享一下，一是深有感触摘抄类；二是言简意赅金句类；三是皮一下很开心类；四是现实问题答疑类。</p>
<span id="more"></span>

<h3 id="一、深有感触摘抄类"><a href="#一、深有感触摘抄类" class="headerlink" title="一、深有感触摘抄类"></a>一、深有感触摘抄类</h3><hr>
<h5 id="秋水东行"><a href="#秋水东行" class="headerlink" title="秋水东行"></a>秋水东行</h5><p>看了几遍了，深有感触：要有恋爱目标，恋爱目标服从人生目标，服从目标要以我为主。</p>
<p>“贵以身为天下，若可寄天下，爱以身为天下，若可托天下”。不珍重自己，那有个好状态、好身体去办事儿；不珍重自己的人，谈何能够爱护珍重别人；不珍重自己，其他人其实也很难再珍重你的。所以，很多事儿，不仅仅是爱情，都得好好琢磨琢磨“贵以身”和“爱以身”了。就凭这句引用的话，这门课买值了。</p>
<h5 id="回复："><a href="#回复：" class="headerlink" title="回复："></a>回复：</h5><p>谢谢支持，看到您能点出这句话，真是非常开心，有种不白写的感觉，您是识货的行家！</p>
<h5 id="进化菌："><a href="#进化菌：" class="headerlink" title="进化菌："></a>进化菌：</h5><p>有启发！</p>
<p>不仅是相处久的恋人需要新鲜感，相处久的朋友、亲人也是需要的。</p>
<p>而且，感觉自己老实本分的天性更多，如果偶尔做些不确定、打破日常的小事情，应该会是比较有趣的吧？</p>
<h5 id="辰昊楠-Yami-的土豆宽粉"><a href="#辰昊楠-Yami-的土豆宽粉" class="headerlink" title="辰昊楠 -(Yami 的土豆宽粉)"></a>辰昊楠 -(Yami 的土豆宽粉)</h5><p>两个人在一起久了，原本一味的甜蜜难免也有些乏味，这个时候可以刻意营造新鲜感、刻意制造惊喜，比如改变以往常用的称呼。试着换换更有挑战的昵称来称呼彼此、带对方体验一些不可预知的生活方式等。</p>
<h5 id="郭梓良"><a href="#郭梓良" class="headerlink" title="郭梓良"></a>郭梓良</h5><p>有朋友遇到了第二种渣，偏执控渣。很好地应验了老师说的，表现出他希望的样子时，彬彬有礼，极致温柔；但一旦你违背了他的意愿，他就会向你疯狂输出负面情绪，直到最后被点醒才发现被 PUA 了。而且偏执控渣和全面依赖渣，确实是一体两面，因为女方的全面依赖，导致他们最后分手的时候，闹的非常难堪。二人多次分手，女方都以各种极端行为要求复合。一般人是真的顶不住</p>
<h5 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h5><p>非常认同且触动我的点：</p>
<p>我们不仅要学习如何去爱，还要学习如何享受被爱。以前，太重视如何去爱，忽略了如何享受被爱。在爱情中，爱与被爱是互动的，爱与被爱都是值得学习的能力。</p>
<p>爱与被爱，是一种可以习得的能力。知识和方法可以复制，能力可以通过训练得到，但是不可能速成。</p>
<p>恋爱，是技巧，那我们的目的是什么？用技术掩盖缺点？“恋爱技能就像太极剑，是让你掩盖破绽、化解矛盾，和自己，也和对方的缺陷达成和解的一种能力。” 我想，可能是用技巧化解恋爱中的矛盾吧。</p>
<p>恋爱就是自我成长。与 ta 相处的过程中，其实就是一场自我认识、自我和解的旅程。</p>
<h5 id="回复：-1"><a href="#回复：-1" class="headerlink" title="回复："></a>回复：</h5><p>谢谢认同，能够引起共鸣是创作者最大的荣耀和心愿，谢谢。</p>
<h5 id="孤鸿傲雪-Geek-79dd4b"><a href="#孤鸿傲雪-Geek-79dd4b" class="headerlink" title="孤鸿傲雪 Geek_79dd4b"></a>孤鸿傲雪 Geek_79dd4b</h5><p>“土味情话流”适用于那些已经进入恋爱关系的人的，都是老夫老妻拿来增添点生活乐趣的。</p>
<p>关系亲密程度，决定了有些话可以说，有些话不能说。随着关系越来越亲密，交谈局面的打开，可以讨论的话题（即打破的话题禁区）也越来越多。</p>
<p>而且关系的发展是循序渐进的，换句话说是连续的，不可能出现跳跃式发展，一上来就搞土味情话，不合适，还没有确定关系，就搞得好像很亲密，有不少妹子会觉得，这个人有病吧，然后就没有然后了。</p>
<p>有的男生不能对两个人关系有很好的把握，交往了一段时间，但是交情实际上还是比较浅的，或者说不是足够牢固到可以确定关系，这个时候突然搞土味情话也不是太合适。怎么说呢，一方面吸引力还不是足够的强，另一方面会让对方觉得猴急，不成熟，反而被筛选掉了。这种情况其实是比较可惜的，说句难听的就是到嘴的鸭子飞了。</p>
<p>用老师在文中的话讲，就是这些东西“是胜利的凯歌，不是冲锋的号角！”，这句话非常经典。</p>
<p>当然了，我不想给所谓的恋爱设置很多条条框框，这种话不能说那些话不能讲，如果恋爱的道路上一眼望过去，到处都是限制、障碍，人一下子就是失去动力，毕竟没有乐趣了，两个人都整天愁眉苦脸的，谈恋爱还有什么意义。</p>
<p>也就是说，土味情话，不是绝对不能说，不是能不能说的问题，而是什么时候说（时机、场合）、怎么说的（说的方式、态度，两个人的状态以及当时外部环境的契合程度等）的问题。另外对这些所谓指标的判断，也是相当程度上非常主观的，而能否做出准确判断，又与两个人的磨合（默契）程度有关。</p>
<p>从效果的角度来说，预估一下，所谓的土味情话说出来之后，对你们的关系是起到推动作用，你们关系会更进一步的发展，会变得更加的亲密，那么大胆说出来！</p>
<p>如果说之前，你自己心里都没底，不知道会有什么后果，说明你们的关系还是比较疏远的，或者很明显说了之后后果自负那种，很显然还是别说了，说了之后双方都会觉得不适。</p>
<p>总结一下就是，土味情话可以是说，但也不是乱说的，尤其要注意时机。时机不成熟，有些话就是不能说。一上来就说，不符合恋爱规律，注定要翻车！</p>
<h5 id="小呀么小二郎"><a href="#小呀么小二郎" class="headerlink" title="小呀么小二郎"></a>小呀么小二郎</h5><p>恋爱关系的核心在于信息交互。无比同意。</p>
<p>我觉得，在满足信息交互的前提下，明确表达出自己喜欢对方也是很有必要的。（不过这个可能是我自己的一种偏执或者说仪式感吧）</p>
<h5 id="回复：-2"><a href="#回复：-2" class="headerlink" title="回复："></a>回复：</h5><p>这不是偏执，你说的非常对，明确表达自己喜欢对方是非常必要的。只不过明确的表达未必就是表白，信息的载体非常多，行动上、情绪上、语言上我们有很多方法明确地表达这个信息。</p>
<h5 id="亚东"><a href="#亚东" class="headerlink" title="亚东"></a>亚东</h5><p>暧昧期最重要的就是一方面有节制地表达爱意（那种迷糊地表达，主要通过细节跟行动，切忌过头），另外一方面就是展示真实的自己。这样等时机合适就自然而然在一起了。</p>
<h5 id="回复：-3"><a href="#回复：-3" class="headerlink" title="回复："></a>回复：</h5><p>总结的非常对，就是最后一个字，时机合适不是等来的，其实也是双方共同创造的。</p>
<h3 id="二、言简意赅金句类："><a href="#二、言简意赅金句类：" class="headerlink" title="二、言简意赅金句类："></a>二、言简意赅金句类：</h3><hr>
<h5 id="辰昊楠-Yami-的土豆宽粉-："><a href="#辰昊楠-Yami-的土豆宽粉-：" class="headerlink" title="辰昊楠 -(Yami 的土豆宽粉)："></a>辰昊楠 -(Yami 的土豆宽粉)：</h5><p>可能两个人有时候最好的状态就是彼此心照不宣。那种期许愿景的心情是毕生难忘的。</p>
<h5 id="回复：-4"><a href="#回复：-4" class="headerlink" title="回复："></a>回复：</h5><p>是的，心有戚戚但不发一言，人潮之中彼此相视而窃喜。</p>
<h5 id="小呀么小二郎-1"><a href="#小呀么小二郎-1" class="headerlink" title="小呀么小二郎"></a>小呀么小二郎</h5><p>“对于普通人来说，及时止损永远比盈利更重要。”</p>
<h5 id="回复：-5"><a href="#回复：-5" class="headerlink" title="回复："></a>回复：</h5><p>大家都要树立底线思维，只要坐在牌桌上，就有机会。</p>
<h5 id="Fiona"><a href="#Fiona" class="headerlink" title="Fiona"></a>Fiona</h5><p>谈恋爱也是要调动智商，考验个人能力的呀！可惜大多数人都太不重视了，得过且过</p>
<h5 id="Lesserror"><a href="#Lesserror" class="headerlink" title="Lesserror"></a>Lesserror</h5><p>欲擒故纵，各位。舔来的爱情是脆弱不堪的。我们要用自己的价值去给她造成难以泯灭的吸引。</p>
<h5 id="回复：-6"><a href="#回复：-6" class="headerlink" title="回复："></a>回复：</h5><p>同意你的观点，要展示自己的价值，也愿你能温柔以待。</p>
<h3 id="三、皮一下很开心类："><a href="#三、皮一下很开心类：" class="headerlink" title="三、皮一下很开心类："></a>三、皮一下很开心类：</h3><hr>
<h5 id="Sweeney"><a href="#Sweeney" class="headerlink" title="Sweeney"></a>Sweeney</h5><p>嗯，先把陪我看曼联比赛这条用上😂</p>
<h5 id="回复：-7"><a href="#回复：-7" class="headerlink" title="回复："></a>回复：</h5><p>嗯，按时间算，您发这条评论的时候曼联马上要踢西汉姆了，半夜三点陪看球那绝对是真爱！</p>
<h5 id="捞鱼的搬砖奇"><a href="#捞鱼的搬砖奇" class="headerlink" title="捞鱼的搬砖奇"></a>捞鱼的搬砖奇</h5><p>我防我自己（狗头）</p>
<h5 id="回复：-8"><a href="#回复：-8" class="headerlink" title="回复："></a>回复：</h5><p>外邪易诛 心魔难伏。</p>
<h5 id="Pluto"><a href="#Pluto" class="headerlink" title="Pluto"></a>Pluto</h5><p>有时候，单身，可能不是你不够好，而是你太好。</p>
<p>挺好的，还能这样骗骗自己。</p>
<h5 id="回复：-9"><a href="#回复：-9" class="headerlink" title="回复："></a>回复：</h5><p>刘亦菲还单身呢！</p>
<h5 id="嗣树："><a href="#嗣树：" class="headerlink" title="嗣树："></a>嗣树：</h5><p>飞龙骑脸，找老仙奶一口不是更香。</p>
<h5 id="回复：-10"><a href="#回复：-10" class="headerlink" title="回复："></a>回复：</h5><p>毒奶老仙，法力无边。</p>
<h5 id="keke"><a href="#keke" class="headerlink" title="keke"></a>keke</h5><p>我一直试图从神经生物学和意识的角度去破解恋爱的本质，以至于现在感觉恋爱就是在某些基因的控制下通过分泌某些激素来带动身体的部分器官和组织发生某些生物学反应的一种状态，那么如何能够让这种状态发挥到极致呢？我想可以基于大数据和云计算，通过视觉识别去快速定位到能跟自己基因产生某种量子自旋和跃迁效应的基因所承载的某个人或某些人，之后再去通过因果之梯去找出那个“命中注定”的 only one，这样就很容易匹配到恋爱对象了，然后把这种最优解植入到基因中去，并去区块链库中进行登记，这样就实现了基因层面的恋爱关系绑定，不可篡改、永不分开，当然这一切都发生在基因层面上，人类的意识是无法感知到的。</p>
<h5 id="回复：-11"><a href="#回复：-11" class="headerlink" title="回复："></a>回复：</h5><p>嘿嘿，您的想法非常有趣，有本书叫自私的基因，也是希望通过生物学的角度来解析人的社会化行为。不过我建议您要对爱情保有信心，从生物学来讲，这种决定论也是一种群体概率而非个体选择；从社会学来讲，人的一切行为既有先天基因的决定，也有后天教育的养成；从哲学上来讲，人有主观能动性，机械决定论可能还是值得商榷。</p>
<h5 id="aiden"><a href="#aiden" class="headerlink" title="aiden"></a>aiden</h5><p>我就想知道，21 天玩转 Python 这门课在哪？女朋友先放一边，Python 学习很重要。</p>
<h3 id="四、现实问题答疑类："><a href="#四、现实问题答疑类：" class="headerlink" title="四、现实问题答疑类："></a>四、现实问题答疑类：</h3><hr>
<h5 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h5><p>李老师，我和男朋友因为要买房结婚（感情也到位了），他父母出首付，后期一起还贷款。我在想如何与他的父母沟通，说这个房子算是婚房，属于夫妻共同财产，如果分手就对半分，想请教老师与他父母如何沟通比较合适呢？希望得到指点~</p>
<h5 id="A："><a href="#A：" class="headerlink" title="A："></a>A：</h5><p>第一，分手对半分是指结婚之前感情万一破裂的情况吗？这种情况一般来讲在他们出首付的情况下不太可能答应的。</p>
<p>第二，如果是指结婚之后，那么按照现行婚姻法的要求，夫妻双方共同还贷，还贷和房产增值部分是属于夫妻双方共同财产。</p>
<p>第三，如果你觉得第二条还不够，还需要首付部分的话，最好是婚后要求房产更名为双方共同拥有。</p>
<p>第四，以上三种情况，无论哪种都不要与他父母沟通，你记住一条，你男朋友才是核心。任何时候你男朋友要你搞定他爸妈，那说明你男朋友对这件事的态度也是 no。</p>
<h5 id="Q"><a href="#Q" class="headerlink" title="Q:"></a>Q:</h5><p>老师，我现在有个情况是这样的，我跟女孩已经 4 个月了，相亲认识的，开始时候会想有好感聊得也很多，1 个多月后，算是心照不宣的确立关系，但是俩个人异地，女方之前有明确的表现说来我的工作所在地工作，双方父母都比较着急，已经操持订婚的事情了，中间还有没人我的父母想让她去我的所在地工作，圣诞节见面之后女方对我的态度急转直下，可能是双方父母去聊彩礼的事没有谈拢，我是觉得还没有到必须要到这一步，然后女生说之前自己恋爱脑了，现在想慢慢发展，我跟她现在每天也就聊个 10 来句，不怎么回复我了，也不关心我的生活了，请问老师这种情况我应该怎么办，我还是想挽回的。</p>
<h5 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h5><p>因为女方到你所在的城市，属于比较重大的人生选择和变动，而且到你所在城市后，你是不是还准备接她进门共同生活？</p>
<p>在这种情况，女方需要男方一个比较可靠的承诺是可以理解的，但是你觉得事情还没有到这一步。</p>
<p>我想这可能是矛盾的关键环节，如果你们双方确实对对方有意，双方父母又都非常满意且着急的情况下，最好是都拿出诚意来解决这个承诺问题。</p>
<h5 id="Q-1"><a href="#Q-1" class="headerlink" title="Q:"></a>Q:</h5><p>我想问下 男生觉的 面子很重要 很敏感 把这个当成他的底线，但是这个底线 对女生来说 就是很正常的交流和沟通 我认为他太敏感了 这也变成了我不能接受的点 怎么破 我想知道我有错么？</p>
<p>ps(这个男生其他方面好 OK 就是大男子主义，认为必须给他留足面子，尤其在有其他外人的情况下，自认为自己的选择和认知就是正确，觉得什么就得他做主，不允许别人否定和反驳 否则就认为你不认可 支持他，让他没面子</p>
<p>他就开始恼怒，然后两个人开始冷战，他也不会主动低头认错 或者主动和好……)</p>
<p>我自己的话 说话 可能稍微有点直接 但是真的没有到他所说的不给他留面子，我的直接也是觉得你是我最亲密的人 才这样说，而且肯定没有所谓的恶意，但是他也不认为，所以 心累啊</p>
<p>两个人已经好几次因为这个事情吵架了 我该如何解决 期待得到回复 谢谢啦！</p>
<h5 id="A-1"><a href="#A-1" class="headerlink" title="A:"></a>A:</h5><p>这其实是个双方磨合的问题，既然这个男生其他方面都好 OK，就是在外人面前要摆大男子主义架子这一个缺点的话，我建议你有条件地接受他这个要求。</p>
<p>这个大男子主义不能侵犯你的尊严，比如：他可以吹牛逼自己痛打过奥巴马，但是不能吹牛逼在家打你</p>
<p>打蛇打七寸，聪明的女人都知道在人前给男朋友一点面子，人后能有多大的好处。但是你可以给，他不能要，给不给看表现，懂了咩？</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>春节加餐3 恋爱课直播集锦：恋爱这件小事儿</title>
    <url>/2022/11/25/love/16/</url>
    <content><![CDATA[<p>今天是我们春节特别加餐的最后一讲了，这预示了什么？</p>
<p>预示着我们马上就要离开假期的怀抱，继续投身于社会浪潮中，做个快乐“打工人”了（快乐不快乐不一定，但是打工是一定的）。打工之余，也别忘了把恋爱这件事提上日程。</p>
<p>恋爱课开课以来，我一共开了三场直播。很多小伙伴跟我反映，自己错过了某一场直播，觉得很可惜。于是，我从这三场直播中，挑选了其中最精华的内容，今天给你做一次汇总分享。</p>
<p>真理是越辩越明的，恋爱这门学问也是需要不断揣摩和思考的，希望今天能给你新的灵感。</p>
<span id="more"></span>

<h3 id="相亲第一次见面注意什么？"><a href="#相亲第一次见面注意什么？" class="headerlink" title="相亲第一次见面注意什么？"></a>相亲第一次见面注意什么？</h3><hr>
<h5 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h5><p>老师，家里介绍的第一次见面的男生，应该怎么准备更好，见面应该聊什么？</p>
<h5 id="A："><a href="#A：" class="headerlink" title="A："></a>A：</h5><p>相亲和自由恋爱是不一样的。</p>
<p>第一次见面的时候，你要注意的是，你要学会“装”一下。毕竟，第一次见面，你要给对方一个相对较好的印象。比如说，在打扮方面，你不能太随意，要稍微正式一点。</p>
<p>在环境的选择上，你可以选择相对较为熟悉的环境，这样方便你应对会出现的问题。还有见面的时候聊什么呢？你要聊自己和对方的情况。其实，这就是一个快速确认的过程。</p>
<p>确认什么呢？比如说，对方的长相，对方的谈吐，这都是你能快速了解到的。接下来，可以聊聊家庭情况、工作情况呀。你要把自己的基础信息提供给对方，这是相亲礼仪之一。</p>
<p>如果你有很硬的实力，像有一套房、一辆车或一个车位，要学会展现，相亲是一个很快的筛选过程。情况基本确认后，才能进入偏个人的层面，比如说兴趣爱好，有没有共同语言之类的。</p>
<p>如果这些信息，你们都交换完了，你就可以找一些可以自由发展的，或者是你擅长的兴趣爱好的一些环节，跟对方分享一下，试着聊聊看。我们说过，亲密关系的第一层级就是兴趣爱好。</p>
<p>或者是对方喜欢什么，看看能不能展开聊聊，亲密关系的第一层级能不能站得住脚。结束后，要记得及时反馈给对方或者是媒人，是觉得不错继续试试，还是这个不太行，停止继续发展。</p>
<p>这就是相亲的时候，第一次见面需要完成的任务。更具体的，我们会在第 09 讲展开。</p>
<h3 id="双方年龄差十岁怎么办？"><a href="#双方年龄差十岁怎么办？" class="headerlink" title="双方年龄差十岁怎么办？"></a>双方年龄差十岁怎么办？</h3><hr>
<h5 id="Q：-1"><a href="#Q：-1" class="headerlink" title="Q："></a>Q：</h5><p>老师，年龄因素会有影响吗？影响有多大？比如说，相差十岁的那种。</p>
<h5 id="A：-1"><a href="#A：-1" class="headerlink" title="A："></a>A：</h5><p>年龄呢，这个因素是一定会有影响的。但是不光年龄，你说，身高影不影响，年收入有差距，家庭背景不一样，有没有影响？当然有影响。当你问这个问题的时候，你自己心里都知道答案。</p>
<p>每个人包括你自己，在婚恋市场上，都想找到一个跟自己价值匹配的人。</p>
<p>但是，人又都是多元化的，每个人都有一个自己的价值矩阵。有的人这里突出一点，有的人那里突出，形状都是不一样的。什么样的矩阵不重要，重要的是你的价值需求是什么。</p>
<p>某个人的价值矩阵可能就是你的最优解。也许，年龄差十岁会影响到你们的感情，但偏偏对方另外一点特别吸引你，特别契合你的需求，可以补平其他地方的差距，年龄就不会是一个决定因素了。但是，如果在你的价值需求里，年龄这个点特别重要，那么你就不适合找一个差十岁的。</p>
<p>一把钥匙开一把锁，我们每个人都想找个更适合自己的人。所以，重点看你的需求是什么。</p>
<h3 id="表白会变成一种错误吗？"><a href="#表白会变成一种错误吗？" class="headerlink" title="表白会变成一种错误吗？"></a>表白会变成一种错误吗？</h3><hr>
<h5 id="Q：-2"><a href="#Q：-2" class="headerlink" title="Q："></a>Q：</h5><p>老师，我之前跟一个男生表白，他同意了。但是没过几天，他就说，我们还是做朋友吧！这种情况的话，我和他还有机会在一起吗？</p>
<h5 id="A：-2"><a href="#A：-2" class="headerlink" title="A："></a>A：</h5><p>这种属于表白坏事的典型例子。</p>
<p>首先说明，他对你是有一定好感的，但是这种好感的程度还不够。你表白，虽然他同意了，但很有可能是迫于压力或者是当时的氛围渲染等等，跟你在一起的。</p>
<p>过了几天，又想做回朋友，是因为他其实是没有做好准备的。如果你问我，还有机会吗？</p>
<p>其实，还是有机会的。不过，没表白之前，机会可能很大，表白之后，就降低了你的可能性。但机会是一定会存在的，既然他能答应你，就说明他觉得你这个人还不错。</p>
<p>他说还是做朋友，并不是说你这个人不行，言外之意是觉得你们的关系还没到恋人的那一步。你可以以朋友的身份，继续深入这段关系，再去看看。</p>
<h3 id="怎么控制自己的目的性？"><a href="#怎么控制自己的目的性？" class="headerlink" title="怎么控制自己的目的性？"></a>怎么控制自己的目的性？</h3><hr>
<h5 id="Q：-3"><a href="#Q：-3" class="headerlink" title="Q："></a>Q：</h5><p>老师，我想问，怎么才能做到既喜欢对方，又对对方没有什么目的性呢？感觉喜欢上对方后，我很难控制不住我的目的性。</p>
<h5 id="A：-3"><a href="#A：-3" class="headerlink" title="A："></a>A：</h5><p>这个问题问得很在点子上，但解决这个问题也很简单。</p>
<p>你对对方有好感，你想想你的目的是什么。我喜欢一个人，不是说我想让 Ta 帮我解决一个情感需求，或者是解决一个什么实际问题。喜欢一个人，可能只是单纯想跟 Ta 在一起。</p>
<p>是那种单纯地想去吃一顿饭，单纯地想一起喝一杯咖啡，或者是一起聊个天的心情。你对这个人没有什么其他的需求，并不要求对方陪你干这干那，也不强求对方一定成为你的伴侣。</p>
<p>你不能有上面这种目的性，你要让自己只是单纯地想完成心中的想法和愿望。想让对方陪自己吃饭，这不叫目的性，目的性是你想让对方做你的对象，让对方拒绝别人，确定和你的关系。</p>
<p>总的来说，我们要真诚起来，真诚地去对别人。真诚就永远不会有目的性。</p>
<h3 id="爱情真的有理所当然吗？"><a href="#爱情真的有理所当然吗？" class="headerlink" title="爱情真的有理所当然吗？"></a>爱情真的有理所当然吗？</h3><hr>
<h5 id="Q：-4"><a href="#Q：-4" class="headerlink" title="Q："></a>Q：</h5><p>老师，怎样才能心安理得地接受另一半对自己的好呢？</p>
<h5 id="A：-4"><a href="#A：-4" class="headerlink" title="A："></a>A：</h5><p>这个问题很经典。</p>
<p>在一段情感关系中，如果一个人不停地对自己好，但是 Ta 又不求任何回报，你是会有很大心理压力的。包括你对别人也是一样，你对别人很好，别人一定程度上也会有心理压力。</p>
<p>就好比我们总帮助一个朋友，帮助得越多，还不求回报，朋友的恶感其实会越大。一旦有一天，某一次，我们帮助不了他，他会对你有加倍的恶感。这个是没有办法避免的。</p>
<p>我们想接受这种关系，比如说挥之既来，呼之即去的那种，叫对方做什么都做，但是对我们一点要求都没有，是没办法心安理得接受的。能够心安理得接受的，可能都是渣男 &#x2F; 渣女。</p>
<p>你不渣，所以你问了这个问题，因为你没法心安理得地接受。</p>
<p>那怎么去调节这种关系呢？很简单，两个人需要共同地去付出。你可以去想想，你在这段感情里，能付出什么，或者是能做到什么，一定有你可以去做的事情的。</p>
<p>你的另一半可能只是不善于表达自己的诉求，不代表 Ta 没有这种诉求。恰恰相反，Ta 内心可能有很大的诉求，只是不敢讲，Ta 怕讲了以后，会影响到这段感情，才闷在心里。</p>
<p>其实，越是这种没有诉求的人，Ta 其实越害怕提出诉求。Ta 怕提出一点点诉求，就把你吓跑，失去这段关系。所以，你要对这种人特别地好才行，找到诉求，满足 Ta。</p>
<h3 id="男生第一次见面要不要拉手？"><a href="#男生第一次见面要不要拉手？" class="headerlink" title="男生第一次见面要不要拉手？"></a>男生第一次见面要不要拉手？</h3><hr>
<h5 id="Q：-5"><a href="#Q：-5" class="headerlink" title="Q："></a>Q：</h5><p>老师，作为男生，第一次见面约会，手拉手合适吗？</p>
<h5 id="A：-5"><a href="#A：-5" class="headerlink" title="A："></a>A：</h5><p>第一次见面，如果之前没有什么感情基础，尤其是相亲，其实是不太合适的。会给女生一种不太礼貌，有点打扰的感觉。当然，有一种情况除外，那就是女主有所主动。</p>
<p>如果女生跟你主动拉手，或者是提出拉手，你是可以主动一点的。这里面是有个讲究的。</p>
<p>但是，作为男生，第一次接触控制在一定距离之内，绝对是会给女生留好感的。</p>
<h3 id="忘记了生日是不是不爱我？"><a href="#忘记了生日是不是不爱我？" class="headerlink" title="忘记了生日是不是不爱我？"></a>忘记了生日是不是不爱我？</h3><hr>
<h5 id="Q：-6"><a href="#Q：-6" class="headerlink" title="Q："></a>Q：</h5><p>老师，我是男生，我生日的时候，女生忘记了。后来她知道了，跟我道歉了。不过，她只给我唱了生日歌，我应该如何理解？</p>
<h5 id="A：-6"><a href="#A：-6" class="headerlink" title="A："></a>A：</h5><p>这个问题很扎心。我们该如何理解呢？</p>
<p>首先，如果她是你的女朋友，你可能觉得女生不是都能记住男朋友生日吗？或者是你们认识多年了，她是你喜欢的女孩子，我建议你去做一个良性的表达，她可能有什么不得已的理由。</p>
<p>可是，如果你们刚刚认识或者认识不久，她忘记你的生日，你可以先向她表示理解，但是事情不能就这样过去，你可以心平气和地跟她表达你的在乎、你的难过，但不要是不满。</p>
<p>比如说，你可以这样说：“全世界有多少人记住我的生日，我是不在乎的。但是因为我很在乎你，所以你没记住，我很难过。”然后可以装作“惩罚”或者让她“承诺”。</p>
<p>像是明年一起过生日，一起出去吃顿饭，或者你给我补个小礼物。</p>
<p>其实，我们都不是在乎这个礼物什么的，在乎的是心意，要把这点表达到。</p>
<h3 id="国家会分配对象吗？"><a href="#国家会分配对象吗？" class="headerlink" title="国家会分配对象吗？"></a>国家会分配对象吗？</h3><hr>
<h5 id="Q：-7"><a href="#Q：-7" class="headerlink" title="Q："></a>Q：</h5><p>老师，未来国家会分配对象吗？</p>
<h5 id="A：-7"><a href="#A：-7" class="headerlink" title="A："></a>A：</h5><p>一定不会的。</p>
<p>即便分配了，你也会不满意。换句话说，国家敢分配，你敢要吗？所以说，我们不要指望国家分配，找对象这件事，我们还是要靠自己！自己动手，丰衣足食！</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>结束语 但行好事，莫问前程</title>
    <url>/2022/11/25/love/17/</url>
    <content><![CDATA[<p>终于还是到了结束语的环节，到了要说再见的时候，感谢你，与我一路走到了这里。</p>
<span id="more"></span>

<h3 id="送君千里，终须一别"><a href="#送君千里，终须一别" class="headerlink" title="送君千里，终须一别"></a>送君千里，终须一别</h3><hr>
<p>课程结束了，在开篇词中，我曾吹牛说这门课与大部分情感课都不一样。今天，我觉得我确实做到了，可以理直气壮地说，这门课确实与大部分情感课都不一样。</p>
<p>三个月前，我们其实计划做一个武侠方向的情感课程。当时，课程名字还不叫《恋爱必修课》，而是《爱情的独孤九剑》，每一讲的标题也是各种各样的武侠招式。虽然，最终的课程呈现形式和我们当初设想的并不完全相同，但效果还是令人满意的。</p>
<p>最重要的是，能够陪伴你走完这一个多月的爱情之路，与你一起研究爱情这个课题，探讨爱情、分析爱情，遇见了如此多的新朋友。虽有万般不舍，但也是聚散终有时。</p>
<p>这就是送君千里，终须一别吧！</p>
<h3 id="但行好事，莫问前程"><a href="#但行好事，莫问前程" class="headerlink" title="但行好事，莫问前程"></a>但行好事，莫问前程</h3><hr>
<p>于我而言，这门课程给我留下了很多值得回忆的地方。</p>
<p>第一讲的时候，有点“任性”地引用了一句道德经，可能有点孤僻，但真的有三位朋友在留言区中对此大加赞赏，可谓杨意不逢，抚凌云而自惜，钟期既遇，奏流水以何惭；</p>
<p>在春节的时候，加更了三讲特辑内容，还放了一篇卖萌的小故事，集锦了大家的评论。由于故事过于羞耻（捂脸）没录音，但不影响大过年，让人看的开心；</p>
<p>有开心也有遗憾，没有在春节前把相亲那一讲更新出来，是一件令人惋惜的事情，也在留言区里，受到了一点批评，在此也特别说声抱歉；</p>
<p>从课程上线开始，做了三次直播，从 PPT 车祸现场到美丽的 11 老师特邀出席，动了很多脑筋，虽然直播人数没有突破 3 位数，但是在答疑解惑时，收获了很多“有趣”的问题；</p>
<p>在课程更新的这段时间，基本做到了留言必回，在留言区为各路小伙伴出了不少主意，只是有些问题语焉不详，所以也没法细说，但心里也挂念着事态发展如何；</p>
<p>做了若干次的一对一咨询，坚持偷偷摸摸地按照至少 1 比 1 的时间进行准备，帮助不少朋友解决了恋爱和婚姻问题，过年收到了一大堆祝福感谢；</p>
<p>……</p>
<p>所以，你看，人生就是这样，你不能保证每次努力都会有收获，但只要你始终认真对待生活，生活终将不负于你。</p>
<p>恋爱也是如此，无论你有多优秀、无论你爱的能力有多强、无论你爱的意愿有多坚决，你也无法保证每一个你爱上的人，都会同样爱你。但你能做的，只有做好自己，把剩下的交给命运。</p>
<p>今年情人节的时候，有人找我咨询，说和相亲对象在同地工作，年前见了几次面，感觉还不错。又恰巧是老乡，但同市不同县，过年一直约不出来，问我情人节是不是应该在微信上聊点啥。</p>
<p>我立马问他，去姑娘家的那个县要多久？</p>
<p>他说要一个小时，我说，你在北京从天通苑跑趟北京西站都不止一个多小时，怎么感觉跟跨国恋一样见不了面呢？情人节你当然要直接杀过去，约姑娘见面呀！微信上聊，能有这效果吗？</p>
<p>他答复我说，其实也想过，但是在微信上试探了一下，姑娘没有流露出答应情人节出来跟他约会的意思，他怕去了扑个空。我说，这种事你就是要冒着风险跑路，才能体现心意，才叫浪漫嘛，十拿九稳的事情从来不浪漫。再说了，就算扑空了，你只当是去逛街了呗。</p>
<p>最终，他听取我的建议，赶着下午的时候，到了姑娘所在的地方，根据我介绍的讲话要点，非常顺利地约出了姑娘并且玩到很晚。这个例子，我也放在了评论区，回答了一个类似情况的朋友，如果你喜欢翻评论的话，可能也看到了。</p>
<p>所以，这个例子说明什么呢？千万不要患得患失，算计过重，要勇敢地去爱，不要让今天的自己为明天的自己牺牲太多，但也不要让明天的自己为今天的自己后悔不已。</p>
<p>要记住，但行好事，莫问前程。</p>
<h3 id="你就是你，独自美丽"><a href="#你就是你，独自美丽" class="headerlink" title="你就是你，独自美丽"></a>你就是你，独自美丽</h3><hr>
<p>如果你认真地听了每一讲，可能你也发现了，咱们这个课程特别强调自己。不管是什么事情、什么时期、什么问题，都要贯彻以我为主的原则，甚至连防渣手册还说了要反躬自省。</p>
<p>这个原则，我想最后再提一次。因为现代社会焦虑无处不在，每个人在追逐焦虑的过程中，往往就忽视了自己。我们总是害怕自己不够优秀，害怕因为不够优秀，而失去爱的机会。</p>
<p>实际上，大多数人其实真的没那么优秀，起码我就属于特别一般的那一种。</p>
<p>我中学的时候就是一个八卦绝缘体。那时候，中学生家长和老师特别担心学生早恋，对此是严防死守的。一旦有男生女生单独出行或是交往过密，就要迎来一顿严刑拷问。</p>
<p>但邪门的事就在于，所有的老师家长都对我特别放心。</p>
<p>哦，和李一帆出去玩，那没事你快去吧；哦，这么晚回来是和李一帆一块自习呐，那没事你早点去休息吧……直到现在，我想起来，也真不知道应该为此高兴还是难过。</p>
<p>而且那个时候也不喜欢女生，别多想，我的意思是，那个时候我对身边的女生不是特别感兴趣，我喜欢的都是武侠小说里面虚构的女性角色——敏敏郡主、蓉儿妹妹、盈盈小姐……以至于常常觉得自己可能有点怪，跟其他说到妹子就两眼放光的兄弟貌似不大一样。</p>
<p>但是，以我现在的眼光看待过去的我自己，我会告诉过去的那个小孩，要坚持做自己，你要相信不一样是正常的，自己总能在这个世界走出自己的路。相信就会，相信本身就是力量。</p>
<p>当然，这是成功经验的分享，不是失败教训的体验。我这个老师家长特别放心的天赋，在后来婚恋过程中，成功升级为丈母娘必杀技——无论认识的姑娘满不满意，反正姑娘家长总是满意的。再比如天天幻想跟小说人物谈恋爱，所以才能深情满满地写下《金庸教你谈恋爱》。</p>
<p>每个人都是这个世界上独一无二的形状，有时候磨平自己，也并不一定就能找到另一半，但坚持做自己，总会有那个契合你形状的爱情出现，并且不需要你多做什么。</p>
<p>因为，你就是你，独自美丽。</p>
<h3 id="凡是过往，皆为序章"><a href="#凡是过往，皆为序章" class="headerlink" title="凡是过往，皆为序章"></a>凡是过往，皆为序章</h3><hr>
<p>我们度过的每一天、做过的每件事、爱过的每个人，都会成为生命中不可分割的部分。</p>
<p>有人讲，这个课程很治愈，听完终于摆脱了多日的失眠，安心睡去；有人讲，这个课很伤感，听完想起了多年前的恋情，后悔那时候还不懂如何去爱；有人讲，这个课很启迪，听完就开悟了。</p>
<p>我想说，其实，这个课程本身只是引子，你看到和你感受到的，全部都是你自己的感悟和体会，是你自己的总结和思考。而我呢，只是做了一点微不足道的工作。</p>
<p>“如今你的气质里，藏着你走过的路，读过的书和爱过的人。”</p>
<p>你感受到的千钧重量都是你生命的重量。人生总是这样，用大把时间迷茫，用几个瞬间成长。</p>
<p>希望这个课程给你提供的情感框架，能够让你在犹豫中更加勇敢、在徘徊中更加坚定、在迷茫中开辟方向、在痛苦中得到安慰，在恋爱这条路上乘风破浪，一往无前。</p>
<p>课程完结，如果这是你的第一门恋爱启蒙课，那么我倍感荣幸。希望它能够像种子一样播撒，也成为你生命的一部分，在恰当的时机，成长为幸福的大树。</p>
<p>当然，这需要你继续在生活中实践，在爱情中思考。凡是过往，皆为序章。</p>
<h3 id="山高路远，江湖再见"><a href="#山高路远，江湖再见" class="headerlink" title="山高路远，江湖再见"></a>山高路远，江湖再见</h3><hr>
<p>今番良晤，豪兴不浅。他日江湖相逢，再当杯酒言欢，咱们就此别过。</p>
<p>哦，等等，最后还有两件事。</p>
<p>第一件事呢，就是应留言区广大小伙伴的强烈要求，我们计划搞个相亲帖，让学完本课程后有意寻觅良缘的单身男女们，自产自销，岂不美哉，具体请点击这里。</p>
<p>你可以在这里，公布自己的基本情况，所在城市和对另一半的要求。</p>
<p>第二件事，就是课程结束后，如果你有比较简单的问题，可以继续在留言区里留言，我还是会坚持回复问题的。但是，如果问题比较复杂，三言两语说不清楚，又或者是不想被其他朋友看到，也可以购买一对一的咨询服务，具体请点击这里。</p>
<p>祝天下有情人终成眷属，愿你早日学有所成，觅得真爱。</p>
<p>好啦，这下真的要说再见了，祝好。</p>
]]></content>
      <categories>
        <category>恋爱必修课</category>
      </categories>
      <tags>
        <tag>恋爱必修课</tag>
      </tags>
  </entry>
  <entry>
    <title>01 为何说只有 1 种实现线程的方法？</title>
    <url>/2022/11/29/tech/java/concurrent/01/</url>
    <content><![CDATA[<p>在本课时我们主要学习为什么说本质上只有一种实现线程的方式？实现 Runnable 接口究竟比继承 Thread 类实现线程好在哪里？</p>
<p>实现线程是并发编程中基础中的基础，因为我们必须要先实现多线程，才可以继续后续的一系列操作。所以本课时就先从并发编程的基础如何实现线程开始讲起，希望你能够夯实基础，虽然实现线程看似简单、基础，但实际上却暗藏玄机。首先，我们来看下为什么说本质上实现线程只有一种方式？</p>
<p>实现线程的方式到底有几种？大部分人会说有 2 种、3 种或是 4 种，很少有人会说有 1 种。我们接下来看看它们具体指什么？2 种实现方式的描述是最基本的，也是最为大家熟知的，我们就先来看看 2 种线程实现方式的源码。</p>
<span id="more"></span>

<h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&#x27;用实现Runnable接口实现线程&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 种方式是通过实现 Runnable 接口实现多线程，如代码所示，首先通过 RunnableThread 类实现 Runnable 接口，然后重写 run() 方法，之后只需要把这个实现了 run() 方法的实例传到 Thread 类中就可以实现多线程。</p>
<h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&#x27;用Thread类实现线程&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 2 种方式是继承 Thread 类，如代码所示，与第 1 种方式不同的是它没有实现接口，而是继承 Thread 类，并重写了其中的 run() 方法。相信上面这两种方式你一定非常熟悉，并且经常在工作中使用它们。</p>
<h4 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h4><p>那么为什么说还有第 3 种或第 4 种方式呢？我们先来看看第 3 种方式：通过线程池创建线程。线程池确实实现了多线程，比如我们给线程池的线程数量设置成 10，那么就会有 10 个子线程来为我们工作，接下来，我们深入解析线程池中的源码，来看看线程池是怎么实现线程的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于线程池而言，本质上是通过线程工厂创建线程的，默认采用 DefaultThreadFactory ，它会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程，以及线程的优先级等。但是无论怎么设置这些属性，最终它还是通过 new Thread() 创建线程的 ，只不过这里的构造函数传入的参数要多一些，由此可以看出通过线程池创建线程并没有脱离最开始的那两种基本的创建方式，因为本质上还是通过 new Thread() 实现的。</p>
<p>在面试中，如果你只是知道这种方式可以创建线程但不了解其背后的实现原理，就会在面试的过程中举步维艰，想更好的表现自己却给自己挖了“坑”。</p>
<p>所以我们在回答线程实现的问题时，描述完前两种方式，可以进一步引申说“我还知道线程池和Callable 也是可以创建线程的，但是它们本质上也是通过前两种基本方式实现的线程创建。”这样的回答会成为面试中的加分项。然后面试官大概率会追问线程池的构成及原理，这部分内容会在后面的课时中详细分析。</p>
<h4 id="有返回值的-Callable-创建线程"><a href="#有返回值的-Callable-创建线程" class="headerlink" title="有返回值的 Callable 创建线程"></a>有返回值的 Callable 创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br></pre></td></tr></table></figure>

<p>第 4 种线程创建方式是通过有返回值的 Callable 创建线程，Runnable 创建线程是无返回值的，而 Callable 和与之相关的 Future、FutureTask，它们可以把线程执行的结果作为返回值返回，如代码所示，实现了 Callable 接口，并且给它的泛型设置成 Integer，然后它会返回一个随机数。</p>
<p>但是，无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的，而子线程的创建方式仍脱离不了最开始讲的两种基本方式，也就是实现 Runnable 接口和继承 Thread 类。</p>
<h4 id="其他创建方式"><a href="#其他创建方式" class="headerlink" title="其他创建方式"></a>其他创建方式</h4><h5 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲到这里你可能会说，我还知道一些其他的实现线程的方式。比如，定时器也可以实现线程，如果新建一个 Timer，令其每隔 10 秒或设置两个小时之后，执行一些任务，那么这时它确实也创建了线程并执行了任务，但如果我们深入分析定时器的源码会发现，本质上它还是会有一个继承自 Thread 类的 TimerThread，所以定时器创建线程最后又绕回到最开始说的两种方式。</p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *描述：匿名内部类创建线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>或许你还会说，我还知道一些其他方式，比如匿名内部类或 lambda 表达式方式，实际上，匿名内部类或 lambda 表达式创建线程，它们仅仅是在语法层面上实现了线程，并不能把它归结于实现多线程的方式，如匿名内部类实现线程的代码所示，它仅仅是用一个匿名内部类把需要传入的 Runnable 给实例出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下 lambda 表达式方式。如代码所示，最终它们依然符合最开始所说的那两种实现线程的方式。</p>
<h4 id="实现线程只有一种方式"><a href="#实现线程只有一种方式" class="headerlink" title="实现线程只有一种方式"></a>实现线程只有一种方式</h4><p>关于这个问题，我们先不聚焦为什么说创建线程只有一种方式，先认为有两种创建线程的方式，而其他的创建方式，比如线程池或是定时器，它们仅仅是在 new Thread() 外做了一层封装，如果我们把这些都叫作一种新的方式，那么创建线程的方式便会千变万化、层出不穷，比如 JDK 更新了，它可能会多出几个类，会把 new Thread() 重新封装，表面上看又会是一种新的实现线程的方式，透过现象看本质，打开封装后，会发现它们最终都是基于 Runnable 接口或继承 Thread 类实现的。</p>
<p>接下来，我们进行更深层次的探讨，为什么说这两种方式本质上是一种呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，启动线程需要调用 start() 方法，而 start() 方法最终还会调用 run() 方法，我们先来看看第一种方式中 run() 方法究竟是怎么实现的，可以看出 run() 方法的代码非常短小精悍，第 1 行代码 if (target !&#x3D; null) ，判断 target 是否等于 null，如果不等于 null，就执行第 2 行代码 target.run()，而 target 实际上就是一个 Runnable，即使用 Runnable 接口实现线程时传给Thread类的对象。</p>
<p>然后，我们来看第二种方式，也就是继承 Thread 方式，实际上，继承 Thread 类之后，会把上述的 run() 方法重写，重写后 run() 方法里直接就是所需要执行的任务，但它最终还是需要调用 thread.start() 方法来启动线程，而 start() 方法最终也会调用这个已经被重写的 run() 方法来执行它的任务，这时我们就可以彻底明白了，事实上创建线程只有一种方式，就是构造一个 Thread 类，这是创建线程的唯一方式。</p>
<p>我们上面已经了解了两种创建线程方式本质上是一样的，它们的不同点仅仅在于实现线程运行内容的不同，那么运行内容来自于哪里呢？</p>
<p>运行内容主要来自于两个地方，要么来自于 target，要么来自于重写的 run() 方法，在此基础上我们进行拓展，可以这样描述：本质上，实现线程只有一种方式，而要想实现线程执行的内容，却有两种方式，也就是可以通过 实现 Runnable 接口的方式，或是继承 Thread 类重写 run() 方法的方式，把我们想要执行的代码传入，让线程去执行，在此基础上，如果我们还想有更多实现线程的方式，比如线程池和 Timer 定时器，只需要在此基础上进行封装即可。</p>
<h4 id="实现-Runnable-接口比继承-Thread-类实现线程要好"><a href="#实现-Runnable-接口比继承-Thread-类实现线程要好" class="headerlink" title="实现 Runnable 接口比继承 Thread 类实现线程要好"></a>实现 Runnable 接口比继承 Thread 类实现线程要好</h4><p>下面我们来对刚才说的两种实现线程内容的方式进行对比，也就是为什么说实现 Runnable 接口比继承 Thread 类实现线程要好？好在哪里呢？</p>
<p>首先，我们从代码的架构考虑，实际上，Runnable 里只有一个 run() 方法，它定义了需要执行的内容，在这种情况下，实现了 Runnable 与 Thread 类的解耦，Thread 类负责线程启动和属性设置等内容，权责分明。</p>
<p>第二点就是在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</p>
<p>第三点好处在于 Java 语言不支持双继承，如果我们的类一旦继承了 Thread 类，那么它后续就没有办法再继承其他的类，这样一来，如果未来这个类需要继承其他类实现一些功能上的拓展，它就没有办法做到了，相当于限制了代码未来的可拓展性。</p>
<p>综上所述，我们应该优先选择通过实现 Runnable 接口的方式来创建线程。</p>
<p>好啦，本课时的全部内容就讲完了，在这一课时我们主要学习了 通过 Runnable 接口和继承 Thread 类等几种方式创建线程，又详细分析了为什么说本质上只有一种实现线程的方式，以及实现 Runnable 接口究竟比继承 Thread 类实现线程好在哪里？学习完本课时相信你一定对创建线程有了更深入的理解。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>03 线程是如何在 6 种状态之间转换的？</title>
    <url>/2022/12/01/tech/java/concurrent/03/</url>
    <content><![CDATA[<p>本课时我们主要学习线程是如何在 6 种状态之间转换的。</p>
<span id="more"></span>

<h4 id="线程的-6-种状态"><a href="#线程的-6-种状态" class="headerlink" title="线程的 6 种状态"></a>线程的 6 种状态</h4><p>就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。</p>
<p>New（新创建）<br>Runnable（可运行）<br>Blocked（被阻塞）<br>Waiting（等待）<br>Timed Waiting（计时等待）<br>Terminated（被终止）<br>如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。</p>
<h4 id="New-新创建"><a href="#New-新创建" class="headerlink" title="New 新创建"></a>New 新创建</h4><p>下面我们逐个介绍线程的 6 种状态，如图所示，首先来看下左上角的 New 状态。</p>
<img data-src="/2022/12/01/tech/java/concurrent/03/c_03_01.png" class="">

<p>New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable，也就是状态转换图中中间的这个大方框里的内容。</p>
<h4 id="Runnable-可运行"><a href="#Runnable-可运行" class="headerlink" title="Runnable 可运行"></a>Runnable 可运行</h4><img data-src="/2022/12/01/tech/java/concurrent/03/c_03_02.png" class="">

<p>Java 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。</p>
<p>所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p>
<h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><img data-src="/2022/12/01/tech/java/concurrent/03/c_03_03.png" class="">

<p>接下来，我们来看下 Runnable 下面的三个方框，它们统称为阻塞状态，在 Java 中阻塞状态通常不仅仅是 Blocked，实际上它包括三种状态，分别是 Blocked(被阻塞）、Waiting(等待）、Timed Waiting(计时等待），这三 种状态统称为阻塞状态，下面我们来看看这三种状态具体是什么含义。</p>
<h4 id="Blocked-被阻塞"><a href="#Blocked-被阻塞" class="headerlink" title="Blocked 被阻塞"></a>Blocked 被阻塞</h4><img data-src="/2022/12/01/tech/java/concurrent/03/c_03_04.png" class="">

<p>首先来看最简单的 Blocked，从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。</p>
<p>我们再往右看，当处于 Blocked 的线程抢到 monitor 锁，就会从 Blocked 状态回到Runnable 状态。</p>
<h4 id="Waiting-等待"><a href="#Waiting-等待" class="headerlink" title="Waiting 等待"></a>Waiting 等待</h4><img data-src="/2022/12/01/tech/java/concurrent/03/c_03_05.png" class="">

<p>我们再看看 Waiting 状态，线程进入 Waiting 状态有三种可能性。</p>
<ol>
<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>
<li>LockSupport.park() 方法。</li>
</ol>
<p>刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。</p>
<p>Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()&#x2F;notifyAll() 。</p>
<h4 id="Timed-Waiting-限期等待"><a href="#Timed-Waiting-限期等待" class="headerlink" title="Timed Waiting 限期等待"></a>Timed Waiting 限期等待</h4><img data-src="/2022/12/01/tech/java/concurrent/03/c_03_06.png" class="">

<p>在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。</p>
<p>以下情况会让线程进入 Timed Waiting 状态。</p>
<ol>
<li>设置了时间参数的 Thread.sleep(long millis) 方法；</li>
<li>设置了时间参数的 Object.wait(long timeout) 方法；</li>
<li>设置了时间参数的 Thread.join(long millis) 方法；</li>
<li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li>
</ol>
<p>讲完如何进入这三种状态，我们再来看下如何从这三种状态流转到下一个状态。</p>
<img data-src="/2022/12/01/tech/java/concurrent/03/c_03_07.png" class="">

<p>想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。</p>
<img data-src="/2022/12/01/tech/java/concurrent/03/c_03_08.png" class="">

<p>只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。</p>
<img data-src="/2022/12/01/tech/java/concurrent/03/c_03_09.png" class="">

<p>如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()&#x2F;notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。</p>
<img data-src="/2022/12/01/tech/java/concurrent/03/c_03_10.png" class="">

<p>同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。</p>
<img data-src="/2022/12/01/tech/java/concurrent/03/c_03_11.png" class="">

<p>当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁&#x2F;join的线程运行结束&#x2F;被中断&#x2F;调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。</p>
<h4 id="Terminated-终止"><a href="#Terminated-终止" class="headerlink" title="Terminated 终止"></a>Terminated 终止</h4><img data-src="/2022/12/01/tech/java/concurrent/03/c_03_11.png" class="">

<p>再来看看最后一种状态，Terminated 终止状态，要想进入这个状态有两种可能。</p>
<ul>
<li>run() 方法执行完毕，线程正常退出。</li>
<li>出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>最后我们再看线程转换的两个注意点。</p>
<ol>
<li>线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。</li>
<li>线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相</li>
</ol>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>thread</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title>04 wait/notify/notifyAll 方法的使用注意事项？</title>
    <url>/2022/12/02/tech/java/concurrent/04/</url>
    <content><![CDATA[<p>本课时我们主要学习 wait&#x2F;notify&#x2F;notifyAll 方法的使用注意事项。</p>
<p>我们主要从三个问题入手：</p>
<ol>
<li>为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</li>
<li>为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</li>
<li>wait&#x2F;notify 和 sleep 方法的异同？</li>
</ol>
<span id="more"></span>

<h4 id="为什么-wait-必须在-synchronized-保护的同步代码中使用？"><a href="#为什么-wait-必须在-synchronized-保护的同步代码中使用？" class="headerlink" title="为什么 wait 必须在 synchronized 保护的同步代码中使用？"></a>为什么 wait 必须在 synchronized 保护的同步代码中使用？</h4><p>首先，我们来看第一个问题，为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</p>
<p>我们先来看看 wait 方法的源码注释是怎么写的。</p>
<p>“wait method should always be used in a loop:This method should only be called by a thread that is the owner of this object’s monitor.”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">     <span class="keyword">while</span> (condition does not hold)</span><br><span class="line">        obj.wait();</span><br><span class="line">        <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This method should only be called by a thread that is the owner of this object’s monitor.”</p>
<p>英文部分的意思是说，在使用 wait 方法时，必须把 wait 方法写在 synchronized 保护的 while 代码块中，并始终判断执行条件是否满足，如果满足就往下继续执行，如果不满足就执行 wait 方法，而在执行 wait 方法之前，必须先持有对象的 monitor 锁，也就是通常所说的 synchronized 锁。那么设计成这样有什么好处呢？</p>
<p>我们逆向思考这个问题，如果不要求 wait 方法放在 synchronized 保护的同步代码中使用，而是可以随意调用，那么就有可能写出这样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; buffer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">give</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        buffer.add(data);</span><br><span class="line">        notify();  <span class="comment">// Since someone may be waiting in take</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (buffer.isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中可以看到有两个方法，give 方法负责往 buffer 中添加数据，添加完之后执行 notify 方法来唤醒之前等待的线程，而 take 方法负责检查整个 buffer 是否为空，如果为空就进入等待，如果不为空就取出一个数据，这是典型的生产者消费者的思想。</p>
<p>但是这段代码并没有受 synchronized 保护，于是便有可能发生以下场景：</p>
<ol>
<li>首先，消费者线程调用 take 方法并判断 buffer.isEmpty 方法是否返回 true，若为 true 代表buffer是空的，则线程希望进入等待，但是在线程调用 wait 方法之前，就被调度器暂停了，所以此时还没来得及执行 wait 方法。</li>
<li>此时生产者开始运行，执行了整个 give 方法，它往 buffer 中添加了数据，并执行了 notify 方法，但 notify 并没有任何效果，因为消费者线程的 wait 方法没来得及执行，所以没有线程在等待被唤醒。</li>
<li>此时，刚才被调度器暂停的消费者线程回来继续执行 wait 方法并进入了等待。</li>
</ol>
<p>虽然刚才消费者判断了 buffer.isEmpty 条件，但真正执行 wait 方法时，之前的 buffer.isEmpty 的结果已经过期了，不再符合最新的场景了，因为这里的“判断-执行”不是一个原子操作，它在中间被打断了，是线程不安全的。</p>
<p>假设这时没有更多的生产者进行生产，消费者便有可能陷入无穷无尽的等待，因为它错过了刚才 give 方法内的 notify 的唤醒。</p>
<p>我们看到正是因为 wait 方法所在的 take 方法没有被 synchronized 保护，所以它的 while 判断和 wait 方法无法构成原子操作，那么此时整个程序就很容易出错。</p>
<p>我们把代码改写成源码注释所要求的被 synchronized 保护的同步代码块的形式，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">give</span><span class="params">(String data)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        buffer.add(data);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (buffer.isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以确保 notify 方法永远不会在 buffer.isEmpty 和 wait 方法之间被调用，提升了程序的安全性。</p>
<p>另外，wait 方法会释放 monitor 锁，这也要求我们必须首先进入到 synchronized 内持有这把锁。</p>
<p>这里还存在一个“虚假唤醒”（spurious wakeup）的问题，线程可能在既没有被notify&#x2F;notifyAll，也没有被中断或者超时的情况下被唤醒，这种唤醒是我们不希望看到的。虽然在实际生产中，虚假唤醒发生的概率很小，但是程序依然需要保证在发生虚假唤醒的时候的正确性，所以就需要采用while循环的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition does not hold)</span><br><span class="line">    obj.wait();</span><br></pre></td></tr></table></figure>

<p>这样即便被虚假唤醒了，也会再次检查while里面的条件，如果不满足条件，就会继续wait，也就消除了虚假唤醒的风险。</p>
<h4 id="为什么-wait-x2F-notify-x2F-notifyAll-被定义在-Object-类中，而-sleep-定义在-Thread-类中？"><a href="#为什么-wait-x2F-notify-x2F-notifyAll-被定义在-Object-类中，而-sleep-定义在-Thread-类中？" class="headerlink" title="为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？"></a>为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</h4><p>我们来看第二个问题，为什么 wait&#x2F;notify&#x2F;notifyAll 方法被定义在 Object 类中？而 sleep 方法定义在 Thread 类中？主要有两点原因：</p>
<ol>
<li>因为 Java 中每个对象都有一把称之为 monitor 监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait&#x2F;notify&#x2F;notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。</li>
<li>因为如果把 wait&#x2F;notify&#x2F;notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。</li>
</ol>
<h4 id="wait-x2F-notify-和-sleep-方法的异同？"><a href="#wait-x2F-notify-和-sleep-方法的异同？" class="headerlink" title="wait&#x2F;notify 和 sleep 方法的异同？"></a>wait&#x2F;notify 和 sleep 方法的异同？</h4><p>第三个问题是对比 wait&#x2F;notify 和 sleep 方法的异同，主要对比 wait 和 sleep 方法，我们先说相同点：</p>
<ol>
<li>它们都可以让线程阻塞。</li>
<li>它们都可以响应 interrupt 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。</li>
</ol>
<p>但是它们也有很多的不同点：</p>
<ol>
<li>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</li>
<li>在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。</li>
<li>sleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。</li>
<li>wait&#x2F;notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</li>
</ol>
<p>以上就是关于 wait&#x2F;notify 与 sleep 的异同点。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>lock</tag>
        <tag>wait</tag>
        <tag>notify</tag>
      </tags>
  </entry>
  <entry>
    <title>02 如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？</title>
    <url>/2022/11/30/tech/java/concurrent/02/</url>
    <content><![CDATA[<p>在本课时我们主要学习如何正确停止一个线程？以及为什么用 volatile 标记位的停止方法是错误的？</p>
<p>首先，我们来复习如何启动一个线程，想要启动线程需要调用 Thread 类的 start() 方法，并在 run() 方法中定义需要执行的任务。启动一个线程非常简单，但如果想要正确停止它就没那么容易了。</p>
<span id="more"></span>

<h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>通常情况下，我们不会手动停止一个线程，而是允许线程运行到结束，然后让它自然停止。但是依然会有许多特殊的情况需要我们提前停止线程，比如：用户突然关闭程序，或程序运行出错重启等。</p>
<p>在这种情况下，即将停止的线程在很多业务场景下仍然很有价值。尤其是我们想写一个健壮性很好，能够安全应对各种场景的程序时，正确停止线程就显得格外重要。但是Java 并没有提供简单易用，能够直接安全停止线程的能力。</p>
<h4 id="为什么不强制停止？而是通知、协作"><a href="#为什么不强制停止？而是通知、协作" class="headerlink" title="为什么不强制停止？而是通知、协作"></a>为什么不强制停止？而是通知、协作</h4><p>对于 Java 而言，最正确的停止线程的方式是使用 interrupt。但 interrupt 仅仅起到通知被停止线程的作用。而对于被停止的线程而言，它拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。那么为什么 Java 不提供强制停止线程的能力呢？</p>
<p>事实上，Java 希望程序间能够相互通知、相互协作地管理线程，因为如果不了解对方正在做的工作，贸然强制停止线程就可能会造成一些安全的问题，为了避免造成问题就需要给对方一定的时间来整理收尾工作。比如：线程正在写入一个文件，这时收到终止信号，它就需要根据自身业务判断，是选择立即停止，还是将整个文件写入成功后停止，而如果选择立即停止就可能造成数据不完整，不管是中断命令发起者，还是接收者都不希望数据出现问题。</p>
<h4 id="如何用-interrupt-停止线程"><a href="#如何用-interrupt-停止线程" class="headerlink" title="如何用 interrupt 停止线程"></a>如何用 interrupt 停止线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明白 Java 停止线程的设计原则之后，我们看看如何用代码实现停止线程的逻辑。我们一旦调用某个线程的 interrupt() 之后，这个线程的中断标记位就会被设置成 true。每个线程都有这样的标记位，当线程执行时，应该定期检查这个标记位，如果标记位被设置成 true，就说明有程序想终止该线程。回到源码，可以看到在 while 循环体判断语句中，首先通过 Thread.currentThread().isInterrupt() 判断线程是否被中断，随后检查是否还有工作要做。&amp;&amp; 逻辑表示只有当两个判断条件同时满足的情况下，才会去执行下面的工作。</p>
<p>我们再看看具体例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">StopThread</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 StopThread 类的 run() 方法中，首先判断线程是否被中断，然后判断 count 值是否小于 1000。这个线程的工作内容很简单，就是打印 0~999 的数字，每打印一个数字 count 值加 1，可以看到，线程会在每次循环开始之前，检查是否被中断了。接下来在 main 函数中会启动该线程，然后休眠 5 毫秒后立刻中断线程，该线程会检测到中断信号，于是在还没打印完1000个数的时候就会停下来，这种就属于通过 interrupt 正确停止线程的情况。</p>
<h4 id="sleep-期间能否感受到中断"><a href="#sleep-期间能否感受到中断" class="headerlink" title="sleep 期间能否感受到中断"></a>sleep 期间能否感受到中断</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            num++;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么我们考虑一种特殊情况，改写上面的代码，如果线程在执行任务期间有休眠需求，也就是每打印一个数字，就进入一次 sleep ，而此时将 Thread.sleep() 的休眠时间设置为 1000 秒钟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopDuringSleep</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                    System.out.println(num);</span><br><span class="line">                    num++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程休眠 5 毫秒后，通知子线程中断，此时子线程仍在执行 sleep 语句，处于休眠中。那么就需要考虑一点，在休眠中的线程是否能够感受到中断通知呢？是否需要等到休眠结束后才能中断线程呢？如果是这样，就会带来严重的问题，因为响应中断太不及时了。正因为如此，Java 设计者在设计之初就考虑到了这一点。</p>
<p>如果 sleep、wait 等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。</p>
<h4 id="两种最佳处理方式"><a href="#两种最佳处理方式" class="headerlink" title="两种最佳处理方式"></a>两种最佳处理方式</h4><p>在实际开发中肯定是团队协作的，不同的人负责编写不同的方法，然后相互调用来实现整个业务的逻辑。那么如果我们负责编写的方法需要被别人调用，同时我们的方法内调用了 sleep 或者 wait 等能响应中断的方法时，仅仅 catch 住异常是不够的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">subTas</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 在这里不处理该异常是非常不好的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在方法中使用 try&#x2F;catch 或在方法签名中声明 throws InterruptedException。</p>
<h4 id="方法签名抛异常，run-强制-try-x2F-catch"><a href="#方法签名抛异常，run-强制-try-x2F-catch" class="headerlink" title="方法签名抛异常，run() 强制 try&#x2F;catch"></a>方法签名抛异常，run() 强制 try&#x2F;catch</h4><p>我们先来看下 try&#x2F;catch 的处理逻辑。如上面的代码所示，catch 语句块里代码是空的，它并没有进行任何处理。假设线程执行到这个方法，并且正在 sleep，此时有线程发送 interrupt 通知试图中断线程，就会立即抛出异常，并清除中断信号。抛出的异常被 catch 语句块捕捉。</p>
<p>但是，捕捉到异常的 catch 没有进行任何处理逻辑，相当于把中断信号给隐藏了，这样做是非常不合理的，那么究竟应该怎么处理呢？首先，可以选择在方法签名中抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">subTask2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如代码所示，要求每一个方法的调用方有义务去处理异常。调用方要不使用 try&#x2F;catch 并在 catch 中正确处理异常，要不将异常声明到方法签名中。如果每层逻辑都遵守规范，便可以将中断信号层层传递到顶层，最终让 run() 方法可以捕获到异常。而对于 run() 方法而言，它本身没有抛出 checkedException 的能力，只能通过 try&#x2F;catch 来处理异常。层层传递异常的逻辑保障了异常不会被遗漏，而对 run() 方法而言，就可以根据不同的业务逻辑来进行相应的处理。</p>
<h4 id="再次中断"><a href="#再次中断" class="headerlink" title="再次中断"></a>再次中断</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了刚才推荐的将异常声明到方法签名中的方式外，还可以在 catch 语句中再次中断线程。如代码所示，需要在 catch 语句块中调用 Thread.currentThread().interrupt() 函数。因为如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时手动添加中断信号，中断信号依然可以被捕捉到。这样后续执行的方法依然可以检测到这里发生过中断，可以做出相应的处理，整个线程可以正常退出。</p>
<p>我们需要注意，我们在实际开发中不能盲目吞掉中断，如果不在方法签名中声明，也不在 catch 语句块中再次恢复中断，而是在 catch 中不作处理，我们称这种行为是“屏蔽了中断请求”。如果我们盲目地屏蔽了中断请求，会导致中断信号被完全忽略，最终导致线程无法正确停止。</p>
<h4 id="为什么用-volatile-标记位的停止方法是错误的"><a href="#为什么用-volatile-标记位的停止方法是错误的" class="headerlink" title="为什么用 volatile 标记位的停止方法是错误的"></a>为什么用 volatile 标记位的停止方法是错误的</h4><p>下面我们来看一看本课时的第二个问题，为什么用 volatile 标记位的停止方法是错误的？</p>
<h5 id="错误的停止方法"><a href="#错误的停止方法" class="headerlink" title="错误的停止方法"></a>错误的停止方法</h5><p>首先，我们来看几种停止线程的错误方法。比如 stop()，suspend() 和 resume()，这些方法已经被 Java 直接标记为 @Deprecated。如果再调用这些方法，IDE 会友好地提示，我们不应该再使用它们了。但为什么它们不能使用了呢？是因为 stop() 会直接把线程停止，这样就没有给线程足够的时间来处理想要在停止前保存数据的逻辑，任务戛然而止，会导致出现数据完整性等问题。</p>
<p>而对于 suspend() 和 resume() 而言，它们的问题在于如果线程调用 suspend()，它并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，这样就容易导致死锁问题，因为这把锁在线程被 resume() 之前，是不会被释放的。</p>
<p>假设线程 A 调用了 suspend() 方法让线程 B 挂起，线程 B 进入休眠，而线程 B 又刚好持有一把锁，此时假设线程 A 想访问线程 B 持有的锁，但由于线程 B 并没有释放锁就进入休眠了，所以对于线程 A 而言，此时拿不到锁，也会陷入阻塞，那么线程 A 和线程 B 就都无法继续向下执行。</p>
<p>正是因为有这样的风险，所以 suspend() 和 resume() 组合使用的方法也被废弃了。那么接下来我们来看看，为什么用 volatile 标记位的停止方法也是错误的？</p>
<h5 id="volatile-修饰标记位适用的场景"><a href="#volatile-修饰标记位适用的场景" class="headerlink" title="volatile 修饰标记位适用的场景"></a>volatile 修饰标记位适用的场景</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCanStop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!canceled &amp;&amp; num &lt;= <span class="number">1000000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是10的倍数。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">VolatileCanStop</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileCanStop</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        r.canceled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么场景下 volatile 修饰标记位可以让线程正常停止呢？如代码所示，声明了一个叫作 VolatileStopThread 的类， 它实现了 Runnable 接口，然后在 run() 中进行 while 循环，在循环体中又进行了两层判断，首先判断 canceled 变量的值，canceled 变量是一个被 volatile 修饰的初始值为 false 的布尔值，当该值变为 true 时，while 跳出循环，while 的第二个判断条件是 num 值小于1000000（一百万），在while 循环体里，只要是 10 的倍数就打印出来，然后 num++。</p>
<p>接下来，首先启动线程，然后经过 3 秒钟的时间，把用 volatile 修饰的布尔值的标记位设置成 true，这样，正在运行的线程就会在下一次 while 循环中判断出 canceled 的值已经变成 true 了，这样就不再满足 while 的判断条件，跳出整个 while 循环，线程就停止了，这种情况是演示 volatile 修饰的标记位可以正常工作的情况，但是如果我们说某个方法是正确的，那么它应该不仅仅是在一种情况下适用，而在其他情况下也应该是适用的。</p>
<h5 id="volatile-修饰标记位不适用的场景"><a href="#volatile-修饰标记位不适用的场景" class="headerlink" title="volatile 修饰标记位不适用的场景"></a>volatile 修饰标记位不适用的场景</h5><p>接下来我们就用一个生产者&#x2F;消费者模式的案例来演示为什么说 volatile 标记位的停止方法是不完美的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是50的倍数,被放到仓库中了。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者结束运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，声明了一个生产者 Producer，通过 volatile 标记的初始值为 false 的布尔值 canceled 来停止线程。而在 run() 方法中，while 的判断语句是 num 是否小于 100000 及 canceled 是否被标记。while 循环体中判断 num 如果是 50 的倍数就放到 storage 仓库中，storage 是生产者与消费者之间进行通信的存储器，当 num 大于 100000 或被通知停止时，会跳出 while 循环并执行 finally 语句块，告诉大家“生产者结束运行”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">needMoreNums</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.97</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于消费者 Consumer，它与生产者共用同一个仓库 storage，并且在方法内通过 needMoreNums() 方法判断是否需要继续使用更多的数字，刚才生产者生产了一些 50 的倍数供消费者使用，消费者是否继续使用数字的判断条件是产生一个随机数并与 0.97 进行比较，大于 0.97 就不再继续使用数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(producer);</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(storage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了。&quot;</span>);</span><br><span class="line">        <span class="comment">//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来</span></span><br><span class="line">        producer.canceled = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下 main 函数，首先创建了生产者&#x2F;消费者共用的仓库 BlockingQueue storage，仓库容量是 8，并且建立生产者并将生产者放入线程后启动线程，启动后进行 500 毫秒的休眠，休眠时间保障生产者有足够的时间把仓库塞满，而仓库达到容量后就不会再继续往里塞，这时生产者会阻塞，500 毫秒后消费者也被创建出来，并判断是否需要使用更多的数字，然后每次消费后休眠 100 毫秒，这样的业务逻辑是有可能出现在实际生产中的。</p>
<p>当消费者不再需要数据，就会将 canceled 的标记位设置为 true，理论上此时生产者会跳出 while 循环，并打印输出“生产者运行结束”。</p>
<p>然而结果却不是我们想象的那样，尽管已经把 canceled 设置成 true，但生产者仍然没有停止，这是因为在这种情况下，生产者在执行 storage.put(num) 时发生阻塞，在它被叫醒之前是没有办法进入下一次循环判断 canceled 的值的，所以在这种情况下用 volatile 是没有办法让生产者停下来的，相反如果用 interrupt 语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做响应处理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>好了，本课时的内容就全部讲完了，我们来总结下学到了什么，首先学习了如何正确停止线程，其次是掌握了为什么说 volatile 修饰标记位停止方法是错误的。</p>
<p>如果我们在面试中被问到“你知不知道如何正确停止线程”这样的问题，我想你一定可以完美地回答了，首先，从原理上讲应该用 interrupt 来请求中断，而不是强制停止，因为这样可以避免数据错乱，也可以让线程有时间结束收尾工作。</p>
<p>如果我们是子方法的编写者，遇到了 interruptedException，应该如何处理呢？</p>
<p>我们可以把异常声明在方法中，以便顶层方法可以感知捕获到异常，或者也可以在 catch 中再次声明中断，这样下次循环也可以感知中断，所以要想正确停止线程就要求我们停止方，被停止方，子方法的编写者相互配合，大家都按照一定的规范来编写代码，就可以正确地停止线程了。</p>
<p>最后我们再来看下有哪些方法是不够好的，比如说已经被舍弃的 stop()、suspend() 和 resume()，它们由于有很大的安全风险比如死锁风险而被舍弃，而 volatile 这种方法在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断，所以 volatile 是不够全面的停止线程的方法。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>thread</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>06 一共有哪 3 类线程安全问题？</title>
    <url>/2022/12/06/tech/java/concurrent/06/</url>
    <content><![CDATA[<p>本课时我们学习 3 类线程安全问题。</p>
<span id="more"></span>

<h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><p>要想弄清楚有哪 3 类线程安全问题，首先需要了解什么是线程安全，线程安全经常在工作中被提到，比如：你的对象不是线程安全的，你的线程发生了安全错误，虽然线程安全经常被提到，但我们可能对线程安全并没有一个明确的定义。</p>
<p>《Java Concurrency In Practice》的作者 Brian Goetz 对线程安全是这样理解的，当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行问题，也不需要进行额外的同步，而调用这个对象的行为都可以获得正确的结果，那这个对象便是线程安全的。</p>
<p>事实上，Brian Goetz 想表达的意思是，如果某个对象是线程安全的，那么对于使用者而言，在使用时就不需要考虑方法间的协调问题，比如不需要考虑不能同时写入或读写不能并行的问题，也不需要考虑任何额外的同步问题，比如不需要额外自己加 synchronized 锁，那么它才是线程安全的，可以看出对线程安全的定义还是非常苛刻的。</p>
<p>而我们在实际开发中经常会遇到线程不安全的情况，那么一共有哪 3 种典型的线程安全问题呢？</p>
<ol>
<li>运行结果错误；</li>
<li>发布和初始化导致线程安全问题；</li>
<li>活跃性问题。</li>
</ol>
<h4 id="运行结果错误"><a href="#运行结果错误" class="headerlink" title="运行结果错误"></a>运行结果错误</h4><p>首先，来看多线程同时操作一个变量导致的运行结果错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongResult</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，首先定义了一个 int 类型的静态变量 i，然后启动两个线程，分别对变量 i 进行 10000 次 i++ 操作。理论上得到的结果应该是 20000，但实际结果却远小于理论结果，比如可能是12996，也可能是13323，每次的结果都还不一样，这是为什么呢？</p>
<p>是因为在多线程下，CPU 的调度是以时间片为单位进行分配的，每个线程都可以得到一定量的时间片。但如果线程拥有的时间片耗尽，它将会被暂停执行并让出 CPU 资源给其他线程，这样就有可能发生线程安全问题。比如 i++ 操作，表面上看只是一行代码，但实际上它并不是一个原子操作，它的执行步骤主要分为三步，而且在每步操作之间都有可能被打断。</p>
<ul>
<li>第一个步骤是读取；</li>
<li>第二个步骤是增加；</li>
<li>第三个步骤是保存。</li>
</ul>
<p>那么我们接下来看如何发生的线程不安全问题。</p>
<img data-src="/2022/12/06/tech/java/concurrent/06/c_06_01.png" class="">

<p>我们根据箭头指向依次看，线程 1 首先拿到 i&#x3D;1 的结果，然后进行 i+1 操作，但此时 i+1 的结果并没有保存下来，线程 1 就被切换走了，于是 CPU 开始执行线程 2，它所做的事情和线程 1 是一样的 i++ 操作，但此时我们想一下，它拿到的 i 是多少？实际上和线程 1 拿到的 i 的结果一样都是 1，为什么呢？因为线程 1 虽然对 i 进行了 +1 操作，但结果没有保存，所以线程 2 看不到修改后的结果。</p>
<p>然后假设等线程 2 对 i 进行 +1 操作后，又切换到线程 1，让线程 1 完成未完成的操作，即将 i+1 的结果 2 保存下来，然后又切换到线程 2 完成 i&#x3D;2 的保存操作，虽然两个线程都执行了对 i 进行 +1 的操作，但结果却最终保存了 i&#x3D;2 的结果，而不是我们期望的 i&#x3D;3，这样就发生了线程安全问题，导致了数据结果错误，这也是最典型的线程安全问题。</p>
<h4 id="发布和初始化导致线程安全问题"><a href="#发布和初始化导致线程安全问题" class="headerlink" title="发布和初始化导致线程安全问题"></a>发布和初始化导致线程安全问题</h4><p>第二种是对象发布和初始化时导致的线程安全问题，我们创建对象并进行发布和初始化供其他类或对象使用是常见的操作，但如果我们操作的时间或地点不对，就可能导致线程安全问题。如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongInit</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrongInit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                students = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                students.put(<span class="number">1</span>, <span class="string">&quot;王小美&quot;</span>);</span><br><span class="line">                students.put(<span class="number">2</span>, <span class="string">&quot;钱二宝&quot;</span>);</span><br><span class="line">                students.put(<span class="number">3</span>, <span class="string">&quot;周三&quot;</span>);</span><br><span class="line">                students.put(<span class="number">4</span>, <span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">WrongInit</span> <span class="variable">multiThreadsError6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WrongInit</span>();</span><br><span class="line">        System.out.println(multiThreadsError6.getStudents().get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类中，定义一个类型为 Map 的成员变量 students，Integer 是学号，String 是姓名。然后在构造函数中启动一个新线程，并在线程中为 students 赋值。</p>
<ul>
<li>学号：1，姓名：王小美；</li>
<li>学号：2，姓名：钱二宝；</li>
<li>学号：3，姓名：周三；</li>
<li>学号：4，姓名：赵四。</li>
</ul>
<p>只有当线程运行完 run() 方法中的全部赋值操作后，4 名同学的全部信息才算是初始化完毕，可是我们看在主函数 mian() 中，初始化 WrongInit 类之后并没有进行任何休息就直接打印 1 号同学的信息，试想这个时候程序会出现什么情况？实际上会发生空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line"></span><br><span class="line">at lesson6.WrongInit.main(WrongInit.java:<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<p>这又是为什么呢？因为 students 这个成员变量是在构造函数中新建的线程中进行的初始化和赋值操作，而线程的启动需要一定的时间，但是我们的 main 函数并没有进行等待就直接获取数据，导致 getStudents 获取的结果为 null，这就是在错误的时间或地点发布或初始化造成的线程安全问题。</p>
<h4 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h4><p>第三种线程安全问题统称为活跃性问题，最典型的有三种，分别为死锁、活锁和饥饿。</p>
<p>什么是活跃性问题呢，活跃性问题就是程序始终得不到运行的最终结果，相比于前面两种线程安全问题带来的数据错误或报错，活跃性问题带来的后果可能更严重，比如发生死锁会导致程序完全卡死，无法向下运行。</p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>最常见的活跃性问题是死锁，死锁是指两个线程之间相互等待对方资源，但同时又互不相让，都想自己先执行，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MayDeadLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1成功拿到两把锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2成功拿到两把锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MayDeadLock</span> <span class="variable">mayDeadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MayDeadLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mayDeadLock.thread1();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mayDeadLock.thread2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，代码中创建了两个 Object 作为 synchronized 锁的对象，线程 1 先获取 o1 锁，sleep(500) 之后，获取 o2 锁；线程 2 与线程 1 执行顺序相反，先获取 o2 锁，sleep(500) 之后，获取 o1 锁。 假设两个线程几乎同时进入休息，休息完后，线程 1 想获取 o2 锁，线程 2 想获取 o1 锁，这时便发生了死锁，两个线程不主动调和，也不主动退出，就这样死死地等待对方先释放资源，导致程序得不到任何结果也不能停止运行。</p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>第二种活跃性问题是活锁，活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果。</p>
<p>举一个例子，假设有一个消息队列，队列里放着各种各样需要被处理的消息，而某个消息由于自身被写错了导致不能被正确处理，执行时会报错，可是队列的重试机制会重新把它放在队列头进行优先重试处理，但这个消息本身无论被执行多少次，都无法被正确处理，每次报错后又会被放到队列头进行重试，周而复始，最终导致线程一直处于忙碌状态，但程序始终得不到结果，便发生了活锁问题。</p>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>第三个典型的活跃性问题是饥饿，饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就有可能始终分配不到 CPU 资源，而导致长时间无法运行。或者是某个线程始终持有某个文件的锁，而其他线程想要修改文件就必须先获取锁，这样想要修改文件的线程就会陷入饥饿，长时间不能运行。</p>
<p>好了，今天的内容就全部讲完了，通过本课时的学习我们知道了线程安全问题主要有 3 种，i++ 等情况导致的运行结果错误，通常是因为并发读写导致的，第二种是对象没有在正确的时间、地点被发布或初始化，而第三种线程安全问题就是活跃性问题，包括死锁、活锁和饥饿。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>07 哪些场景需要额外注意线程安全问题？</title>
    <url>/2022/12/08/tech/java/concurrent/07/</url>
    <content><![CDATA[<p>在本课时我们主要学习哪些场景需要额外注意线程安全问题，在这里总结了四种场景。</p>
<span id="more"></span>

<h4 id="访问共享变量或资源"><a href="#访问共享变量或资源" class="headerlink" title="访问共享变量或资源"></a>访问共享变量或资源</h4><p>第一种场景是访问共享变量或共享资源的时候，典型的场景有访问共享对象的属性，访问 static 静态变量，访问共享的缓存，等等。因为这些信息不仅会被一个线程访问到，还有可能被多个线程同时访问，那么就有可能在并发读写的情况下发生线程安全问题。比如我们上一课时讲过的多线程同时 i++ 的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     共享的变量或资源带来的线程安全问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNotSafe1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，两个线程同时对 i 进行 i++ 操作，最后的输出可能是 15875 等小于20000的数，而不是我们期待的20000，这便是非常典型的共享变量带来的线程安全问题。</p>
<h4 id="依赖时序的操作"><a href="#依赖时序的操作" class="headerlink" title="依赖时序的操作"></a>依赖时序的操作</h4><p>第二个需要我们注意的场景是依赖时序的操作，如果我们操作的正确性是依赖时序的，而在多线程的情况下又不能保障执行的顺序和我们预想的一致，这个时候就会发生线程安全问题，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">    map.remove(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中首先检查 map 中有没有 key 对应的元素，如果有则继续执行 remove 操作。此时，这个组合操作就是危险的，因为它是先检查后操作，而执行过程中可能会被打断。如果此时有两个线程同时进入 if() 语句，然后它们都检查到存在 key 对应的元素，于是都希望执行下面的 remove 操作，随后一个线程率先把 obj 给删除了，而另外一个线程它刚已经检查过存在 key 对应的元素，if 条件成立，所以它也会继续执行删除 obj 的操作，但实际上，集合中的 obj 已经被前面的线程删除了，这种情况下就可能导致线程安全问题。</p>
<p>类似的情况还有很多，比如我们先检查 x&#x3D;1，如果 x&#x3D;1 就修改 x 的值，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">    x = <span class="number">7</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样类似的场景都是同样的道理，“检查与执行”并非原子性操作，在中间可能被打断，而检查之后的结果也可能在执行时已经过期、无效，换句话说，获得正确结果取决于幸运的时序。这种情况下，我们就需要对它进行加锁等保护措施来保障操作的原子性。</p>
<h4 id="不同数据之间存在绑定关系"><a href="#不同数据之间存在绑定关系" class="headerlink" title="不同数据之间存在绑定关系"></a>不同数据之间存在绑定关系</h4><p>第三种需要我们注意的线程安全场景是不同数据之间存在相互绑定关系的情况。有时候，我们的不同数据之间是成组出现的，存在着相互对应或绑定的关系，最典型的就是 IP 和端口号。有时候我们更换了 IP，往往需要同时更换端口号，如果没有把这两个操作绑定在一起，就有可能出现单独更换了 IP 或端口号的情况，而此时信息如果已经对外发布，信息获取方就有可能获取一个错误的 IP 与端口绑定情况，这时就发生了线程安全问题。在这种情况下，我们也同样需要保障操作的原子性。</p>
<h4 id="对方没有声明自己是线程安全的"><a href="#对方没有声明自己是线程安全的" class="headerlink" title="对方没有声明自己是线程安全的"></a>对方没有声明自己是线程安全的</h4><p>第四种值得注意的场景是在我们使用其他类时，如果对方没有声明自己是线程安全的，那么这种情况下对其他类进行多线程的并发操作，就有可能会发生线程安全问题。举个例子，比如说我们定义了 ArrayList，它本身并不是线程安全的，如果此时多个线程同时对 ArrayList 进行并发读&#x2F;写，那么就有可能会产生线程安全问题，造成数据出错，而这个责任并不在 ArrayList，因为它本身并不是并发安全的，正如源码注释所写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Note that <span class="built_in">this</span> implementation is not <span class="keyword">synchronized</span>. If multiple threads</span><br><span class="line">access an ArrayList instance concurrently, and at least one of the threads</span><br><span class="line">modifies the list structurally, it must be <span class="keyword">synchronized</span> externally.</span><br></pre></td></tr></table></figure>

<p>这段话的意思是说，如果我们把 ArrayList 用在了多线程的场景，需要在外部手动用 synchronized 等方式保证并发安全。</p>
<p>所以 ArrayList 默认不适合并发读写，是我们错误地使用了它，导致了线程安全问题。所以，我们在使用其他类时如果会涉及并发场景，那么一定要首先确认清楚，对方是否支持并发操作，以上就是四种需要我们额外注意线程安全问题的场景，分别是访问共享变量或资源，依赖时序的操作，不同数据之间存在绑定关系，以及对方没有声明自己是线程安全的。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>08 为什么多线程会带来性能问题？</title>
    <url>/2022/12/08/tech/java/concurrent/08/</url>
    <content><![CDATA[<p>在本课时我们主要学习为什么多线程会带来性能问题？</p>
<span id="more"></span>


<h3 id="什么是性能问题"><a href="#什么是性能问题" class="headerlink" title="什么是性能问题"></a>什么是性能问题</h3><hr>
<p>在上一课时我们已经学习了多线程带来的线程安全问题，但对于多线程而言，它不仅可能会带来线程安全问题，还有可能会带来性能问题，也许你会奇怪，我们使用多线程的最大目的不就是为了提高性能吗？让多个线程同时工作，加快程序运行速度，为什么反而会带来性能问题呢？这是因为单线程程序是独立工作的，不需要与其他线程进行交互，但多线程之间则需要调度以及合作，调度与合作就会带来性能开销从而产生性能问题。</p>
<p>首先，我们来了解究竟什么是性能问题？其实性能问题有许多的表现形式，比如服务器的响应慢、吞吐量低、内存占用过多就属于性能问题。我们设计优秀的系统架构、购置更多的 CDN 服务器、购买更大的带宽等都是为了提高性能，提高用户体验，虽然运行速度慢不会带来严重的后果，通常只需要我们多等几秒就可以，但这会严重影响用户的体验。有研究表明，页面每多响应 1 秒，就会流失至少 7% 的用户，而超过 8 秒无法返回结果的话，几乎所有用户都不会选择继续等待。我们引入多线程的一大重要原因就是想提高程序性能，所以不能本末倒置，不能因为引入了多线程反而程序运行得更慢了，所以我们必须要解决多线程带来的性能问题。</p>
<h3 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h3><hr>
<p>那么什么情况下多线程编程会带来性能问题呢？主要有两个方面，一方面是线程调度，另一个方面是线程协作。</p>
<h3 id="调度开销"><a href="#调度开销" class="headerlink" title="调度开销"></a>调度开销</h3><hr>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>首先，我们看一下线程调度，在实际开发中，线程数往往是大于 CPU 核心数的，比如 CPU 核心数可能是 8 核、16 核，等等，但线程数可能达到成百上千个。这种情况下，操作系统就会按照一定的调度算法，给每个线程分配时间片，让每个线程都有机会得到运行。而在进行调度时就会引起上下文切换，上下文切换会挂起当前正在执行的线程并保存当前的状态，然后寻找下一处即将恢复执行的代码，唤醒下一个线程，以此类推，反复执行。但上下文切换带来的开销是比较大的，假设我们的任务内容非常短，比如只进行简单的计算，那么就有可能发生我们上下文切换带来的性能开销比执行线程本身内容带来的开销还要大的情况。</p>
<h4 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h4><p>不仅上下文切换会带来性能问题，缓存失效也有可能带来性能问题。由于程序有很大概率会再次访问刚才访问过的数据，所以为了加速整个程序的运行，会使用缓存，这样我们在使用相同数据时就可以很快地获取数据。可一旦进行了线程调度，切换到其他线程，CPU就会去执行不同的代码，原有的缓存就很可能失效了，需要重新缓存新的数据，这也会造成一定的开销，所以线程调度器为了避免频繁地发生上下文切换，通常会给被调度到的线程设置最小的执行时间，也就是只有执行完这段时间之后，才可能进行下一次的调度，由此减少上下文切换的次数。</p>
<p>那么什么情况会导致密集的上下文切换呢？如果程序频繁地竞争锁，或者由于 IO 读写等原因导致频繁阻塞，那么这个程序就可能需要更多的上下文切换，这也就导致了更大的开销，我们应该尽量避免这种情况的发生。</p>
<h3 id="协作开销"><a href="#协作开销" class="headerlink" title="协作开销"></a>协作开销</h3><hr>
<p>除了线程调度之外，线程协作同样也有可能带来性能问题。因为线程之间如果有共享数据，为了避免数据错乱，为了保证线程安全，就有可能禁止编译器和 CPU 对其进行重排序等优化，也可能出于同步的目的，反复把线程工作内存的数据 flush 到主存中，然后再从主内存 refresh 到其他线程的工作内存中，等等。这些问题在单线程中并不存在，但在多线程中为了确保数据的正确性，就不得不采取上述方法，因为线程安全的优先级要比性能优先级更高，这也间接降低了我们的性能。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>性能问题</tag>
      </tags>
  </entry>
  <entry>
    <title>09 使用线程池比手动创建线程好在哪里？</title>
    <url>/2022/12/08/tech/java/concurrent/09/</url>
    <content><![CDATA[<p>在本课时我们主要学习为什么使用线程池比手动创建线程要好，并讲解具体好在哪里？</p>
<span id="more"></span>

<h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h4><p>首先，回顾线程池的相关知识，在 Java 诞生之初是没有线程池的概念的，而是先有线程，随着线程数的不断增加，人们发现需要一个专门的类来管理它们，于是才诞生了线程池。没有线程池的时候，每发布一个任务就需要创建一个新的线程，这样在任务少时是没有问题的，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 描述：     单个任务的时候，新建线程来执行 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneTask</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        thread0.start();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">           System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们发布了一个新的任务并放入子线程中，然后启动子线程执行任务，这时的任务也非常简单，只是打印出当前线程的名字，这种情况下，打印结果显示 Thread Name: Thread-0，即我们当前子线程的默认名字。</p>
<img data-src="/2022/12/08/tech/java/concurrent/09/c_09_01.png" class="">

<p>我们来看一下任务执行流程，如图所示，主线程调用 start() 方法，启动了一个 t0 的子线程。这是在一个任务的场景下，随着我们的任务增多，比如现在有 10 个任务了，那么我们就可以使用 for 循环新建 10 个子线程，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 描述：     for循环新建10个线程 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenTask</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread Name: Thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">4</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">7</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">Thread Name: Thread-<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>这里你会发现，打印出来的顺序是错乱的，比如 Thread-4 打印在了 Thread-3 之前，这是因为，虽然 Thread-3 比 Thread-4 先执行 start 方法，但是这并不代表 Thread-3 就会先运行，运行的顺序取决于线程调度器，有很大的随机性，这是需要我们注意的地方。</p>
<img data-src="/2022/12/08/tech/java/concurrent/09/c_09_02.png" class="">

<p>我们再看来下线程的执行流程，如图所示，主线程通过 for 循环创建了 t0~t9 这 10 个子线程，它们都可以正常的执行任务，但如果此时我们的任务量突然飙升到 10000 会怎么样？我们先来看看依然用 for 循环的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示，我们创建了 10000 个子线程，而 Java 程序中的线程与操作系统中的线程是一一对应的，此时假设线程中的任务需要一定的耗时才能够完成，便会产生很大的系统开销与资源浪费。</p>
<img data-src="/2022/12/08/tech/java/concurrent/09/c_09_03.png" class="">

<p>创建线程时会产生系统开销，并且每个线程还会占用一定的内存等资源，更重要的是我们创建如此多的线程也会给稳定性带来危害，因为每个系统中，可创建线程的数量是有一个上限的，不可能无限的创建。线程执行完需要被回收，大量的线程又会给垃圾回收带来压力。但我们的任务确实非常多，如果都在主线程串行执行，那效率也太低了，那应该怎么办呢？于是便诞生了线程池来平衡线程与系统资源之间的关系。</p>
<p>我们来总结下如果每个任务都创建一个线程会带来哪些问题：</p>
<ol>
<li>第一点，反复创建线程系统开销比较大，每个线程创建和销毁都需要时间，如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。</li>
<li>第二点，过多的线程会占用过多的内存等资源，还会带来过多的上下文切换，同时还会导致系统不稳定。</li>
</ol>
<h4 id="线程池解决问题思路"><a href="#线程池解决问题思路" class="headerlink" title="线程池解决问题思路"></a>线程池解决问题思路</h4><p>针对上面的两点问题，线程池有两个解决思路。</p>
<p>首先，针对反复创建线程开销大的问题，线程池用一些固定的线程一直保持工作状态并反复执行任务。</p>
<p>其次，针对过多线程占用太多内存资源的问题，解决思路更直接，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。</p>
<h4 id="如何使用线程池"><a href="#如何使用线程池" class="headerlink" title="如何使用线程池"></a>如何使用线程池</h4><p>线程池就好比一个池塘，池塘里的水是有限且可控的，比如我们选择线程数固定数量的线程池，假设线程池有 5 个线程，但此时的任务大于 5 个，线程池会让余下的任务进行排队，而不是无限制的扩张线程数量，保障资源不会被过度消耗。如代码所示，我们往 5 个线程的线程池中放入 10000 个任务并打印当前线程名字，结果会是怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 描述：     用固定线程数的线程池执行10000个任务 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">            service.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;Thread Name: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Thread Name: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如打印结果所示，打印的线程名始终在 Thread Name: pool-1-thread-1~5 之间变化，并没有超过这个范围，也就证明了线程池不会无限制地扩张线程的数量，始终是这5个线程在工作。</p>
<img data-src="/2022/12/08/tech/java/concurrent/09/c_09_04.png" class="">

<p>执行流程如图所示，首先创建了一个线程池，线程池中有 5 个线程，然后线程池将 10000 个任务分配给这 5 个线程，这 5 个线程反复领取任务并执行，直到所有任务执行完毕，这就是线程池的思想。</p>
<h4 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h4><p>使用线程池比手动创建线程主要有三点好处。</p>
<ol>
<li>第一点，线程池可以解决线程生命周期的系统开销问题，同时还可以加快响应速度。因为线程池中的线程是可以复用的，我们只用少量的线程去执行大量的任务，这就大大减小了线程生命周期的开销。而且线程通常不是等接到任务后再临时创建，而是已经创建好时刻准备执行任务，这样就消除了线程创建所带来的延迟，提升了响应速度，增强了用户体验。</li>
<li>第二点，线程池可以统筹内存和 CPU 的使用，避免资源使用不当。线程池会根据配置和任务数量灵活地控制线程数量，不够的时候就创建，太多的时候就回收，避免线程过多导致内存溢出，或线程太少导致 CPU 资源浪费，达到了一个完美的平衡。</li>
<li>第三点，线程池可以统一管理资源。比如线程池可以统一管理任务队列和线程，可以统一开始或结束任务，比单个线程逐一处理任务要更方便、更易于管理，同时也有利于数据统计，比如我们可以很方便地统计出已经执行过的任务的数量。</li>
</ol>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>10 线程池的各个参数的含义？</title>
    <url>/2022/12/08/tech/java/concurrent/10/</url>
    <content><![CDATA[<p>本课时我们主要学习线程池各个参数的含义，并重点掌握线程池中线程是在什么时机被创建和销毁的。</p>
<span id="more"></span>


<h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h3><hr>
<img data-src="/2022/12/08/tech/java/concurrent/10/c_10_01.png" class="">

<p>首先，我们来看下线程池中各个参数的含义，如表所示线程池主要有 6 个参数，其中第 3 个参数由 keepAliveTime + 时间单位组成。我们逐一看下它们各自的含义，corePoolSize 是核心线程数，也就是常驻线程池的线程数量，与它对应的是 maximumPoolSize，表示线程池最大线程数量，当我们的任务特别多而 corePoolSize 核心线程数无法满足需求的时候，就会向线程池中增加线程，以便应对任务突增的情况。</p>
<h3 id="线程创建的时机"><a href="#线程创建的时机" class="headerlink" title="线程创建的时机"></a>线程创建的时机</h3><hr>
<img data-src="/2022/12/08/tech/java/concurrent/10/c_10_02.png" class="">

<p>接下来，我们来具体看下这两个参数所代表的含义，以及线程池中创建线程的时机。如上图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。</p>
<p>此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maximumPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maximumPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize、workQueue、maximumPoolSize，如果依然不能满足需求，则会拒绝任务。</p>
<h3 id="corePoolSize-与-maximumPoolSize"><a href="#corePoolSize-与-maximumPoolSize" class="headerlink" title="corePoolSize 与 maximumPoolSize"></a>corePoolSize 与 maximumPoolSize</h3><hr>
<p>通过上面的流程图，我们了解了 corePoolSize 和 maximumPoolSize 的具体含义，corePoolSize 指的是核心线程数，线程池初始化时线程数默认为 0，当有新的任务提交后，会创建新线程执行任务，如果不做特殊设置，此后线程数通常不会再小于 corePoolSize ，因为它们是核心线程，即便未来可能没有可执行的任务也不会被销毁。随着任务量的增加，在任务队列满了之后，线程池会进一步创建新线程，最多可以达到 maximumPoolSize 来应对任务多的场景，如果未来线程有空闲，大于 corePoolSize 的线程会被合理回收。所以正常情况下，线程池中的线程数量会处在 corePoolSize 与 maximumPoolSize 的闭区间内。</p>
<h3 id="“长工”与“临时工”"><a href="#“长工”与“临时工”" class="headerlink" title="“长工”与“临时工”"></a>“长工”与“临时工”</h3><hr>
<p>我们可以把 corePoolSize 与 maximumPoolSize 比喻成长工与临时工，通常古代一个大户人家会有几个固定的长工，负责日常的工作，而大户人家起初肯定也是从零开始雇佣长工的。假如长工数量被老爷设定为 5 人，也就对应了 corePoolSize，不管这 5 个长工是忙碌还是空闲，都会一直在大户人家待着，可到了农忙或春节，长工的人手显然就不够用了，这时就需要雇佣更多的临时工，这些临时工就相当于在 corePoolSize 的基础上继续创建新线程，但临时工也是有上限的，也就对应了 maximumPoolSize，随着农忙或春节结束，老爷考虑到人工成本便会解约掉这些临时工，家里工人数量便会从 maximumPoolSize 降到 corePoolSize，所以老爷家的工人数量会一致保持在 corePoolSize 和 maximumPoolSize 的区间。</p>
<img data-src="/2022/12/08/tech/java/concurrent/10/c_10_03.gif" class="">

<p>在这里我们用一个动画把整个线程池变化过程生动地描述出来，比如线程池的 corePoolSize 为 5，maximumPoolSize 为 10，任务队列容量为 100，随着任务被提交，我们的线程数量会从 0 慢慢增长到 5，然后就不再增长了，新的任务会被放入队列中，直到队列被塞满，然后在 corePoolSize 的基础上继续创建新线程来执行队列中的任务，线程会逐渐增加到 maximumPoolSize， 然后线程数不再增加，如果此时仍有任务被不断提交，线程池就会拒绝任务。随着队列中任务被执行完，被创建的 10 个线程现在无事可做了，这时线程池会根据 keepAliveTime 参数来销毁线程，已达到减少内存占用的目的。</p>
<p>通过对流程图的理解和动画演示，我们总结出线程池的几个特点。</p>
<ul>
<li>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加线程。</li>
<li>线程池只有在任务队列填满时才创建多于 corePoolSize 的线程，如果使用的是无界队列（例如 LinkedBlockingQueue），那么由于队列不会满，所以线程数不会超过 corePoolSize。</li>
<li>通过设置 corePoolSize 和 maximumPoolSize 为相同的值，就可以创建固定大小的线程池。</li>
<li>通过设置 maximumPoolSize 为很高的值，例如 Integer.MAX_VALUE，就可以允许线程池创建任意多的线程。</li>
</ul>
<h3 id="keepAliveTime-时间单位"><a href="#keepAliveTime-时间单位" class="headerlink" title="keepAliveTime+时间单位"></a>keepAliveTime+时间单位</h3><hr>
<p>第三个参数是 keepAliveTime + 时间单位，当线程池中线程数量多于核心线程数时，而此时又没有任务可做，线程池就会检测线程的 keepAliveTime，如果超过规定的时间，无事可做的线程就会被销毁，以便减少内存的占用和资源消耗。如果后期任务又多了起来，线程池也会根据规则重新创建线程，所以这是一个可伸缩的过程，比较灵活，我们也可以用 setKeepAliveTime 方法动态改变 keepAliveTime 的参数值。</p>
<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><hr>
<p>第四个参数是 ThreadFactory，ThreadFactory 实际上是一个线程工厂，它的作用是生产线程以便执行任务。我们可以选择使用默认的线程工厂，创建的线程都会在同一个线程组，并拥有一样的优先级，且都不是守护线程，我们也可以选择自己定制线程工厂，以方便给线程自定义命名，不同的线程池内的线程通常会根据具体业务来定制不同的线程名。</p>
<h3 id="workQueue-和-Handler"><a href="#workQueue-和-Handler" class="headerlink" title="workQueue 和 Handler"></a>workQueue 和 Handler</h3><hr>
<p>最后两个参数是 workQueue 和 Handler，它们分别对应阻塞队列和任务拒绝策略，在后面的课时会对它们进行详细展开讲解。</p>
<p>在本课时，介绍了线程池的各个参数的含义，以及如果有任务提交，线程池是如何应对的，新线程是在什么时机下被创建和销毁等内容，你有没有觉得线程池的设计很巧妙呢？</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>11 线程池有哪 4 种拒绝策略？</title>
    <url>/2022/12/09/tech/java/concurrent/11/</url>
    <content><![CDATA[<p>本课时我们主要学习线程池有哪 4 种默认的拒绝策略。</p>
<span id="more"></span>

<h4 id="拒绝时机"><a href="#拒绝时机" class="headerlink" title="拒绝时机"></a>拒绝时机</h4><p>首先，新建线程池时可以指定它的任务拒绝策略，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br></pre></td></tr></table></figure>

<p>以便在必要的时候按照我们的策略来拒绝任务，那么拒绝任务的时机是什么呢？线程池会在以下两种情况下会拒绝新提交的任务。</p>
<ul>
<li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li>
<li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li>
</ul>
<p>我们具体讲一下第二种情况，也就是由于工作饱和导致的拒绝。比如新建一个线程池，使用容量上限为 10 的 ArrayBlockingQueue 作为任务队列，并且指定线程池的核心线程数为 5，最大线程数为 10，假设此时有 20 个耗时任务被提交，在这种情况下，线程池会首先创建核心数量的线程，也就是5个线程来执行任务，然后往队列里去放任务，队列的 10 个容量被放满了之后，会继续创建新线程，直到达到最大线程数 10。此时线程池中一共有 20 个任务，其中 10 个任务正在被 10 个线程执行，还有 10 个任务在任务队列中等待，而且由于线程池的最大线程数量就是 10，所以已经不能再增加更多的线程来帮忙处理任务了，这就意味着此时线程池工作饱和，这个时候再提交新任务时就会被拒绝。</p>
<img data-src="/2022/12/09/tech/java/concurrent/11/c_11_01.png" class="">

<p>我们结合图示来分析上述情况，首先看右侧上方的队列部分，你可以看到目前队列已经满了，而图中队列下方的每个线程都在工作，且线程数已经达到最大值 10，如果此时再有新的任务提交，线程池由于没有能力继续处理新提交的任务，所以就会拒绝。</p>
<p>我们了解了线程池拒绝任务的时机，那么我们如何正确地选择拒绝策略呢？Java 在 ThreadPoolExecutor 类中为我们提供了 4 种默认的拒绝策略来应对不同的场景，都实现了 RejectedExecutionHandler 接口，如图所示：</p>
<img data-src="/2022/12/09/tech/java/concurrent/11/c_11_02.png" class="">

<p>接下来，我们将具体讲解这 4 种拒绝策略。</p>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><ul>
<li>第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</li>
<li>第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</li>
<li>第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</li>
<li>第四种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。<ul>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>12 有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？</title>
    <url>/2022/12/09/tech/java/concurrent/12/</url>
    <content><![CDATA[<p>在本课时我们主要学习常见的 6 种线程池，并详细讲解 Java 8 新增的 ForkJoinPool 线程池，6 种常见的线程池如下。</p>
<span id="more"></span>

<ul>
<li>FixedThreadPool</li>
<li>CachedThreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
<li>SingleThreadScheduledExecutor</li>
<li>ForkJoinPool</li>
</ul>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>第一种线程池叫作 FixedThreadPool，它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_01.png" class="">

<p>如图所示，线程池有 t0~t9，10 个线程，它们会不停地执行任务，如果某个线程任务执行完了，就会从任务队列中获取新的任务继续执行，期间线程数量不会增加也不会减少，始终保持在 10 个。</p>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p>第二种线程池是 CachedThreadPool，可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p>
<p>当我们提交一个任务后，线程池会判断已创建的线程中是否有空闲线程，如果有空闲线程则将任务直接指派给空闲线程，如果没有空闲线程，则新建线程去执行任务，这样就做到了动态地新增线程。让我们举个例子，如下方代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; </span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">Task</span>() &#123; </span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用 for 循环提交 1000 个任务给 CachedThreadPool，假设这些任务处理的时间非常长，会发生什么情况呢？因为 for 循环提交任务的操作是非常快的，但执行任务却比较耗时，就可能导致 1000 个任务都提交完了但第一个任务还没有被执行完，所以此时 CachedThreadPool 就可以动态的伸缩线程数量，随着任务的提交，不停地创建 1000 个线程来执行任务，而当任务执行完之后，假设没有新的任务了，那么大量的闲置线程又会造成内存资源的浪费，这时线程池就会检测线程在 60 秒内有没有可执行任务，如果没有就会被销毁，最终线程数量会减为 0。</p>
<h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><p>第三个线程池是 ScheduledThreadPool，它支持定时或周期性执行任务。比如每隔 10 秒钟执行一次任务，而实现这种功能的方法主要有 3 种，如代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">service.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">service.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>那么这 3 种方法有什么区别呢？</p>
<ul>
<li>第一种方法 schedule 比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。</li>
<li>第二种方法 scheduleAtFixedRate 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。</li>
<li>第三种方法 scheduleWithFixedDelay 与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。</li>
</ul>
<p>举个例子，假设某个同学正在熬夜写代码，需要喝咖啡来提神，假设每次喝咖啡都需要花10分钟的时间，如果此时采用第2种方法 scheduleAtFixedRate，时间间隔设置为 1 小时，那么他将会在每个整点喝一杯咖啡，以下是时间表：</p>
<ul>
<li>00:00: 开始喝咖啡</li>
<li>00:10: 喝完了</li>
<li>01:00: 开始喝咖啡</li>
<li>01:10: 喝完了</li>
<li>02:00: 开始喝咖啡</li>
<li>02:10: 喝完了</li>
</ul>
<p>但是假设他采用第3种方法 scheduleWithFixedDelay，时间间隔同样设置为 1 小时，那么由于每次喝咖啡需要10分钟，而 scheduleWithFixedDelay 是以任务完成的时间为时间起点开始计时的，所以第2次喝咖啡的时间将会在1:10，而不是1:00整，以下是时间表：</p>
<ul>
<li>00:00: 开始喝咖啡</li>
<li>00:10: 喝完了</li>
<li>01:10: 开始喝咖啡</li>
<li>01:20: 喝完了</li>
<li>02:20: 开始喝咖啡</li>
<li>02:30: 喝完了</li>
</ul>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>第四种线程池是 SingleThreadExecutor，它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p>
<h4 id="SingleThreadScheduledExecutor"><a href="#SingleThreadScheduledExecutor" class="headerlink" title="SingleThreadScheduledExecutor"></a>SingleThreadScheduledExecutor</h4><p>第五个线程池是 SingleThreadScheduledExecutor，它实际和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程，如源码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>它只是将 ScheduledThreadPool 的核心线程数设置为了 1。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_02.png" class="">

<p>总结上述的五种线程池，我们以核心线程数、最大线程数，以及线程存活时间三个维度进行对比，如表格所示。</p>
<p>第一个线程池 FixedThreadPool，它的核心线程数和最大线程数都是由构造函数直接传参的，而且它们的值是相等的，所以最大线程数不会超过核心线程数，也就不需要考虑线程回收的问题，如果没有任务可执行，线程仍会在线程池中存活并等待任务。</p>
<p>第二个线程池 CachedThreadPool 的核心线程数是 0，而它的最大线程数是 Integer 的最大值，线程数一般是达不到这么多的，所以如果任务特别多且耗时的话，CachedThreadPool 就会创建非常多的线程来应对。</p>
<p>同理，你可以课后按照同样的方法来分析后面三种线程池的参数，来加深对知识的理解。</p>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><img data-src="/2022/12/09/tech/java/concurrent/12/c_12_03.png" class="">

<p>最后，我们来看下第六种线程池 ForkJoinPool，这个线程池是在 JDK 7 加入的，它的名字 ForkJoin 也描述了它的执行机制，主要用法和之前的线程池是相同的，也是把任务交给线程池去执行，线程池中也有任务队列来存放任务。但是 ForkJoinPool 线程池和之前的线程池有两点非常大的不同之处。第一点它非常适合执行可以产生子任务的任务。</p>
<p>如图所示，我们有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result，比如说主任务需要执行非常繁重的计算任务，我们就可以把计算拆分成三个部分，这三个部分是互不影响相互独立的，这样就可以利用 CPU 的多核优势，并行计算，然后将结果进行汇总。这里面主要涉及两个步骤，第一步是拆分也就是 Fork，第二步是汇总也就是 Join，到这里你应该已经了解到 ForkJoinPool 线程池名字的由来了。</p>
<p>举个例子，比如面试中经常考到的菲波那切数列，你一定非常熟悉，这个数列的特点就是后一项的结果等于前两项的和，第 0 项是 0，第 1 项是 1，那么第 2 项就是 0+1&#x3D;1，以此类推。我们在写代码时应该首选效率更高的迭代形式或者更高级的乘方或者矩阵公式法等写法，不过假设我们写成了最初版本的递归形式，伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Fib</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fib</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Fib</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    f1.solve();</span><br><span class="line">    f2.solve();</span><br><span class="line">    number = f1.number + f2.number;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到如果 n&lt;&#x3D;1 则直接返回 n，如果 n&gt;1 ，先将前一项 f1 的值计算出来，然后往前推两项求出 f2 的值，然后将两值相加得到结果，所以我们看到在求和运算中产生了两个子任务。计算 f(4) 的流程如下图所示。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_04.png" class="">

<p>在计算 f(4) 时需要首先计算出 f(2) 和 f(3)，而同理，计算 f(3) 时又需要计算 f(1) 和 f(2)，以此类推。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_05.png" class="">

<p>这是典型的递归问题，对应到我们的 ForkJoin 模式，如图所示，子任务同样会产生子子任务，最后再逐层汇总，得到最终的结果。</p>
<p>ForkJoinPool 线程池有多种方法可以实现任务的分裂和汇总，其中一种用法如下方代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">        f1.fork();</span><br><span class="line"></span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">        f2.fork();</span><br><span class="line">        <span class="keyword">return</span> f1.join() + f2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到它首先继承了 RecursiveTask，RecursiveTask 类是对ForkJoinTask 的一个简单的包装，这时我们重写 compute() 方法，当 n&lt;&#x3D;1 时直接返回，当 n&gt;1 就创建递归任务，也就是 f1 和 f2，然后我们用 fork() 方法分裂任务并分别执行，最后在 return 的时候，使用 join() 方法把结果汇总，这样就实现了任务的分裂和汇总。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; </span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">        <span class="type">ForkJoinTask</span> <span class="variable">task</span> <span class="operator">=</span> forkJoinPool.submit(<span class="keyword">new</span> <span class="title class_">Fibonacci</span>(i));</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码将会打印出斐波那契数列的第 0 到 9 项的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>这就是 ForkJoinPool 线程池和其他线程池的第一点不同。</p>
<p>我们来看第二点不同，第二点不同之处在于内部结构，之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列，如图所示。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_06.png" class="">

<p>ForkJoinPool 线程池内部除了有一个共用的任务队列之外，每个线程还有一个对应的双端队列 deque，这时一旦线程中的任务被 Fork 分裂了，分裂出来的子任务放入线程自己的 deque 里，而不是放入公共的任务队列中。如果此时有三个子任务放入线程 t1 的 deque 队列中，对于线程 t1 而言获取任务的成本就降低了，可以直接在自己的任务队列中获取而不必去公共队列中争抢也不会发生阻塞（除了后面会讲到的 steal 情况外），减少了线程间的竞争和切换，是非常高效的。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_07.png" class="">

<p>我们再考虑一种情况，此时线程有多个，而线程 t1 的任务特别繁重，分裂了数十个子任务，但是 t0 此时却无事可做，它自己的 deque 队列为空，这时为了提高效率，t0 就会想办法帮助 t1 执行任务，这就是“work-stealing”的含义。</p>
<p>双端队列 deque 中，线程 t1 获取任务的逻辑是后进先出，也就是LIFO（Last In Frist Out），而线程 t0 在“steal”偷线程 t1 的 deque 中的任务的逻辑是先进先出，也就是FIFO（Fast In Frist Out），如图所示，图中很好的描述了两个线程使用双端队列分别获取任务的情景。你可以看到，使用 “work-stealing” 算法和双端队列很好地平衡了各线程的负载。</p>
<img data-src="/2022/12/09/tech/java/concurrent/12/c_12_08.png" class="">

<p>最后，我们用一张全景图来描述 ForkJoinPool 线程池的内部结构，你可以看到 ForkJoinPool 线程池和其他线程池很多地方都是一样的，但重点区别在于它每个线程都有一个自己的双端队列来存储分裂出来的子任务。ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>13 线程池常用的阻塞队列有哪些？</title>
    <url>/2022/12/12/tech/java/concurrent/13/</url>
    <content><![CDATA[<p>在本课时我们主要学习线程池内部结构，以及线程池中最常见的阻塞队列类型。</p>
<span id="more"></span>

<h4 id="线程池内部结构"><a href="#线程池内部结构" class="headerlink" title="线程池内部结构"></a>线程池内部结构</h4><img data-src="/2022/12/12/tech/java/concurrent/13/c_13_01.png" class="">

<p>线程池的内部结构主要由四部分组成，如图所示。</p>
<ul>
<li>第一部分是线程池管理器，它主要负责管理线程池的创建、销毁、添加任务等管理操作，它是整个线程池的管家。</li>
<li>第二部分是工作线程，也就是图中的线程 t0~t9，这些线程勤勤恳恳地从任务队列中获取任务并执行。</li>
<li>第三部分是任务队列，作为一种缓冲机制，线程池会把当下没有处理的任务放入任务队列中，由于多线程同时从任务队列中获取任务是并发场景，此时就需要任务队列满足线程安全的要求，所以线程池中任务队列采用 BlockingQueue 来保障线程安全。</li>
<li>第四部分是任务，任务要求实现统一的接口，以便工作线程可以处理和执行。</li>
</ul>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><img data-src="/2022/12/12/tech/java/concurrent/13/c_13_02.png" class="">

<p>线程池中的这四个主要组成部分最值得我们关注的就是阻塞队列了，如表格所示，不同的线程池会选用不同的阻塞队列。</p>
<p>表格左侧是线程池，右侧为它们对应的阻塞队列，你可以看到 5 种线程池对应了 3 种阻塞队列，我们接下来对它们进行逐一的介绍。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。</p>
<p>我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p>
<h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p>第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>线程池</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title>14 为什么不应该自动创建线程池？</title>
    <url>/2022/12/12/tech/java/concurrent/14/</url>
    <content><![CDATA[<p>在本课时我们主要学习为什么不应该自动创建线程池，所谓的自动创建线程池就是直接调用 Executors 的各种方法来生成前面学过的常见的线程池，例如 Executors.newCachedThreadPool()。但这样做是有一定风险的，接下来我们就来逐一分析自动创建线程池可能带来哪些问题。</p>
<span id="more"></span>

<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>首先我们来看第一种线程池 FixedThreadPool， 它是线程数量固定的线程池，如源码所示，newFixedThreadPool 内部实际还是调用了 ThreadPoolExecutor 构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过往构造函数中传参，创建了一个核心线程数和最大线程数相等的线程池，它们的数量也就是我们传入的参数，这里的重点是使用的队列是容量没有上限的 LinkedBlockingQueue，如果我们对任务的处理速度比较慢，那么随着请求的增多，队列中堆积的任务也会越来越多，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。</p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>第二种线程池是 SingleThreadExecutor，我们来分析下创建它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看出，newSingleThreadExecutor 和 newFixedThreadPool 的原理是一样的，只不过把核心线程数和最大线程数都直接设置成了 1，但是任务队列仍是无界的 LinkedBlockingQueue，所以也会导致同样的问题，也就是当任务堆积时，可能会占用大量的内存并导致 OOM。</p>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p>第三种线程池是 CachedThreadPool，创建它的源码下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 CachedThreadPool 和前面两种线程池不一样的地方在于任务队列使用的是 SynchronousQueue，SynchronousQueue 本身并不存储任务，而是对任务直接进行转发，这本身是没有问题的，但你会发现构造函数的第二个参数被设置成了 Integer.MAX_VALUE，这个参数的含义是最大线程数，所以由于 CachedThreadPool 并不限制线程的数量，当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。</p>
<h4 id="ScheduledThreadPool-和-SingleThreadScheduledExecutor"><a href="#ScheduledThreadPool-和-SingleThreadScheduledExecutor" class="headerlink" title="ScheduledThreadPool 和 SingleThreadScheduledExecutor"></a>ScheduledThreadPool 和 SingleThreadScheduledExecutor</h4><p>第四种线程池 ScheduledThreadPool 和第五种线程池 SingleThreadScheduledExecutor 的原理是一样的，创建 ScheduledThreadPool 的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里的 ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的子类，调用的它的构造方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123; </span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,<span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过源码可以看出，它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过多的任务，就可能导致 OOM。</p>
<p>你可以看到，这几种自动创建的线程池都存在风险，相比较而言，我们自己手动创建会更好，因为我们可以更加明确线程池的运行规则，不仅可以选择适合自己的线程数量，更可以在必要的时候拒绝新任务的提交，避免资源耗尽的风险。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>15 合适的线程数量是多少？CPU 核心数和线程数的关系？</title>
    <url>/2022/12/14/tech/java/concurrent/15/</url>
    <content><![CDATA[<p>在本课时我们主要学习合适的线程数量是多少，以及 CPU 核心数和线程数的关系。</p>
<blockquote>
<p>你可能经常在面试中被问到这两个问题，如果想要很好地回答它们首先你需要了解，我们调整线程池中的线程数量的最主要的目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能。在实际工作中，我们需要根据任务类型的不同选择对应的策略。</p>
</blockquote>
<span id="more"></span>

<h4 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h4><p>首先，我们来看 CPU 密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。对于这样的任务最佳的线程数为 CPU 核心数的 1~2 倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍以上，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p>
<p>针对这种情况，我们最好还要同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做整体的平衡。</p>
<h4 id="耗时-IO-型任务"><a href="#耗时-IO-型任务" class="headerlink" title="耗时 IO 型任务"></a>耗时 IO 型任务</h4><p>第二种任务是耗时 IO 型，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。</p>
<p>《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）</span><br></pre></td></tr></table></figure>

<p>通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。</p>
<p>太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>综上所述我们就可以得出一个结论：</p>
<ul>
<li>线程的平均工作时间所占比例越高，就需要越少的线程；</li>
<li>线程的平均等待时间所占比例越高，就需要越多的线程；</li>
<li>针对不同的程序，进行对应的实际测试就可以得到最合适的选择。</li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程数量</tag>
      </tags>
  </entry>
  <entry>
    <title>16 如何根据实际需要，定制自己的线程池？</title>
    <url>/2022/12/14/tech/java/concurrent/16/</url>
    <content><![CDATA[<p>在本课时我们主要学习如何根据自己的实际需求设置线程池的各个参数来定制自己的线程池。</p>
<span id="more"></span>

<h4 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h4><p>第一个需要设置的参数往往是 corePoolSize 核心线程数，在上一课时我们讲过，合理的线程数量和任务类型，以及 CPU 核心数都有关系，基本结论是线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程。而对于最大线程数而言，如果我们执行的任务类型不是固定的，比如可能一段时间是 CPU 密集型，另一段时间是 IO 密集型，或是同时有两种任务相互混搭。那么在这种情况下，我们可以把最大线程数设置成核心线程数的几倍，以便应对任务突发情况。当然更好的办法是用不同的线程池执行不同类型的任务，让任务按照类型区分开，而不是混杂在一起，这样就可以按照上一课时估算的线程数或经过压测得到的结果来设置合理的线程数了，达到更好的性能。</p>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>对于阻塞队列这个参数而言，我们可以选择之前介绍过的 LinkedBlockingQueue 或者 SynchronousQueue 或者 DelayedWorkQueue，不过还有一种常用的阻塞队列叫 ArrayBlockingQueue，它也经常被用于线程池中，这种阻塞队列内部是用数组实现的，在新建对象的时候要求传入容量值，且后期不能扩容，所以 ArrayBlockingQueue 的最大的特点就是容量是有限的。这样一来，如果任务队列放满了任务，而且线程数也已经达到了最大值，线程池根据规则就会拒绝新提交的任务，这样一来就可能会产生一定的数据丢失。</p>
<p>但相比于无限增加任务或者线程数导致内存不足，进而导致程序崩溃，数据丢失还是要更好一些的，如果我们使用了 ArrayBlockingQueue 这种阻塞队列，再加上我们限制了最大线程数量，就可以非常有效地防止资源耗尽的情况发生。此时的队列容量大小和 maxPoolSize 是一个 trade-off，如果我们使用容量更大的队列和更小的最大线程数，就可以减少上下文切换带来的开销，但也可能因此降低整体的吞吐量；如果我们的任务是 IO 密集型，则可以选择稍小容量的队列和更大的最大线程数，这样整体的效率就会更高，不过也会带来更多的上下文切换。</p>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><p>对于线程工厂 threadFactory 这个参数，我们可以使用默认的 defaultThreadFactory，也可以传入自定义的有额外能力的线程工厂，因为我们可能有多个线程池，而不同的线程池之间有必要通过不同的名字来进行区分，所以可以传入能根据业务信息进行命名的线程工厂，以便后续可以根据线程名区分不同的业务进而快速定位问题代码。比如可以通过com.google.common.util.concurrent.ThreadFactory</p>
<p>Builder 来实现，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">rpcFactory</span> <span class="operator">=</span> builder.setNameFormat(<span class="string">&quot;rpc-pool-%d&quot;</span>).build();</span><br></pre></td></tr></table></figure>

<p>我们生成了名字为 rpcFactory 的 ThreadFactory，它的 nameFormat 为 “rpc-pool-%d” ，那么它生成的线程的名字是有固定格式的，它生成的线程的名字分别为”rpc-pool-1”，”rpc-pool-2” ，以此类推。</p>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>最后一个参数是拒绝策略，我们可以根据业务需要，选择第 11 讲里的四种拒绝策略之一来使用：AbortPolicy，DiscardPolicy，DiscardOldestPolicy 或者 CallerRunsPolicy。除此之外，我们还可以通过实现 RejectedExecutionHandler 接口来实现自己的拒绝策略，在接口中我们需要实现 rejectedExecution 方法，在 rejectedExecution 方法中，执行例如打印日志、暂存任务、重新执行等自定义的拒绝策略，以便满足业务需求。如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CustomRejectionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123; </span><br><span class="line">        <span class="comment">//打印日志、暂存任务、重新执行等拒绝策略</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以定制自己的线程池和我们的业务是强相关的，首先我们需要掌握每个参数的含义，以及常见的选项，然后根据实际需要，比如说并发量、内存大小、是否接受任务被拒绝等一系列因素去定制一个非常适合自己业务的线程池，这样既不会导致内存不足，同时又可以用合适数量的线程来保障任务执行的效率，并在拒绝任务时有所记录方便日后进行追溯。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>17 如何正确关闭线程池？shutdown 和 shutdownNow 的区别？</title>
    <url>/2022/12/14/tech/java/concurrent/17/</url>
    <content><![CDATA[<p>在本课时我们主要学习如何正确关闭线程池？以及 shutdown() 与 shutdownNow() 方法的区别？首先，我们创建一个线程数固定为 10 的线程池，并且往线程池中提交 100 个任务，如代码所示。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">    service.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果现在我们想关闭该线程池该如何做呢？本课时主要介绍 5 种在 ThreadPoolExecutor 中涉及关闭线程池的方法，如下所示。</p>
<ul>
<li>void shutdown;</li>
<li>boolean isShutdown;</li>
<li>boolean isTerminated;</li>
<li>boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</li>
<li>List shutdownNow;</li>
</ul>
<p>下面我们就对这些方法逐一展开。</p>
<h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h5><p>第一种方法叫作 shutdown()，它可以安全地关闭一个线程池，调用 shutdown() 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown() 方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。但这并不代表 shutdown() 操作是没有任何效果的，调用 shutdown() 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</p>
<h5 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown()"></a>isShutdown()</h5><p>第二个方法叫作 isShutdown()，它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown() 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</p>
<h5 id="isTerminated"><a href="#isTerminated" class="headerlink" title="isTerminated()"></a>isTerminated()</h5><p>第三种方法叫作 isTerminated()，这个方法可以检测线程池是否真正“终结”了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了，因为我们刚才说过，调用 shutdown 方法之后，线程池会继续执行里面未完成的任务，不仅包括线程正在执行的任务，还包括正在任务队列中等待的任务。比如此时已经调用了 shutdown 方法，但是有一个线程依然在执行任务，那么此时调用 isShutdown 方法返回的是 true ，而调用 isTerminated 方法返回的便是 false ，因为线程池中还有任务正在在被执行，线程池并没有真正“终结”。直到所有任务都执行完毕了，调用 isTerminated() 方法才会返回 true，这表示线程池已关闭并且线程池内部是空的，所有剩余的任务都执行完毕了。</p>
<h5 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h5><p>第四个方法叫作 awaitTermination()，它本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p>
<ol>
<li>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；</li>
<li>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；</li>
<li>等待期间线程被中断，方法会抛出 InterruptedException 异常。</li>
</ol>
<p>也就是说，调用 awaitTermination 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</p>
<p>我们则可以根据 awaitTermination() 返回的布尔值来判断下一步应该执行的操作。</p>
<h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h5><p>最后一个方法是 shutdownNow()，也是 5 种方法里功能最强大的，它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。shutdownNow() 的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123; </span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到源码中有一行 interruptWorkers() 代码，这行代码会让每一个已经启动的线程都中断，这样线程就可以在执行任务期间检测到中断信号并进行相应的处理，提前结束任务。这里需要注意的是，由于 Java 中不推荐强行停止线程的机制的限制，即便我们调用了 shutdownNow 方法，如果被中断的线程对于中断信号不理不睬，那么依然有可能导致任务不会停止。可见我们在开发中落地最佳实践是很重要的，我们自己编写的线程应当具有响应中断信号的能力，正确停止线程的方法在第 2 讲有讲过，应当利用中断信号来协同工作。</p>
<p>在掌握了这 5 种关闭线程池相关的方法之后，我们就可以根据自己的业务需要，选择合适的方法来停止线程池，比如通常我们可以用 shutdown() 方法来关闭，这样可以让已提交的任务都执行完毕，但是如果情况紧急，那我们就可以用 shutdownNow 方法来加快线程池“终结”的速度。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>18 线程池实现“线程复用”的原理？</title>
    <url>/2022/12/30/tech/java/concurrent/18/</url>
    <content><![CDATA[<p>在本课时我们主要学习线程复用的原理，以及对线程池的 execute 这个非常重要的方法进行源码解析。</p>
<span id="more"></span>

<h4 id="线程复用原理"><a href="#线程复用原理" class="headerlink" title="线程复用原理"></a>线程复用原理</h4><p>我们知道线程池会使用固定数量或可变数量的线程来执行任务，但无论是固定数量或可变数量的线程，其线程数量都远远小于任务数量，面对这种情况线程池可以通过线程复用让同一个线程去执行不同的任务，那么线程复用背后的原理是什么呢？</p>
<p>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
<p>我们首先来复习一下线程池创建新线程的时机和规则：</p>
<img data-src="/2022/12/30/tech/java/concurrent/18/c_18_01.png" class="">

<p>如流程图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maxPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maxPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize 、workQueue 、maxPoolSize ，如果依然不能满足需求，则会拒绝任务。</p>
<p>我们接下来具体看看代码是如何实现的，我们从 execute 方法开始分析，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) </span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) </span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程复用源码解析"><a href="#线程复用源码解析" class="headerlink" title="线程复用源码解析"></a>线程复用源码解析</h4><p>这段代码短小精悍，内容丰富，接下来我们具体分析代码中的逻辑，首先看下前几行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果传入的Runnable的空，就抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (command == <span class="literal">null</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>

<p>execute 方法中通过 if 语句判断 command ，也就是 Runnable 任务是否等于 null，如果为 null 就抛出异常。</p>
<p>接下来判断当前线程数是否小于核心线程数，如果小于核心线程数就调用 addWorker() 方法增加一个 Worker，这里的 Worker 就可以理解为一个线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; </span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那 addWorker 方法又是做什么用的呢？addWorker 方法的主要作用是在线程池中创建一个线程并执行第一个参数传入的任务，它的第二个参数是个布尔值，如果布尔值传入 true 代表增加线程时判断当前线程是否少于 corePoolSize，小于则增加新线程，大于等于则不增加；同理，如果传入 false 代表增加线程时判断当前线程是否少于 maxPoolSize，小于则增加新线程，大于等于则不增加，所以这里的布尔值的含义是以核心线程数为界限还是以最大线程数为界限进行是否新增线程的判断。addWorker() 方法如果返回 true 代表添加成功，如果返回 false 代表添加失败。</p>
<p>我们接下来看下一部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) </span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) </span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果代码执行到这里，说明当前线程数大于或等于核心线程数或者 addWorker 失败了，那么就需要通过 if (isRunning(c) &amp;&amp; workQueue.offer(command)) 检查线程池状态是否为 Running，如果线程池状态是 Running 就把任务放入任务队列中，也就是 workQueue.offer(command)。如果线程池已经不处于 Running 状态，说明线程池被关闭，那么就移除刚刚添加到任务队列中的任务，并执行拒绝策略，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) </span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<p>下面我们再来看后一个 else 分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) </span><br><span class="line">    addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>能进入这个 else 说明前面判断到线程池状态为 Running，那么当任务被添加进来之后就需要防止没有可执行线程的情况发生（比如之前的线程被回收了或意外终止了），所以此时如果检查当前线程数为 0，也就是 workerCountOf**(recheck) &#x3D;&#x3D; 0，那就执行 addWorker() 方法新建线程。</p>
<p>我们再来看最后一部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) </span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<p>执行到这里，说明线程池不是 Running 状态或线程数大于或等于核心线程数并且任务队列已经满了，根据规则，此时需要添加新线程，直到线程数达到“最大线程数”，所以此时就会再次调用 addWorker 方法并将第二个参数传入 false，传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize，小于则增加新线程，大于等于则不增加，也就是以 maxPoolSize 为上限创建新的 worker；addWorker 方法如果返回 true 代表添加成功，如果返回 false 代表任务添加失败，说明当前线程数已经达到 maxPoolSize，然后执行拒绝策略 reject 方法。如果执行到这里线程池的状态不是 Running，那么 addWorker 会失败并返回 false，所以也会执行拒绝策略 reject 方法。</p>
<p>可以看出，在 execute 方法中，多次调用 addWorker 方法把任务传入，addWorker 方法会添加并启动一个 Worker，这里的 Worker 可以理解为是对 Thread 的包装，Worker 内部有一个 Thread 对象，它正是最终真正执行任务的线程，所以一个 Worker 就对应线程池中的一个线程，addWorker 就代表增加线程。线程复用的逻辑实现主要在 Worker 类中的 run 方法里执行的 runWorker 方法中，简化后的 runWorker 方法代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">runWorker(Worker w) &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，实现线程复用的逻辑主要在一个不停循环的 while 循环体中。</p>
<ol>
<li>通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务。</li>
<li>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）。</li>
</ol>
<p>在这里，我们找到了最终的实现，通过取 Worker 的 firstTask 或者 getTask方法从 workQueue 中取出了新任务，并直接调用 Runnable 的 run 方法来执行任务，也就是如之前所说的，每个线程都始终在一个大循环中，反复获取任务，然后执行任务，从而实现了线程的复用。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>19 你知道哪几种锁？分别有什么特点？</title>
    <url>/2022/12/30/tech/java/concurrent/19/</url>
    <content><![CDATA[<p>本课时我们首先会对锁的分类有一个整体的概念，了解锁究竟有哪些分类标准。然后在后续的课程中，会对其中重要的锁进行详细讲解。</p>
<span id="more"></span>

<h4 id="锁的-7-大分类"><a href="#锁的-7-大分类" class="headerlink" title="锁的 7 大分类"></a>锁的 7 大分类</h4><p>需要首先指出的是，这些多种多样的分类，是评价一个事物的多种标准，比如评价一个城市，标准有人口多少、经济发达与否、城市面积大小等。而一个城市可能同时占据多个标准，以北京而言，人口多，经济发达，同时城市面积还很大。</p>
<p>同理，对于 Java 中的锁而言，一把锁也有可能同时占有多个标准，符合多种分类，比如 ReentrantLock 既是可中断锁，又是可重入锁。</p>
<p>根据分类标准我们把锁分为以下 7 大类别，分别是：</p>
<ul>
<li>偏向锁&#x2F;轻量级锁&#x2F;重量级锁；</li>
<li>可重入锁&#x2F;非可重入锁；</li>
<li>共享锁&#x2F;独占锁；</li>
<li>公平锁&#x2F;非公平锁；</li>
<li>悲观锁&#x2F;乐观锁；</li>
<li>自旋锁&#x2F;非自旋锁；</li>
<li>可中断锁&#x2F;不可中断锁。<br>以上是常见的分类标准，下面我们来逐一介绍它们的含义。</li>
</ul>
<h4 id="偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><p>第一种分类是偏向锁&#x2F;轻量级锁&#x2F;重量级锁，这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。</p>
<ul>
<li><p>偏向锁<br>如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</p>
</li>
<li><p>轻量级锁<br>JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</p>
</li>
<li><p>重量级锁<br>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</p>
</li>
</ul>
<img data-src="/2022/12/30/tech/java/concurrent/19/c_19_01.png" class="">

<p>你可以发现锁升级的路径：无锁→偏向锁→轻量级锁→重量级锁。</p>
<p>综上所述，偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。</p>
<h4 id="可重入锁-x2F-非可重入锁"><a href="#可重入锁-x2F-非可重入锁" class="headerlink" title="可重入锁&#x2F;非可重入锁"></a>可重入锁&#x2F;非可重入锁</h4><p>第 2 个分类是可重入锁和非可重入锁。可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</p>
<p>对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。</p>
<h4 id="共享锁-x2F-独占锁"><a href="#共享锁-x2F-独占锁" class="headerlink" title="共享锁&#x2F;独占锁"></a>共享锁&#x2F;独占锁</h4><p>第 3 种分类标准是共享锁和独占锁。共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>
<h4 id="公平锁-x2F-非公平锁"><a href="#公平锁-x2F-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><p>第 4 种分类是公平锁和非公平锁。公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。</p>
<h4 id="悲观锁-x2F-乐观锁"><a href="#悲观锁-x2F-乐观锁" class="headerlink" title="悲观锁&#x2F;乐观锁"></a>悲观锁&#x2F;乐观锁</h4><p>第 5 种分类是悲观锁，以及与它对应的乐观锁。悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</p>
<h4 id="自旋锁-x2F-非自旋锁"><a href="#自旋锁-x2F-非自旋锁" class="headerlink" title="自旋锁&#x2F;非自旋锁"></a>自旋锁&#x2F;非自旋锁</h4><p>第 6 种分类是自旋锁与非自旋锁。自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</p>
<h4 id="可中断锁-x2F-不可中断锁"><a href="#可中断锁-x2F-不可中断锁" class="headerlink" title="可中断锁&#x2F;不可中断锁"></a>可中断锁&#x2F;不可中断锁</h4><p>第 7 种分类是可中断锁和不可中断锁。在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>20 悲观锁和乐观锁的本质是什么？</title>
    <url>/2022/12/30/tech/java/concurrent/20/</url>
    <content><![CDATA[<p>本课时我们会讲讲悲观锁和乐观锁。</p>
<p>首先我们看下悲观锁与乐观锁是如何进行分类的，悲观锁和乐观锁是从是否锁住资源的角度进行分类的。</p>
<span id="more"></span>

<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁比较悲观，它认为如果不锁住这个资源，别的线程就会来争抢，就会造成数据结果错误，所以悲观锁为了确保结果的正确性，会在每次获取并修改数据时，都把数据锁住，让其他线程无法访问该数据，这样就可以确保数据内容万无一失。</p>
<p>这也和我们人类中悲观主义者的性格是一样的，悲观主义者做事情之前总是担惊受怕，所以会严防死守，保证别人不能来碰我的东西，这就是悲观锁名字的含义。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_01.png" class="">

<p>我们举个例子，假设线程 A 和 B 使用的都是悲观锁，所以它们在尝试获取同步资源时，必须要先拿到锁。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_02.png" class="">

<p>假设线程 A 拿到了锁，并且正在操作同步资源，那么此时线程 B 就必须进行等待。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_03.png" class="">

<p>而当线程 A 执行完毕后，CPU 才会唤醒正在等待这把锁的线程 B 再次尝试获取锁。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_04.png" class="">

<p>如果线程 B 现在获取到了锁，才可以对同步资源进行自己的操作。这就是悲观锁的操作流程。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁比较乐观，认为自己在操作资源的时候不会有其他线程来干扰，所以并不会锁住被操作对象，不会不让别的线程来接触它，同时，为了确保数据正确性，在更新之前，会去对比在我修改数据期间，数据有没有被其他线程修改过：如果没被修改过，就说明真的只有我自己在操作，那我就可以正常的修改数据；如果发现数据和我一开始拿到的不一样了，说明其他线程在这段时间内修改过数据，那说明我迟了一步，所以我会放弃这次修改，并选择报错、重试等策略。</p>
<p>这和我们生活中乐天派的人的性格是一样的，乐观的人并不会担忧还没有发生的事情，相反，他会认为未来是美好的，所以他在修改数据之前，并不会把数据给锁住。当然，乐天派也不会盲目行动，如果他发现事情和他预想的不一样，也会有相应的处理办法，他不会坐以待毙，这就是乐观锁的思想。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_05.png" class="">

<p>乐观锁的实现一般都是利用 CAS 算法实现的。我们举个例子，假设线程 A 此时运用的是乐观锁。那么它去操作同步资源的时候，不需要提前获取到锁，而是可以直接去读取同步资源，并且在自己的线程内进行计算。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_06.png" class="">

<p>当它计算完毕之后、准备更新同步资源之前，会先判断这个资源是否已经被其他线程所修改过。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_07.png" class="">

<p>如果这个时候同步资源没有被其他线程修改更新，也就是说此时的数据和线程 A 最开始拿到的数据是一致的话，那么此时线程 A 就会去更新同步资源，完成修改的过程。</p>
<img data-src="/2022/12/30/tech/java/concurrent/20/c_20_08.png" class="">

<p>而假设此时的同步资源已经被其他线程修改更新了，线程 A 会发现此时的数据已经和最开始拿到的数据不一致了，那么线程 A 不会继续修改该数据，而是会根据不同的业务逻辑去选择报错或者重试。</p>
<p>悲观锁和乐观锁概念并不是 Java 中独有的，这是一种广义的思想，这种思想可以应用于其他领域，比如说在数据库中，同样也有对悲观锁和乐观锁的应用。</p>
<h4 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h4><ul>
<li>悲观锁：synchronized 关键字和 Lock 接口</li>
</ul>
<p>Java 中悲观锁的实现包括 synchronized 关键字和 Lock 相关类等，我们以 Lock 接口为例，例如 Lock 的实现类 ReentrantLock，类中的 lock() 等方法就是执行加锁，而 unlock() 方法是执行解锁。处理资源之前必须要先加锁并拿到锁，等到处理完了之后再解开锁，这就是非常典型的悲观锁思想。</p>
<ul>
<li>乐观锁：原子类</li>
</ul>
<p>乐观锁的典型案例就是原子类，例如 AtomicInteger 在更新数据时，就使用了乐观锁的思想，多个线程可以同时操作同一个原子变量。</p>
<ul>
<li>大喜大悲：数据库</li>
</ul>
<p>数据库中同时拥有悲观锁和乐观锁的思想。例如，我们如果在 MySQL 选择 select for update 语句，那就是悲观锁，在提交之前不允许第三方来修改该数据，这当然会造成一定的性能损耗，在高并发的情况下是不可取的。</p>
<p>相反，我们可以利用一个版本 version 字段在数据库中实现乐观锁。在获取及修改数据时都不需要加锁，但是我们在获取完数据并计算完毕，准备更新数据时，会检查版本号和获取数据时的版本号是否一致，如果一致就直接更新，如果不一致，说明计算期间已经有其他线程修改过这个数据了，那我就可以选择重新获取数据，重新计算，然后再次尝试更新数据。</p>
<p>SQL语句示例如下（假设取出数据的时候 version 为1）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> </span><br><span class="line"></span><br><span class="line">        name <span class="operator">=</span> ‘小李’,</span><br><span class="line"></span><br><span class="line">        version<span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">WHERE</span>   id<span class="operator">=</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">AND</span> version<span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h4 id="“汝之蜜糖-彼之砒霜”"><a href="#“汝之蜜糖-彼之砒霜”" class="headerlink" title="“汝之蜜糖,彼之砒霜”"></a>“汝之蜜糖,彼之砒霜”</h4><p>有一种说法认为，悲观锁由于它的操作比较重量级，不能多个线程并行执行，而且还会有上下文切换等动作，所以悲观锁的性能不如乐观锁好，应该尽量避免用悲观锁，这种说法是不正确的。</p>
<p>因为虽然悲观锁确实会让得不到锁的线程阻塞，但是这种开销是固定的。悲观锁的原始开销确实要高于乐观锁，但是特点是一劳永逸，就算一直拿不到锁，也不会对开销造成额外的影响。</p>
<p>反观乐观锁虽然一开始的开销比悲观锁小，但是如果一直拿不到锁，或者并发量大，竞争激烈，导致不停重试，那么消耗的资源也会越来越多，甚至开销会超过悲观锁。</p>
<p>所以，同样是悲观锁，在不同的场景下，效果可能完全不同，可能在今天的这种场景下是好的选择，在明天的另外的场景下就是坏的选择，这恰恰是“汝之蜜糖，彼之砒霜”。</p>
<p>因此，我们就来看一下两种锁各自的使用场景，把合适的锁用到合适的场景中去，把合理的资源分配到合理的地方去。</p>
<h4 id="两种锁各自的使用场景"><a href="#两种锁各自的使用场景" class="headerlink" title="两种锁各自的使用场景"></a>两种锁各自的使用场景</h4><p>悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。</p>
<p>乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。在这些场景下，乐观锁不加锁的特点能让性能大幅提高。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>21 如何看到 synchronized 背后的“monitor 锁”？</title>
    <url>/2022/12/30/tech/java/concurrent/21/</url>
    <content><![CDATA[<p>本课时我们研究下 synchronized 背后的 monitor 锁。</p>
<span id="more"></span>

<h4 id="获取和释放-monitor-锁的时机"><a href="#获取和释放-monitor-锁的时机" class="headerlink" title="获取和释放 monitor 锁的时机"></a>获取和释放 monitor 锁的时机</h4><p>我们都知道，最简单的同步方式就是利用 synchronized 关键字来修饰代码块或者修饰一个方法，那么这部分被保护的代码，在同一时刻就最多只有一个线程可以运行，而 synchronized 的背后正是利用 monitor 锁实现的。所以首先我们来看下获取和释放 monitor 锁的时机，每个 Java 对象都可以用作一个实现同步的锁，这个锁也被称为内置锁或 monitor 锁，获得 monitor 锁的唯一途径就是进入由这个锁保护的同步代码块或同步方法，线程在进入被 synchronized 保护的代码块之前，会自动获取锁，并且无论是正常路径退出，还是通过抛出异常退出，在退出的时候都会自动释放锁。</p>
<p>我们首先来看一个 synchronized 修饰方法的代码的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    method body</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 method() 方法是被 synchronized 修饰的，为了方便理解其背后的原理，我们把上面这段代码改写为下面这种等价形式的伪代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种写法中，进入 method 方法后，立刻添加内置锁，并且用 try 代码块把方法保护起来，最后用 finally 释放这把锁，这里的 intrinsicLock 就是 monitor 锁。经过这样的伪代码展开之后，相信你对 synchronized 的理解就更加清晰了。</p>
<h4 id="用-javap-命令查看反汇编的结果"><a href="#用-javap-命令查看反汇编的结果" class="headerlink" title="用 javap 命令查看反汇编的结果"></a>用 javap 命令查看反汇编的结果</h4><p>JVM 实现 synchronized 方法和 synchronized 代码块的细节是不一样的，下面我们就分别来看一下两者的实现。</p>
<h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>首先我们来看下同步代码块的实现，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;csdn&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 SynTest 类中的 synBlock 方法，包含一个同步代码块，synchronized 代码块中有一行代码打印了 csdn 字符串，下面我们来通过命令看下 synchronized 关键字到底做了什么事情：首先用 cd 命令切换到 SynTest.java 类所在的路径，然后执行 <code>javac SynTest.java</code>，于是就会产生一个名为 SynTest.class 的字节码文件，然后我们执行 <code>javap -verbose SynTest.class</code>，就可以看到对应的反汇编内容。</p>
<p>关键信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void synBlock();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line"></span><br><span class="line">         0: aload_0</span><br><span class="line"></span><br><span class="line">         1: dup</span><br><span class="line"></span><br><span class="line">         2: astore_1</span><br><span class="line"></span><br><span class="line">         3: monitorenter</span><br><span class="line"></span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">         7: ldc           #3                      // String lagou</span><br><span class="line"></span><br><span class="line">         9: invokevirtual #4               // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">        12: aload_1</span><br><span class="line"></span><br><span class="line">        13: monitorexit</span><br><span class="line"></span><br><span class="line">        14: goto          22</span><br><span class="line"></span><br><span class="line">        17: astore_2</span><br><span class="line"></span><br><span class="line">        18: aload_1</span><br><span class="line"></span><br><span class="line">        19: monitorexit</span><br><span class="line"></span><br><span class="line">        20: aload_2</span><br><span class="line"></span><br><span class="line">        21: athrow</span><br><span class="line"></span><br><span class="line">        22: return</span><br></pre></td></tr></table></figure>

<p>从里面可以看出，synchronized 代码块实际上多了 monitorenter 和 monitorexit 指令，标红的第3、13、19行指令分别对应的是 monitorenter 和 monitorexit。这里有一个 monitorenter，却有两个 monitorexit 指令的原因是，JVM 要保证每个 monitorenter 必须有与之对应的 monitorexit，monitorenter 指令被插入到同步代码块的开始位置，而 monitorexit 需要插入到方法正常结束处和异常处两个地方，这样就可以保证抛异常的情况下也能释放锁</p>
<p>可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为 0，我们来具体看一下 monitorenter 和 monitorexit 的含义：</p>
<ul>
<li>monitorenter</li>
</ul>
<p>执行 monitorenter 的线程尝试获得 monitor 的所有权，会发生以下这三种情况之一：</p>
<p>a. 如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。</p>
<p>b. 如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。</p>
<p>c. 如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。</p>
<ul>
<li>monitorexit monitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。</li>
</ul>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>从上面可以看出，同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，并不是依靠 monitorenter 和 monitorexit 指令实现的，被 javap 反汇编后可以看到，synchronized 方法和普通方法大部分是一样的，不同在于，这个方法会有一个叫作 ACC_SYNCHRONIZED 的 flag 修饰符，来表明它是同步方法。</p>
<p>同步方法的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的反汇编指令如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void synMethod();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line"></span><br><span class="line">         0: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 16: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，被 synchronized 修饰的方法会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。其他方面， synchronized 方法和刚才的 synchronized 代码块是很类似的，例如这时如果其他线程来请求执行方法，也会因为无法获得 monitor 锁而被阻塞。</p>
<p>好了，本课时的内容就全部讲完了，本课时我们讲解了获取和释放 monitor 的时机，以及被 synchronized 修饰的等价代码，然后我们还利用 javac 和 javap 命令查看了 synchronized 代码块以及 synchronized 方法所对应的的反汇编指令，其中同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>05 有哪几种实现生产者消费者模式的方法？</title>
    <url>/2022/12/05/tech/java/concurrent/05/</url>
    <content><![CDATA[<p>本课时我们主要学习如何用 wait&#x2F;notify&#x2F;Condition&#x2F;BlockingQueue 实现生产者消费者模式。</p>
<span id="more"></span>

<h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><p>我们先来看看什么是生产者消费者模式，生产者消费者模式是程序设计中非常常见的一种设计模式，被广泛运用在解耦、消息队列等场景。在现实世界中，我们把生产商品的一方称为生产者，把消费商品的一方称为消费者，有时生产者的生产速度特别快，但消费者的消费速度跟不上，俗称“产能过剩”，又或是多个生产者对应多个消费者时，大家可能会手忙脚乱。如何才能让大家更好地配合呢？这时在生产者和消费者之间就需要一个中介来进行调度，于是便诞生了生产者消费者模式。</p>
<img data-src="/2022/12/05/tech/java/concurrent/05/c_05_01.png" class="">

<p>使用生产者消费者模式通常需要在两者之间增加一个阻塞队列作为媒介，有了媒介之后就相当于有了一个缓冲，平衡了两者的能力，整体的设计如图所示，最上面是阻塞队列，右侧的 1 是生产者线程，生产者在生产数据后将数据存放在阻塞队列中，左侧的 2 是消费者线程，消费者获取阻塞队列中的数据。而中间的 3 和 4 分别代表生产者消费者之间互相通信的过程，因为无论阻塞队列是满还是空都可能会产生阻塞，阻塞之后就需要在合适的时机去唤醒被阻塞的线程。</p>
<p>那么什么时候阻塞线程需要被唤醒呢？有两种情况。第一种情况是当消费者看到阻塞队列为空时，开始进入等待，这时生产者一旦往队列中放入数据，就会通知所有的消费者，唤醒阻塞的消费者线程。另一种情况是如果生产者发现队列已经满了，也会被阻塞，而一旦消费者获取数据之后就相当于队列空了一个位置，这时消费者就会通知所有正在阻塞的生产者进行生产，这便是对生产者消费者模式的简单介绍。</p>
<h4 id="如何用-BlockingQueue-实现生产者消费者模式"><a href="#如何用-BlockingQueue-实现生产者消费者模式" class="headerlink" title="如何用 BlockingQueue 实现生产者消费者模式"></a>如何用 BlockingQueue 实现生产者消费者模式</h4><p>我们接下来看如何用 wait&#x2F;notify&#x2F;Condition&#x2F;BlockingQueue 实现生产者消费者模式，先从最简单的 BlockingQueue 开始讲起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                queue.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，首先，创建了一个 ArrayBlockingQueue 类型的 BlockingQueue，命名为 queue 并将它的容量设置为 10；其次，创建一个简单的生产者，while(true) 循环体中的queue.put() 负责往队列添加数据；然后，创建两个生产者线程并启动；同样消费者也非常简单，while(true) 循环体中的 queue.take() 负责消费数据，同时创建两个消费者线程并启动。为了代码简洁并突出设计思想，代码里省略了 try&#x2F;catch 检测，我们不纠结一些语法细节。以上便是利用 BlockingQueue 实现生产者消费者模式的代码。虽然代码非常简单，但实际上 ArrayBlockingQueue 已经在背后完成了很多工作，比如队列满了就去阻塞生产者线程，队列有空就去唤醒生产者线程等。</p>
<h4 id="如何用-Condition-实现生产者消费者模式"><a href="#如何用-Condition-实现生产者消费者模式" class="headerlink" title="如何用 Condition 实现生产者消费者模式"></a>如何用 Condition 实现生产者消费者模式</h4><p>BlockingQueue 实现生产者消费者模式看似简单，背后却暗藏玄机，我们在掌握这种方法的基础上仍需要掌握更复杂的实现方法。我们接下来看如何在掌握了 BlockingQueue 的基础上利用 Condition 实现生产者消费者模式，它们背后的实现原理非常相似，相当于我们自己实现一个简易版的 BlockingQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueueForCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Queue queue;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyBlockingQueueForCondition</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.max = size;</span><br><span class="line">       queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object o)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (queue.size() == max) &#123;</span><br><span class="line">               notFull.await();</span><br><span class="line">           &#125;</span><br><span class="line">           queue.add(o);</span><br><span class="line">           notEmpty.signalAll();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">               notEmpty.await();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">item</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">           notFull.signalAll();</span><br><span class="line">           <span class="keyword">return</span> item;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，首先，定义了一个队列变量 queue 并设置最大容量为 16；其次，定义了一个 ReentrantLock 类型的 Lock 锁，并在 Lock 锁的基础上创建两个 Condition，一个是 notEmpty，另一个是 notFull，分别代表队列没有空和没有满的条件；最后，声明了 put 和 take 这两个核心方法。</p>
<p>因为生产者消费者模式通常是面对多线程的场景，需要一定的同步措施保障线程安全，所以在 put 方法中先将 Lock 锁上，然后，在 while 的条件里检测 queue 是不是已经满了，如果已经满了，则调用 notFull 的 await() 阻塞生产者线程并释放 Lock，如果没有满，则往队列放入数据并利用 notEmpty.signalAll() 通知正在等待的所有消费者并唤醒它们。最后在 finally 中利用 lock.unlock() 方法解锁，把 unlock 方法放在 finally 中是一个基本原则，否则可能会产生无法释放锁的情况。</p>
<p>下面再来看 take 方法，take 方法实际上是与 put 方法相互对应的，同样是通过 while 检查队列是否为空，如果为空，消费者开始等待，如果不为空则从队列中获取数据并通知生产者队列有空余位置，最后在 finally 中解锁。</p>
<p>这里需要注意，我们在 take() 方法中使用 while( queue.size() &#x3D;&#x3D; 0 ) 检查队列状态，而不能用 if( queue.size() &#x3D;&#x3D; 0 )。为什么呢？大家思考这样一种情况，因为生产者消费者往往是多线程的，我们假设有两个消费者，第一个消费者线程获取数据时，发现队列为空，便进入等待状态；因为第一个线程在等待时会释放 Lock 锁，所以第二个消费者可以进入并执行 if( queue.size() &#x3D;&#x3D; 0 )，也发现队列为空，于是第二个线程也进入等待；而此时，如果生产者生产了一个数据，便会唤醒两个消费者线程，而两个线程中只有一个线程可以拿到锁，并执行 queue.remove 操作，另外一个线程因为没有拿到锁而卡在被唤醒的地方，而第一个线程执行完操作后会在 finally 中通过 unlock 解锁，而此时第二个线程便可以拿到被第一个线程释放的锁，继续执行操作，也会去调用 queue.remove 操作，然而这个时候队列已经为空了，所以会抛出 NoSuchElementException 异常，这不符合我们的逻辑。而如果用 while 做检查，当第一个消费者被唤醒得到锁并移除数据之后，第二个线程在执行 remove 前仍会进行 while 检查，发现此时依然满足 queue.size() &#x3D;&#x3D; 0 的条件，就会继续执行 await 方法，避免了获取的数据为 null 或抛出异常的情况。</p>
<h4 id="如何用-wait-x2F-notify-实现生产者消费者模式"><a href="#如何用-wait-x2F-notify-实现生产者消费者模式" class="headerlink" title="如何用 wait&#x2F;notify 实现生产者消费者模式"></a>如何用 wait&#x2F;notify 实现生产者消费者模式</h4><p>最后我们再来看看使用 wait&#x2F;notify 实现生产者消费者模式的方法，实际上实现原理和Condition 是非常类似的，它们是兄弟关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> LinkedList&lt;Object&gt; storage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.maxSize = size;</span><br><span class="line">       storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        storage.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        notifyAll();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">while</span> (storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(storage.remove());</span><br><span class="line">       notifyAll();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，最主要的部分仍是 take 与 put 方法，我们先来看 put 方法，put 方法被 synchronized 保护，while 检查队列是否为满，如果不满就往里放入数据并通过 notifyAll() 唤醒其他线程。同样，take 方法也被 synchronized 修饰，while 检查队列是否为空，如果不为空就获取数据并唤醒其他线程。使用这个 MyBlockingQueue 实现的生产者消费者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     wait形式实现生产者消费者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitStyle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyBlockingQueue</span> <span class="variable">myBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(MyBlockingQueue storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                storage.put();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> MyBlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(MyBlockingQueue storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                storage.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是三种实现生产者消费者模式的讲解，其中，第一种 BlockingQueue 模式实现比较简单，但其背后的实现原理在第二种、第三种实现方法中得以体现，第二种、第三种实现方法本质上是我们自己实现了 BlockingQueue 的一些核心逻辑，供生产者与消费者使用。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>java</tag>
        <tag>lock</tag>
        <tag>BlockingQueue</tag>
      </tags>
  </entry>
</search>
